% LaTeX source for textbook ``Physical Modeling in Octave''
% Copyright 2011 Allen B. Downey.

% License: Creative Commons Attribution-NonCommercial 3.0 Unported License.
% http://creativecommons.org/licenses/by-nc/3.0/
%

\documentclass[12pt]{book}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{url}
\usepackage{makeidx}
\usepackage[symbol*]{footmisc}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{hevea}                           
\usepackage{upquote}
\usepackage{times}

\newcommand{\myreg}{\textsuperscript{{\tiny \textregistered}}}

\sloppy

\pagestyle{fancyplain}

\renewcommand{\chaptermark}[1]{\markboth{#1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}{}}

\lhead[\fancyplain{}{\bfseries\thepage}]%
      {\fancyplain{}{\bfseries\rightmark}}
\rhead[\fancyplain{}{\bfseries\leftmark}]%
      {\fancyplain{}{\bfseries\thepage}}
\cfoot{}

\renewcommand\MakeUppercase{}

\newenvironment{code}{\vspace{0.6\parskip} \begin{verbatim}}{\end{verbatim} \vspace{0.6\parskip}}

% these styles get translated in CSS for the HTML version
% \newstyle{a:link}{color:black;}
% \newstyle{p+p}{margin-top:1em;margin-bottom:1em}
%\newstyle{img}{border:0px}

% change the arrows
%% \setlinkstext
%%   {\imgsrc[ALT="Previous"]{back.png}}
%%   {\imgsrc[ALT="Up"]{up.png}}
%%   {\imgsrc[ALT="Next"]{next.png}}
\usepackage[utf8]{vietnam}
\makeindex

\begin{document}

\frontmatter

%\blankpage
%\blankpage

\newcommand{\thetitle}{Mô hình hóa các hiện tượng vật lý bằng Octave(R)}
\newcommand{\theversion}{1.1.6}

\title {\thetitle}
\author {Allen B. Downey}
\date {Version \theversion}

%% \input{latexonly}
%% 
%% \begin{latexonly}

%\blankpage
%\blankpage

% TITLE PAGES FOR LATEX VERSION

%% \maketitle

\vspace{2in}

\begin{center}
{\Large \thetitle}

\vspace{0.25in}

Original book: Physical Modeling with Octave

Copyright 2011 Allen B. Downey
\end{center}

\vspace{0.25in}

\begin{flushleft}
Green Tea Press       \\
9 Washburn Ave \\
Needham MA 02492
\end{flushleft}

Permission is granted to copy, distribute, and/or modify this document
under the terms of the GNU Free Documentation License, which is available 
at \url{http://www.gnu.org/copyleft/fdl.html}.

The original form of this book is \LaTeX\ source code.  Compiling this
code has the effect of generating a device-independent representation
of a textbook, which can be converted to other formats and printed.

This book was typeset by the author using latex, dvips and ps2pdf,
among other free, open-source programs.
The LaTeX source for this book is available from
\url{http://greenteapress.com/matlab}.

Nguyễn Quang Chiến đã dịch bản gốc cuốn sách trên và thay đổi một số chỗ để 
phù hợp với phần mềm Octave.

Octave (tên đầy đủ: GNU Octave) là phần mềm mã nguồn mở, bản quyền thuộc về
John W. Eaton. Bạn có thể tải chương trình về dùng và phân phát miễn phí. Chi tiết
xin xem tại: \url{http://www.gnu.org/software/octave/}.

Cuốn sách tiếng Việt này được phát hành theo giấy phép GNU Free Documentation
License 1.3. Bạn được quyền in, sao chép, phân phát cuốn sách này miễn phí. Nhớ
kèm theo trang này để người đọc biết về giấy phép phát hành cuốn sách. 

%% \end{latexonly}


% HTMLONLY

%% \begin{htmlonly}
%% 
%% % TITLE PAGE FOR HTML VERSION
%% 
%% {\Large \thetitle}
%% 
%% {\large Allen B. Downey}
%% 
%% Version \theversion
%% 
%% Copyright 2011 Allen B. Downey
%% Copyright 2011 translation to Vietnamese by Nguyễn Quang Chiến
%% 
%% \vspace{0.25in}
%% 
%% Permission is granted to copy, distribute, and/or modify this document
%% under the terms of the Creative Commons Attribution-NonCommercial 3.0
%% Unported License, which is available at
%% \url{http://creativecommons.org/licenses/by-nc/3.0/}.
%% 
%% \setcounter{chapter}{-1}
%% 
%% \end{htmlonly}


\chapter{Lời giới thiệu theo ý tưởng của tác giả Allen B. Downey}

Hầu hết các cuốn sách đề cập đến MATLAB đang được bán hiện nay đều 
dành cho người đọc đã biết lập trình. Cuốn sách này dành cho những 
người chưa từng lập trình từ trước, và dùng Octave thay cho MATLAB,
để phù hợp với tinh thần tự do như chính bản thân nội dung cuốn sách.

Tôi sẽ sắp xếp bố cục cuốn sách này cho phù hợp: mở đầu là
các giá trị số vô hướng, rồi tiếp tục với véc-tơ và ma trận. Cách học 
này rất tốt với người mới bắt đầu lập trình, vì thật khó hiểu được
những kiểu đối tượng dữ liệu phức tạp trước khi bạn hiểu ý nghĩa
căn bản của lập trình. Nhưng có những vấn đề sau đây nảy sinh:

\begin{itemize}

\item Tài liệu Octave được viết dưới dạng các ma trận, và các
thông báo lỗi cũng vậy. Để hạn chế nhược điểm này, cuốn sách
giải thích các thuật ngữ cần thiết từ sớm và giải mã một số 
thông báo lỗi có thể làm người bắt đầu thấy khó hiểu.

\item Nhiều ví dụ trong nửa đầu cuốn sách không phải là viết theo
phong cách Octave thực sự. Tôi nhận định lại vấn đề này trong phần
nửa sau cuốn sách bằng việc chuyển chúng về phong cách chính thống
hơn.

\end{itemize}

Cuốn sách này nhấn mạnh về các hàm số, một phần là vì chúng là 
cơ chế quan trọng chi phối độ phức tạp của chương trình, và cũng 
vì chúng rất có ích khi làm việc với các công cụ của Octave như 
{\tt fzero} và {\tt ode45}.

Tôi coi rằng bạn đọc đã biết môn toán giải tích, phương trình vi phân,
và vật lý, nhưng không cần đại số tuyến tính. Tôi sẽ giải thích về toán
trong suốt nội dung sách, nhưng bạn cũng cần biết toán để nắm được
những đoạn giải thích đó.

Có những bài tập nhỏ trong từng chương, và một số bài tập lớn hơn
ở cuối những chương nhất định.

Nếu bạn muốn góp ý và sửa chữa nội dung cuốn sách, hãy gửi ý kiến
phản hồi đến blog của tôi, trong mục MatLab 
({\tt http://quangchien.wordpress.com/category/matlab/mo-hinh-hoa/}).


% ENDCONTRIB

\tableofcontents

\mainmatter

\chapter*{Cách cài đặt Octave}

Nếu máy bạn dùng Windows thì có hai cách sau đây:
\begin{enumerate}

\item Dùng gói Octave-forge từ trang web \url{http://octave.sourceforge.net/},
bên dưới có đường link đến Windows Installer. Sau khi tải file về cài đặt, bạn 
chỉ cần theo hướng dẫn trên máy. 
% Sau khi cài xong, bạn có thể tiếp tục cài
% phần mềm phụ trợ cho giao diện như GUI Octave \url{http://sites.google.com/site/guioctave/}
% hoặc QtOctave \url{http://qtoctave.wordpress.com/}.  
Bằng cách này bạn có bản Octave tương đối cũ là 3.2.4 (khi tôi thử dùng tháng
11/2011).  
%Sau khi cài đặt, náy đúp vào biểu tượng Octave bạn sẽ thấy cửa sổ
% lệnh xuất hiện.

\item Dùng Octave trong môi trường Cygwin. Điều này đảm bảo cho bạn có phiên bản 
mới của Octave. Tuy nhiên, cần một số thao tác thủ công để chỉnh sửa cấu hình
đồ họa mới có thể dùng được Octave trọn vẹn. Đầu tiên, bạn tải Cygwin về từ địa chỉ \url{www.cygwin.com} và 
cài đặt. Máy tính sẽ nhắc bạn cần gỡ các bản Cygwin đã cài từ trước (nếu có). Nếu 
bạn là người mới dùng, hãy bỏ qua thông báo này. Sau đó bạn chọn phương thức 
tải về và cài đặt (Download and Install), chọn một trạm (mirror) để tải về. 

Bây giờ sẽ có một bảng danh sách các thư viện / gói chương trình được liệt kê. 
Hãy vào mục Math, chọn các gói sau [các con số đứng đằng sau là số phiên bản 
mà tôi thấy trong tháng 11/2011].
\begin{verbatim}
octave 3.4.2-3
octave-devel 3.4.2-3
octave-doc 3.4.2-3
octave-forge  20110730-1
gnuplot 4.4.4-1
xinit 
\end{verbatim}
Sau khi chấp nhận, máy sẽ báo cho bạn các gói phụ trợ sẽ được cài đặt cùng. 
Bạn tiếp tục chấp nhận. Sau khi hoàn tất cài đặt vào ổ cứng, bạn phải bật
cửa sổ lệnh Cygwin rồi chỉnh cấu hình đồ họa. 

\end{enumerate}

Nếu dùng các hệ điều hành tựa UNIX (chẳng hạn các bản phân phối Linux) bạn có thể
tự cài thông qua kho phần mềm của hệ điều hành. Chẳng hạn, đối với Ubuntu:
\begin{verbatim}
$ sudo apt-get install octave
\end{verbatim}
Nhưng cách này cũng chỉ cho bạn phiên bản Octave 3.2.4. Để có được phiên bản
Octave 3.4.2, bạn phải biên dịch từ mã nguồn. Khởi động Octave chỉ cần gõ
\begin{verbatim}
$ octave
\end{verbatim}
%
Điều này cũng đúng với hệ Cygwin.

Khi thực hành trên các hệ thống khác nhau, chỉ có hình thức biểu diễn đường dẫn
thư mục là khác nhau đôi chút: dấu gạch chéo ngược (\verb#\#) trong Windows 
được thay bằng dấu gạch xuôi (\verb#/#) trong Unix. Kết quả phép tính không
phụ thuộc vào hệ thống. Để thống nhất, tôi sử dụng hệ Windows.


% chap01
\chapter{Các biến và giá trị}

\section{Chiếc máy tính tay}
\label{calc}

Phần cốt lõi của Octave là một chiếc máy tính tay. Khi kích chuột vào biểu tượng 
Octave từ Windows, bạn sẽ thấy ở cửa sổ hiện một dòng chữ chào người dùng và 
thông tin về phiên bản Octave đang chạy, tiếp theo là dấu 
\begin{verbatim}
octave:1>
\end{verbatim}
%
\noindent vốn là {\bf dấu nhắc} của Octave; tức là ký hiệu dùng để nhắc bạn nhập vào một
câu lệnh. Ở đây con số \texttt{1} là để chỉ dòng lệnh thứ nhất trong lần chạy Octave này.
Vì số thứ tự này không quá quan trọng nên để đơn giản, trong những lần sau ta 
kí hiệu dấu nhắc là \verb">>".

Dạng câu lệnh đơn giản nhất là một {\bf biểu thức} toán học, vốn được 
hợp thành từ các {\bf toán hạng} (ví dụ như các số) và các 
{\bf toán tử} (như dấu cộng, {\tt +}).

Nếu bạn gõ vào một biểu thức và ấn Enter (hoặc Return), Octave sẽ 
{\bf lượng giá} biểu thức và in ra kết quả.

\begin{verbatim}
>> 2 + 1
ans = 3
\end{verbatim}
%
Để nói rõ hơn: trong ví dụ trên, Octave tự in ra \verb#>>#; tôi  
gõ vào {\tt 2 + 1} và ấn Enter, rồi Octave lại in ra {\tt ans = 3}.
Khi tôi nói là ``in'', điều đó có nghĩa là ``hiện lên màn hình''. Điều này
có thể làm bạn thoạt đầu thấy dễ lẫn, nhưng đó chính là cách mọi người
vẫn nói.

Một biểu thức có thể bao gồm bao nhiêu toán tử và toán hạng cũng được.
Bạn không cần phải gõ các dấu cách; một số người gõ và một số người không.

\begin{verbatim}
>> 1+2+3+4+5+6+7+8+9
ans = 45
\end{verbatim}
%
Lại nói về dấu cách, bạn có thể nhận thấy rằng Octave chèn vào một số
dấu cách giữa {\tt ans =} và kết quả. Trong các ví dụ tôi sẽ bỏ bớt khoảng
cách này để tiết kiệm chỗ.

Các toán tử số học khác cũng giống như bạn đã biết. Phép trừ kí hiệu 
bởi dấu {\tt -}; phép nhân bởi một dấu sao, {\tt *}; phép chia bởi dấu 
gạch chéo xuôi {\tt /}.

\begin{verbatim}
>> 2*3 - 4/5
ans = 5.2000
\end{verbatim}
%
Thứ tự thực hiện phép toán cũng giống như trong môn đại số: các phép 
nhân và chia được thực hiện trước các phép cộng và trừ. Bạn có thể dùng
cặp ngoặc đơn để thay đổi thứ tự tính.

\begin{verbatim}
>> 2 * (3-4) / 5
ans = -0.4000
\end{verbatim}
%
Khi thêm vào cặp ngoặc đơn, tôi cũng đồng thời thay đổi độ dãn cách
để ta dễ đọc hơn. Đây là một trong những gợi ý về cách trình bày trong
cuốn sách, để chương trình được dễ đọc. Bản thân phong cách không
làm ảnh hưởng đến tính năng của chương trình; trình thông dịch Octave
không kiểm tra phong cách. Nhưng người đọc thì có, và quan trọng nhất
bạn chính là người đọc thường xuyên nhất các mã lệnh bạn viết ra. 

Từ đó dẫn đến định lý thứ nhất về gỡ lỗi chương trình:

\begin{quote}
Mã lệnh dễ đọc cũng dễ gỡ lỗi.
\end{quote}

Thời gian bạn bỏ ra để làm đẹp mã lệnh hoàn toàn xác đáng; điều này sẽ giúp
bạn tiết kiệm thời gian gỡ lỗi!

Toán tử thông dụng tiếp đến là lũy thừa, với ký hiệu \verb+^+,
đôi khi còn được gọi là ``dấu mũ''. Số 2 nâng lên lũy thừa 16 là

\begin{verbatim}
>> 2^16
ans = 65536
\end{verbatim}
%
Cũng như trong đại số cơ bản, phép lũy thừa được thực hiện trước các phép 
nhân và chia, nhưng một lần nữa, bạn có thể dùng cặp ngoặc tròn để thay
đổi thứ tự thực hiện phép tính.


\section{Các hàm toán học}

Octave biết cách tính gần như mọi hàm toán học bạn biết đến. Nó
biết tất cả các hàm lượng giác; sau đây là cách dùng:

\begin{verbatim}
>> sin(1)
ans = 0.8415
\end{verbatim}
%
Lệnh này là một ví dụ của một {\bf lời gọi hàm}. Tên của hàm này là
{\tt sin}, vốn là ký hiệu thông dụng của hàm lượng giác sin. Giá trị trong
cặp ngoặc tròn được gọi là {\bf đối số}. Tất cả các hàm lượng giác 
trong Octave đều tính theo ra-đian.

Một số hàm nhận nhiều đối số, khi đó chúng được phân cách bởi cách
dấu phẩy. Chẳng hạn, {\tt atan2} dùng để tính nghịch đảo của hàm tan,
vốn là góc tính theo ra-đian giữa chiều dương trục x và điểm có các
tọa độ $y$ và $x$ cho trước.

\begin{verbatim}
>> atan2(1,1)
ans = 0.7854
\end{verbatim}
%
Nếu bạn không rành chút kiến thức lượng giác trên thì cũng không nên
lo lắng. Đó chỉ là một ví dụ cho thấy hàm có nhiều đối số.

Octave cũng có các hàm lũy thừa, như {\tt exp}, dùng để tính số
$e$ nâng lên một số mũ cho trước. Vì vậy {\tt exp(1)} chính là $e$.

\begin{verbatim}
>> exp(1)
ans = 2.7183
\end{verbatim}
%
Nghịch đảo của {\tt exp} là {\tt log}, nhằm tính loga cơ số $e$:

\begin{verbatim}
>> log(exp(3))
ans = 3
\end{verbatim}
%
Ví dụ này cũng cho thấy các lời gọi hàm có thể {\bf lồng ghép} được;
nghĩa là bạn có thể dùng kết quả tính được từ hàm này để làm đối số
cho một hàm khác.

Một cách tổng quát hơn, bạn có thể dùng lời gọi một hàm như là toán
hạng cho một biểu thức.

\begin{verbatim}
>> sqrt(sin(0.5)^2 + cos(0.5)^2)
ans = 1
\end{verbatim}
%
Như bạn có thể đoán được, {\tt sqrt} có tác dụng tính căn bậc hai.

Còn có rất nhiều hàm toán học khác, nhưng cuốn sách này không 
nhằm mục đích là một cuốn sổ tra cứu. Để biết cách dùng các hàm
khác, bạn cần phải đọc các đoạn thông tin giải thích từng hàm.


\section{Thông tin về hàm}

Octave đi kèm theo hai dạng thông tin trực tuyến giải thích cách dùng hàm, 
đó là {\tt help} và {\tt doc}.

Lệnh \texttt{help} hoạt động trong cửa sổ lệnh; bạn chỉ cần gõ {\tt help}
theo sau là tên của lệnh.

\begin{verbatim}
>> help sin
`sin' is a built-in function

 -- Mapping Function:  sin (X)
     Compute the sine for each element of X in radians.

     See also: asin, sind, sinh

Additional help for built-in functions and operators is
available in the on-line version of the manual.  Use the 
command `doc <topic>' to search the manual index.

Help and information about Octave is also available on the 
WWW at http://www.octave.org and via the help@octave.org
mailing list.
\end{verbatim}
%
Bạn cần lưu ý rằng tên hàm phải được viết chữ thường. Nếu viết
chữ in, bạn sẽ thấy có lỗi kiểu như sau:

\begin{verbatim}
>> SIN(1)
error: `SIN' undefined near line 27 column 1
\end{verbatim}
%
Một vấn đề khác là có những từ trong thông tin trợ giúp mà bạn vẫn
còn chưa biết nghĩa. Chẳng hạn, ``the elements of X'' (phần tử của X);
bạn chỉ hiểu được sau khi đọc đến mục véc-tơ và ma trận sau đây
mấy chương.

Các trang \texttt{doc} thường tốt hơn. Nếu bạn gõ {\tt doc sin}, một
cửa sổ sẽ xuất hiện với các thông tin chi tiết về hàm này, các hàm liên quan 
và cả những ví dụ về cách dùng (nếu có). Những ví dụ này đôi khi có véc-tơ
và ma trận, giờ thì bạn chưa hiểu, nhưng có thể sẽ biết qua về những
nội dung sắp tới. Sau khi di chuyển quanh trang thông tin này bạn có thể
gõ phím \texttt{q} để đóng lại và trở về Octave.


\section{Biến}

Một trong những đặc điểm giúp Octave mạnh hơn một máy tính tay
là khả năng đặt tên cho một giá trị. Một giá trị sau khi đã đặt tên
được gọi là một {\bf biến}.

Octave đi kèm theo một số giá trị định sẵn. Chẳng hạn
\footnote{Xét về mặt kỹ thuật thì {\tt pi} là một hàm chứ không phải
một biến, nhưng hiện giờ ta tạm coi nó như vậy.}, cái tên {\tt pi} dùng để chỉ
đại lượng $\pi$ trong toán học, vốn gần bằng

\begin{verbatim}
>> pi
ans = 3.1416
\end{verbatim}
%
Và nếu bạn làm bất cứ phép tính nào với số phức, có thể bạn sẽ thấy tiện
khi dùng {\tt i} hoặc {\tt j} vốn được định nghĩa sẵn là căn bậc hai 
của $-1$.

Bạn có thể dùng một tên biến ở bất cứ chỗ nào viết được một số; chẳng hạn,
như toán hạng trong một biểu thức:

\begin{verbatim}
>> pi * 3^2
ans = 28.274
\end{verbatim}
%
hoặc như đối số cho một hàm:

\begin{verbatim}
>> sin(pi/2)
ans = 1

>> exp(i * pi)
ans = -1.0000e+00 + 1.2246e-16i
\end{verbatim}
%
Kí hiệu {\tt e} trong cách viết này {\em không phải} là hằng số mũ 
$e$; nó chỉ là chữ viết tắt của ``exponent'' (lũy thừa), cụ thể là
lũy thừa với cơ số bằng 10. Như vậy kết quả của phép tính thứ hai
bằng $-1 \times 10^0 + 1.2246 \times 10^{-16} i $, hay 
$-1 + 0 \cdot i $. 
Octave thực hiện tính toán với số phức. Ví dụ này minh họa cho đẳng thức Euler:
$e^{i \pi} = -1$.

Mỗi khi lượng giá một biểu thức, Octave gán giá trị cho một biến
có tên là {\tt ans}.  Bạn có thể dùng {\tt ans} trong phép tính tiếp
theo như một cách viết tắt cho ``giá trị của biểu thức liền trước''.

\begin{verbatim}
>> 3^2 + 4^2
ans = 25

>> sqrt(ans)
ans = 5
\end{verbatim}
%
Nhưng nhớ rằng giá trị của {\tt ans} lại thay đổi mỗi khi bạn lượng
giá một biểu thức.


\section{Lệnh gán}

Bạn có thể tự tạo các biến và cho chúng các giá trị, bằng cách dùng
{\bf lệnh gán}. Toán tử gán là dấu bằng, {\tt =}.

\begin{verbatim}
>> x = 6 * 7
x = 42
\end{verbatim}
%
Ví dụ này tạo ra một biến mới có tên là {\tt x} và gán cho nó giá trị
của biểu thức {\tt 6 * 7}.  Octave trả lời lại với tên biến và
giá trị tính được.

Trong mỗi câu lệnh gán, vế trái phải là một tên biến hợp lệ. Vế phải
có thể là một biểu thức bất kì, bao gồm cả lời gọi hàm.

Hầu như bất kỳ dãy chữ cái viết thường và viết in nào cũng tạo nên
một tên biến hợp lệ. Một số dấu nhất định cũng hợp lệ, nhưng chỉ có
dấu gạch thấp, {\tt \_}, là kí hiệu thông dung nhất. Các chữ số cũng
được, nhưng không được đặt chúng ở đầu tên biến. Không được dùng
các dáu cách. Các tên biến đều có sự phân biệt giữa chữ in và chữ
thường, vì vậy {\tt x} và {\tt X} là các biến khác nhau.

\begin{verbatim}
>> fibonacci0 = 1;

>> LENGTH = 10;

>> first_name = 'allen'
first_name = allen
\end{verbatim}
%
Hai ví dụ đầu cho thấy cách dùng của dấu chấm phẩy, dùng để ngăn
không cho in ra kết quả của câu lệnh. Trong trường hợp này Octave
tạo ra biến và gán nó với giá trị, nhưng không hiển thị gì.

Ví dụ thứ ba cho thấy rằng không phải mọi thứ trong Octave đều
là con số. Một dãy các ký tự trong cặp dấu nháy đơn được gọi là
một {\bf chuỗi}.

Mặc dù {\tt i}, {\tt j} và {\tt pi} đều được định nghĩa trước nhưng
bạn hoàn toàn có thể gán lại chúng. Việc dùng {\tt i} và {\tt j} vào
mục đích khác cũng thường thấy, song có lẽ sẽ không hay nếu ta
đổi giá trị của {\tt pi}!

\section{Tại sao phải dùng biến?}

Các lý do chung lý giải cho việc dùng biến là

\begin{itemize}

\item Để tránh việc tính lại một giá trị được dùng lặp lại nhiều lần.
Chẳng hạn, nếu bạn thực hiện tính toán liên quan đến $e$, có thể
bạn sẽ muốn tính nó một lần và lưu lại kết quả.

\begin{verbatim}
>> e = exp(1)
e = 2.7183
\end{verbatim}


\item Để làm cho sự gắn kết giữa mã lệnh và cơ sở toán học trở nên
rõ ràng hơn. Nếu bạn tính diện tích của một hình tròn, có thể bạn muốn
dùng một biến có tên là {\tt r}:

\begin{verbatim}
>> r = 3
r = 3

>> area = pi * r^2
area = 28.274
\end{verbatim}
%
Bằng cách này mã lệnh viết ra sẽ giống với công thức quen thuộc $\pi r^2$.


\item Để chẻ nhỏ một phép tính dài thành một loạt các bước. Chẳng hạn
bạn phải lượng giá một biểu thức đồ sộ, gai góc như sau:

\begin{verbatim}
ans = ((x - theta) * sqrt(2 * pi) * sigma) ^ -1 * ...
exp(-1/2 * (log(x - theta) - zeta)^2 / sigma^2)
\end{verbatim}
%
Bạn có thể dùng dấu ba chấm để tách một biểu thức thành nhiều dòng.
Chỉ việc gõ vào {\tt ...} ở cuối dòng trên rồi tiếp tục gõ xuống dòng dưới.

Nhưng cách tốt hơn thường là chia phép tính thành một loạt các bước
kế tiếp và gán những kết quả trung gian cho các biến.

\begin{verbatim}
shiftx = x - theta
denom = shiftx * sqrt(2 * pi) * sigma
temp = (log(shiftx) - zeta) / sigma
exponent = -1/2 * temp^2
ans = exp(exponent) / denom
\end{verbatim}
%
Tên của các biến trung gian giải thích vai trò của chúng trong phép tính.
{\tt shiftx} là giá trị của {\tt x} bị dịch chuyển đi {\tt theta} đơn vị. Cũng 
dễ hiểu khi đặt {\tt exponent} là đối số cho hàm {\tt exp}, và {\tt denom} 
thay thế cho mẫu số. Việc chọn những cái tên có nghĩa làm cho mã lệnh 
dễ đọc và dễ hiểu (xem Định lý thứ nhất về gỡ lỗi).

\end{itemize}


\section{Lỗi}

Tuy giờ còn sớm nhưng rất có thể bạn đã bắt đầu mắc lỗi khi lập trình.
Mỗi khi học thêm được một đặc điểm mới của Octave, bạn cần phải
thử để gây ra lỗi, càng nhiều càng tốt, càng sớm càng tốt.

Khi bạn cố ý gây ra lỗi, bạn sẽ thấy các thông báo lỗi trông như thế nào.
Sau này, khi bạn vô tình mắc lỗi, bạn sẽ hiểu được những thông báo lỗi
khi đó có ý gì.

Một lỗi hay gặp ở người mới lập trình là việc bỏ qua dấu {\tt *} trong
phép nhân.

\begin{verbatim}
>> area = pi r^2
parse error:
  syntax error
>>> area = pi r^2
              ^
\end{verbatim}
%
Thông báo lỗi chỉ ra rằng, có một lỗi cú pháp, cụ thể là lỗi phân tách (parse)
các thành phần trong biểu thức để tính toán. Sau khi thấy toán hạng {\tt pi},
Octave chờ một toán tử, chẳng hạn {\tt *}.  Nhưng thay vào đó,
nó nhận được một tên biến; như vậy đã có lỗi xảy ra ở vị trí được chỉ bởi dấu 
dấu mũ, \verb#^# (còn gọi là ``caret'').

Một lỗi hay gặp khác là việc bỏ quên cặp ngoặc tròn bao quanh các
đối số của một hàm. Chẳng hạn, trong cách viết toán học, ta thường 
ghi $\sin \pi$, nhưng trong Octave thì không được như vậy.

\begin{verbatim}
>> sin pi
ans =   -0.89000  -0.97054
\end{verbatim}
%
Gì vậy nhỉ, có kết quả đấy chứ? Ồ, có điều không ổn rồi; tại sao lại có
hai đáp số? Vấn đề ở đây là khi bạn bỏ mất cặp ngoặc, Octave sẽ coi như 
đối số là một chuỗi kí tự (thay vì một biểu thức). Và phép tính với một dãy
các giá trị sẽ được đề cập đến sau, khi ta làm quen với véc-tơ. Tình trạng 
tương tự cũng xảy ra khi bạn gõ vào:

\begin{verbatim}
>> abs pi
ans =  112   105
\end{verbatim}
%
Cái ``đặc điểm ngôn ngữ'' này có lý do riêng của nó, nhưng thay vì tìm
hiểu ngay bây giờ, tôi khuyên bạn nên {\em luôn luôn} viết cặp ngoặc
tròn bao quanh các đối số.

Ví dụ này minh họa cho Định lý thứ hai của việc gỡ lỗi.

\begin{quote}
Điều duy nhất còn tồi tệ hơn cả việc nhận được thông báo lỗi là việc 
{\em không} nhận được thông báo lỗi nào.
\end{quote}
%
Những người mới bắt đầu lập trình ghét các thông báo lỗi và tìm mọi cách
xua đuổi chúng đi. Những người lập trình có kinh nghiệm hiểu rằng thông
báo lỗi là người bạn của họ. Chúng có thể khó hiểu, và thậm chí có thể
đánh lạc hướng, nhưng công sức bỏ ra đểu hiểu được chúng sẽ được
đền bù xứng đáng.

Sau đây là một lỗi thông thường khác của người mới bắt đầu. Nếu bạn 
chuyển biểu thức toán sau đây sang Octave:

\[ \frac{1}{2 \sqrt \pi}\]

Bạn có thể muốn viết như sau:

\begin{verbatim}
1 / 2 * sqrt(pi)
\end{verbatim}
%
Nhưng cách này sai. Rất sai.


\section{Phép toán số học với số có phần thập phân}

Trong toán học, có một vài loại số: số nguyên, số thực, hữu tỉ, vô tỉ,
số ảo, số phức, v.v. Octave chỉ có một kiểu số, đó là số có phần
thập phân, chính xác hơn là {\bf dấu phẩy động}.

Bạn có thể đã nhận thấy rằng Octave biểu thị các giá trị theo cách
viết có phần thập phân. Vì vậy, số hữu tỉ $1/3$ chẳng hạn được biểu
diễn bởi giá trị phẩy động như sau

\begin{verbatim}
>> 1/3
ans = 0.33333
\end{verbatim}
%
\noindent vốn chỉ gần đúng. Thực ra nó không đến nỗi dở như ta
có thể hình dung; Octave dùng nhiều chữ số hơn là nó biểu
diễn (hiển thị) trên màn hình. Bạn có thể thay đổi {\tt format} 
(định dạng) để thấy các chữ số còn lại.

\begin{verbatim}
>> format long
>> 1/3
ans =  0.333333333333333
\end{verbatim}
%
Ở bên trong, Octave dùng dạng dấu phẩy động IEEE với độ
chính xác kép, vốn có khoảng 15 chữ số có nghĩa (theo hệ thập
phân). Các chữ số không đứng ở đầu hoặc cuối không được
tính là chữ số ``có nghĩa'', vì vậy Octave có thể biểu diễn cả
những số lớn lẫn nhỏ với cùng lượng chữ số có nghĩa như vậy.

Những giá trị rất lớn và rất nhỏ được biểu diễn theo cách viết
khoa học.

\begin{verbatim}
>> factorial(100)
ans =  9.33262154439422e+157
\end{verbatim}
%
Như vậy ở đây, 
$100!$ xấp xỉ với $9.33 \times 10^{157}$.  Đáp số chính là một 
số nguyên gồm 158 chữ số, nhưng ở đây ta chỉ biết được 16
chữ số đầu tiên.

Bạn có thể tự nhập vào các số theo cách viết tương tự.

\begin{verbatim}
>> speed_of_light = 3.0e8
speed_of_light = 300000000
\end{verbatim}
%
Dù Octave có thể xử lý được những số lớn, nhưng vẫn có một giới hạn.
Các biến được định nghĩa trước, {\tt realmax} và {\tt realmin}, chứa các 
giá trị số lớn nhất và nhỏ nhất mà Octave có thể xử lý\footnote{Các
tên biến này dễ gây nhầm lẫn; số có dấu phẩy động đôi khi được gọi
nhầm là ``real'' (số thực).}.

\begin{verbatim}
>> realmax
ans = 1.79769313486232e+308

>> realmin
ans = 2.22507385850720e-308
\end{verbatim}
%
Nếu kết quả tính toán quá lớn, Octave sẽ ``làm tròn lên'' thành
vô cùng.

\begin{verbatim}
>> factorial(170)
ans = 7.25741561530806e+306

>> factorial(171)
ans = Inf
\end{verbatim}
%
Phép chia cho số không cũng trả lại kết quả {\tt Inf}, nhưng trong 
trường hợp này Octave sẽ cảnh báo bạn vì phép chia cho không
thường được coi là không xác định.

\begin{verbatim}
>> 1/0
warning: division by zero
ans = Inf
\end{verbatim}
%
Một lời cảnh báo cũng giống như một thông báo lỗi nhưng ``vô hại''; 
việc tính toán vẫn được tiếp tục. Việc để cho {\tt Inf} tiếp tục lan 
truyền đi trong phép tính thường không cho kết quả như bạn mong đợi,
nhưng nếu bạn cẩn thận khi dùng nó, {\tt Inf} có thể sẽ hữu ích.

Với những phép tính thực sự không xác định, Octave sẽ trả lại {\tt NaN},
là viết tắt của ``not a number'' (không phải một con số).

\begin{verbatim}
>> 0/0
warning: division by zero
ans = NaN
\end{verbatim}



\section{Lời chú thích}

Ngoài những câu lệnh cấu thành chương trình, sẽ rất có ích nếu ta kèm
thêm những lời chú thích để đưa thêm thông tin về chương trình. Dấu
phần trăm {\tt \%} ngăn cách lời chú thích với mã lệnh.

\begin{verbatim}
>> speed_of_light = 3.0e8     % meters per second
speed_of_light = 300000000
\end{verbatim}
%
Lời chú thích chạy từ dấu phần trăm về cuối dòng. Ở trường hợp trên
nó giải thích về đơn vị của giá trị. Bạn có thể tưởng tượng rằng Octave
sẽ giúp việc theo dõi các đơn vị và thao tác với chúng qua từng phép tính,
nhưng thật ra gánh nặng đó được đặt lên vai người lập trình.

Lời chú thích không ảnh hưởng đến việc thực thi chương trình. Chúng
chỉ dành cho người đọc. Những lời chú thích hợp lý sẽ làm chương trình
dễ đọc hơn, nhưng chú thích dở thì vô dụng hoặc (còn tệ hơn nữa)
có thể gây nhầm lẫn.

Hãy tránh việc đặt những lời chú thích thừa:

\begin{verbatim}
>> x = 5        % assign the value 5 to x
\end{verbatim}
%
Những lời chú thích hay phải bổ sung thông tin vốn không có sẵn trong
câu lệnh, như ở ví dụ trên, phải nói về ý nghĩa của biến:

\begin{verbatim}
>> p = 0         % position from the origin in meters 
>> v = 100       % velocity in meters / second
>> a = -9.8      % acceleration of gravity in meters / second^2
\end{verbatim}
%
Nếu bạn dùng các tên biến dài thì bạn có thể cũng không cần những
lời chú thích như vậy, nhưng điều này lại bất tiện ở chỗ: câu lệnh dài
sẽ khó đọc hơn. Ngoài ra, nếu bạn chuyển từ biểu thức toán vốn 
dùng tên biến ngắn thì chương trình bạn nên thống nhất với công
thức toán học.

\section{Thuật ngữ}

\begin{description}

\item[trình thông dịch:] Chương trình làm nhiệm vụ đọc và thực thi mã lệnh Octave.

\item[mã lệnh:] Dòng lệnh Octave được thực thi bởi trình thông dịch.

\item[dấu nhắc:] Ký hiệu mà trình thông dịch in ra để chỉ rằng nó đang 
đợi bạn gõ vào một câu lệnh.

\item[toán tử:] Một trong các kí hiệu, như {\tt *} và {\tt +}, để biểu thị cho 
các phép toán.

\item[toán hạng:] Một số hoặc một biến xuất hiện trong biểu thức bên cạnh 
các toán tử.

\item[biểu thức:] Dãy các toán hạng và toán tử để biểu thị một phép toán 
và trả lại một giá trị.

\item[giá trị:] Kết quả số của một phép tính.

\item[lượng giá:] Tính giá trị của một biểu thức.

\item[thứ tự tính toán:] Quy tắc chỉ định những phép toán nào trong một 
biểu thức sẽ được thực hiện trước.

\item[hàm:] Một phép tính được đặt tên; chẳng hạn {\tt log10} là tên hàm
dùng để tính loga cơ số 10.

\item[gọi:] Để hàm được thực thi và tính một kết quả.

\item[lời gọi hàm:] Dạng câu lệnh để thực thi một hàm.

\item[đối số:] Biểu thức xuất hiện trong một lời gọi hàm để chỉ định các
giá trị mà hàm thao tác với.

\item[lời gọi hàm lồng ghép:] Biểu thức trong đó dùng kết quả của một 
lời gọi hàm làm đối số cho một lời gọi hàm khác.

\item[biến:] Một giá trị được đặt tên.   

\item[lệnh gán:] Lệnh tạo ra một biến mới (nếu cần) và cho nó một
giá trị.

\item[chuỗi:] Giá trị bao gồm một dãy các kí tự (đối ngược với một con số).

\item[dấu phẩy động:] Kiểu số mà Octave sử dụng. Tất cả các số có
dấu phẩy động đều biểu diễn được với khoảng 16 chữ số trong phần 
thập phân (khác với các số nguyên và số thực trong toán học).

\item[cách viết khoa học:] Một dạng viết và biểu thị các số lớn và nhỏ;
chẳng hạn {\tt 3.0e8} để biểu thị cho $\mbox{3,0} \times 10^8$
hay 300.000.000.  

\item[lời chú thích:] Phần của chương trình nhằm cung cấp thêm thông tin
về chương trình, nhưng không ảnh hưởng đến việc thực thi nó.

\end{description}


\section{Bài tập}

\newtheoremstyle{myex}% name
     {9pt}%      Space above
     {9pt}%      Space below
     {\itshape}%         Body font
     {}%         Indent amount (empty = no indent, \parindent = para indent)
     {\bfseries}% Thm head font
     {}%        Punctuation after thm head
     {9pt}%     Space after thm head: " " = normal interword space;
           %       \newline = linebreak
     {}%         Thm head spec (can be left empty, meaning `normal')


\theoremstyle{myex}
\newtheorem{ex}{Exercise}[chapter]

\begin{ex}
Hãy viết một biểu thức Octave để lượng giá biểu thức toán sau đây.
Bạn có thể coi rằng các biến {\tt mu}, {\tt sigma} và {\tt x} đều đã tồn tại.

\begin{equation}
\frac{e^{- \left( \frac{x-\mu}{\sigma \sqrt{}2} \right) ^2}}
{\sigma \sqrt{2 \pi}}
\end{equation}

Lưu ý: bạn không thể dùng những chữ cái Hi Lạp trong Octave; khi
chuyển từ biểu thức toán có chứa chữ cái Hi Lạp, ta thường viết hẳn 
tên nó (coi như bạn đã biết tên các chữ cái này).
\end{ex}
 

% chap02
\chapter{Mã lệnh chương trình}

\section{Tập tin M}

Đến giờ ta đã gõ tất cả chương trình ``vào dấu nhắc lệnh''. Điều này
cũng ổn nếu như bạn chỉ phải viết một vài dòng lệnh. Vượt quá
mức đó, bạn sẽ cần lưu chương trình vào một {\bf tập tin lệnh} rồi
thực hiện tập tin lệnh này.

Một tập tin lệnh là một file (tập tin) chứa mã lệnh Octave. Các tập tin
này cũng được gọi là ``M-files'' (tập tin M) vì chúng có phần mở rộng
{\tt .m}, vốn là chữ viết tắt cho Octave.

%% Phần này chuyển sang dùng SciTE
Bạn có thể tạo và sửa các tập tin lệnh với bất kì phần mềm biên tập
file chữ (text editor) hay trình soạn thảo văn bản nào.
%, nhưng cách làm
%dễ nhất là chọn {\sf New}$\rightarrow${\sf Script} từ trình đơn (menu) 
%{\sf File}. Một cửa sổ sẽ xuất hiện trong đó chạy một trình biên tập
%file chữ dành riêng cho Octave.
Ở đây, tôi dùng trình biên tập có tên SciTE (\url{http://www.scintilla.org/SciTE.html}).
Nếu dùng Windows, bạn có thể vào mục Downloads, chọn Windows Installer.
Nếu dùng UNIX, Linux, hay Mac, nhiều khả năng là bạn có thể tìm được
gói cài trong kho phần mềm (repository) của hệ thống.
%% ---

Sau khi cài và khởi động SciTE, hãy gõ dòng lệnh sau vào trong trình biên tập 

\begin{verbatim}
x = 5
\end{verbatim}
%
và nhấn tổ hợp phím \textsf{Ctrl+S}, hoặc chọn 
{\sf Save} từ trình đơn {\sf File}. Dù bằng cách nào đi nữa, một hộp thoại 
sẽ xuất hiện tại đó bạn có thể chọn tên tập tin (nhớ kết thúc bằng \texttt{.m})
và thư mục cần lưu vào. Hãy đổi tên thành {\tt myscript.m} và giữ nguyên thư mục.

Ở đây cần một chút lưu ý. Vì SciTE với Octave là hai phần mềm riêng, nên
ta cần đảm bảo cho chúng hoạt động trong cùng một thư mục. Sau lần này,
khi thoát khỏi Octave, bạn cần đặt lại đường dẫn lúc khởi động bằng cách
chỉ định nó trong mục {\sf Start in} ở hộp thoại Properties có được khi kích 
chuột phải vào biểu tượng Octave.
%
Còn bây giờ, bạn có thể di chuyển đến thư mục chứa tập tin mã lệnh bằng
cách dùng lệnh \texttt{cd}, chẳng hạn:
\begin{verbatim}
>> cd C:\Users\tencuaban\matlab
\end{verbatim}
%
Một số lệnh khác bạn có thể cần dùng bao gồm \texttt{pwd} để xem đường dẫn
đến thư mục hiện thời, \texttt{ls} để liệt kê các tập tin và thư mục
con của thư mục hiện thời. Đôi khi có thể dùng phím Tab để nhắc hệ thống 
điền nốt tên của tập tin hay thư mục mà bạn đang gõ dở.
%Ở đây cần lưu ý một chút về cách chọn thư mục. Vì SciTE chạy ngoài
%môi trường Cygwin / Octave nên đường dẫn ngầm định của Octave lại ở
%một nơi ``xa xăm''. Tuy vậy, ngay trong Octave ta vẫn có thể chuyển về
%thư mục quen thuộc trong Windows (ở đây tôi sẽ chuyển về thư mục
%Downloads của bạn trong Windows 7) bằng cách:
%\begin{verbatim}
%>> cd /cygdrive/c/Users/tencuaban/Downloads
%\end{verbatim}
%
%Với \texttt{cd} là lệnh chuyển thư mục. Bạn có thể tự thám hiểm hệ thống
%thư mục của Cygwin bằng các lệnh: \texttt{pwd} để xem đường dẫn
%đến thư mục hiện thời, \texttt{ls} để liệt kê các tập tin và thư mục
%con của thư mục hiện thời. Đôi khi có thể dùng phím Tab để nhắc hệ thống 
%điền nốt tên của tập tin hay thư mục mà bạn đang gõ dở.

Octave, theo mặc định, sẽ lưu tập tin lệnh của bạn vào trong thư
mục đặt ở {\bf đường dẫn được tìm kiếm} (search path), vốn là một
loạt các thư mục mà Octave tìm các tập tin lệnh ở đó.

Hãy quay trở lại dấu nhắc lệnh và gõ vào {\tt myscript} (không có
phần mở rộng). Octave sẽ thực hiện tập tin lệnh
và hiển thị kết quả.

\begin{verbatim}
>> myscript
x = 5
\end{verbatim}
%
Khi bạn chạy một tập tin lệnh, Octave thực hiện các lệnh trong tập
tin M, lần lượt từng lệnh một, hệt như khi bạn gõ chúng từ dấu nhắc.

Nếu có vấn đề trục trặc là Octave không thể tìm thấy tập tin lệnh
thì bạn sẽ nhận được một thông báo lỗi kiểu như:

\begin{verbatim}
>> myscript
error: `myscript' undefined near line 88 column 1
\end{verbatim}
%
Trong trường hợp này bạn có thể lưu lại tập tin lệnh vào một thư mục
có trong đường dẫn tìm kiếm, hoặc sửa lại đường dẫn tìm kiếm để nó
bao gồm cả thư mục đang chứa tập tin lệnh này. Về chi tiết, bạn sẽ phải
tra cứu tài liệu. (Rất xin lỗi!)

Tên tập tin có thể là bất cứ gì bạn thích, nhưng nên chọn những tên có
nghĩa và dễ nhớ. Bạn phải rất cẩn thận chọn được một tên mà hiện 
không sử dụng; vì nếu tên đó mà đang được dùng thì bạn có thể sẽ
vô tình thay thế nó vào các hàm có sẵn trong Octave. Sau cùng, tên
tập tin không được phép có dấu cách. Nếu bạn tạo ra file có tên
{\tt my script.m}, Octave không phàn nàn gì cho đến khi bạn chạy nó:

\begin{verbatim}
>> my script
error: `my' undefined near line 88 column 1
\end{verbatim}
%
Vấn đề là ở chỗ nó đang cố tìm một tập tin lệnh có tên {\tt my}.  Sự việc
còn tồi tệ hơn nữa nếu như từ đầu tiên của tên tập tin lại là một hàm
sẵn có. Để cho vui, bạn hãy thử tạo một tập tin lệnh có tên {\tt abs val.m}
và chạy nó.

Việc theo dõi tất cả những tập tin lệnh của bạn có thể sẽ vất vả. Để cho
mọi thứ trở nên đơn giản, tạm thời bây giờ bạn nên đặt tất cả tập tin 
lệnh vào trong thư mục mặc định.

\begin{ex}
Dãy Fibonacci, kí hiệu $F$, được mô tả bởi các phương trình 
$F_1 = 1$, $F_2 = 1$, và với $i \ge 3$, $F_{i} = F_{i-1} + F_{i-2}$.
Các số trong dãy này thường xuất hiện trong tự nhiên ở nhiều loại cây,
đặc biệt là ở những cánh hoa hay vẩy được sắp xếp theo hình thù
xoáy ốc.

Biểu thức sau được dùng để tính số Fibonacci thứ $n$:

\begin{equation}
F_n = \frac{1}{\sqrt{5}}
\left[ 
\left( \frac{1 + \sqrt{5}}{2} \right)^{n} -
\left( \frac{1 - \sqrt{5}}{2} \right)^{n}
\right]
\end{equation}
%
Hãy chuyển biếu thức này sang Octave và lưu mã lệnh vào
một tập tin có tên là {\tt fibonacci1}.  Tại dấu nhắc lệnh, hãy
đặt {\tt n} bằng 10 và chạy đoạn mã. Dòng cuối cùng của đoạn mã
cần phải gán giá trị của $F_n$ cho {\tt ans}.
(Giá trị đúng của $F_{10}$ là 55).
\end{ex}


\section{Tại sao cần dùng tập tin lệnh?}

Những lý do thông thường nhất cho việc dùng mã lệnh là:

\begin{itemize}

\item Khi bạn đang viết nhiều câu lệnh (nhiều hơn một vài dòng), có thể
bạn cần thử vài lần trước khi mã lệnh chạy đúng. Việc đặt mã vào trong
một tập tin lệnh sẽ giúp bạn dễ chỉnh sửa hơn là gõ lệnh từ dấu nhắc.

\item Nếu bạn chọn tên hợp lý cho tập tin lệnh, bạn sẽ nhớ được là
tập tin nào làm nhiệm vụ gì, và bạn có thể sẽ sử dụng lại được một
tập tin lệnh của dự án này cho dự án sau.

\item Nếu bạn chạy tập tin lệnh nhiều lần, việc gõ tên tập tin lệnh sẽ 
nhanh hơn là gõ lại toàn bộ mã lệnh!

\end{itemize}

Không may là sức mạnh của các tập tin lệnh cũng đi kèm với trách nhiệm
của người dùng; bạn phải chắc rằng mình chạy đúng tập tin lệnh mà
mình cần.

Thứ nhất, mỗi khi chỉnh sửa tập tin lệnh, bạn phải lưu nó lại trước khi 
chạy. Nếu quên không lưu, bạn sẽ chạy phiên bản cũ của tập tin.

Thứ hai, mỗi khi bạn tạo một tập tin lệnh mới, hãy bắt đầu viết 
đơn giản, kiểu như {\tt x=5}, để có được kết quả hiện ra rõ ràng. Sau đó
chạy tập tin lệnh để chắc rằng bạn nhận được kết quả như mong đợi.
Octave có rất nhiều hàm định nghĩa sẵn. Rất dễ viết một tập tin lệnh
có tên giống như tên hàm của Octave, và nếu không cẩn thận, bạn
có thể thấy rằng mình đã chạy hàm của Octave thay vì tập tin lệnh
vừa viết.

Dù trong trường hợp nòa, nếu mã lệnh mà bạn chạy không phải là mã
lệnh bạn vừa sửa đổi thì bạn sẽ thấy việc gỡ rỗi thật phát bực! Và 
điều này dẫn ta đến Định lý thứ ba về gỡ lỗi:

\begin{quote}
Bạn phải chắc chắn 100\% rằng mã lệnh bạn đang chạy đúng là
mã lệnh bạn muốn chạy.
\end{quote}



\section{Không gian làm việc}

Các biến bạn vừa tạo ra được lưu vào trong một {\bf không gian làm việc},
hay ``workspace'', vốn là một tập hợp các biến cùng giá trị của chúng.
Lệnh {\tt who} in ra các tên biến có trong không gian này.

\begin{verbatim}
>> x=5;
>> y=7;
>> z=9;
>> who
Variables in the current scope:
x  y  z  
\end{verbatim}
%
Lệnh {\tt clear} xóa bỏ hết các biến.

\begin{verbatim}
>> clear y
>> who
Variables in the current scope:
x  z  
\end{verbatim}
%
Để hiển thị giá trị một biến, bạn có thể dùng hàm {\tt disp}.

\begin{verbatim}
>> disp(z)
     9
\end{verbatim}
%
Nhưng sẽ dễ hơn nếu ta chỉ gõ tên biến.

\begin{verbatim}
>> z
z = 9
\end{verbatim}
%
(Chặt chẽ mà nói thì tên biến cũng chính là một biểu thức, vì vậy
việc lượng giá nó sẽ gán giá trị cho {\tt ans}, nhưng dường như 
Octave hiểu điều này như một trường hợp đặc biệt.)


\section{Các lỗi khác}

Một lần nữa, khi thử điều gì mới, bạn nên cố ý tạo ra một số lỗi để
sau này còn nhận ra chúng.

Lỗi thông thường nhất với các tập tin lệnh là chạy một tập tin mà
không tạo trước các biến cần thiết. Chẳng hạn, {\tt fibonacci1} yêu cầu
bạn gán một giá trị cho {\tt n}. Nếu như bạn không gán:

\begin{verbatim}
>> fibonacci1
error: `n' undefined near line 1 column 37
error: called from:
error:   C:\Users\tencuaban\matlab\fibonacci1.m 
	at line 1, column 3
\end{verbatim}
%
Chi tiết của thông báo lệnh này có thể sẽ khác trong trường hợp của
bạn, tùy theo nội dung mã lệnh bạn gõ vào tập tin. Nhưng ý tưởng chung
là {\tt n} chưa được định nghĩa. Lưu ý rằng Octave báo với bạn dòng
lệnh trong chương trình có lỗi xảy ra, và hiển thị dòng đó.

Thông tin này có thể hữu ích, nhưng hãy cẩn thận! Octave báo với
bạn chỗ phát hiện ra trục trặc, chứ không phải là vị trí của lỗi. Ở
trường hợp này, lỗi không hề nằm ở tập tin lệnh; mà đúng ra là ở
không gian làm việc.

Từ đó dẫn đến Định lý thứ tư về gỡ lỗi:

\begin{quote}
Các thông báo lỗi báo cho ta biết trục trặc được phát hiện ở đâu, chứ
không phải là nơi khởi nguồn của nó.
\end{quote}

Mục đích của ta là tìm ra nguyên nhân và sửa nó---chứ không phải 
chỉ là làm cho thông báo lỗi biến đi.


\section{Các điều kiện trước và sau}

Mỗi tập tin lệnh đều nên chứa một lời chú thích nhằm trình bày 
tác dụng của nó, và những yêu cầu của nó đối với không gian 
làm việc. Chẳng hạn, tôi có thể gõ những dòng sau vào đầu
tập tin {\tt fibonacci1}:

\begin{verbatim}
% Computes the nth Fibonacci number.  
% Precondition: you must assign a value to n before running 
% this script.  Postcondition: the result is stored in ans.
\end{verbatim}
%
Một {\bf điều kiện trước} (``precondition'') là điều buộc phải đúng
lúc chương trình bắt đầu được thực hiện, để chương trình có thể chạy đúng.
Một {\bf điều kiện sau} (``postcondition'') là điều sẽ đúng sau khi
chương trình kết thúc.

Nếu có một lời chú thích như vậy ở đầu tập tin lệnh, Octave sẽ 
coi đó là đoạn thông tin của tập tin lệnh, vì vậy nếu bạn gõ vào 
{\tt help fibonacci1}, bạn sẽ nhận được nội dung đoạn thông tin này
(trừ những dấu phần trăm).

\begin{verbatim}
>> help fibonacci1
  Computes the nth Fibonacci number.  
  Precondition: you must assign a value to n before running 
  this script.  Postcondition: the result is stored in ans.
\end{verbatim}
%
(Một số thông tin theo sau đã được tôi lược đi cho gọn.) Như vậy,
bằng cách này, các tập tin lệnh mà bạn viết ra sẽ thể hiện giống như
các hàm đã định nghĩa sẵn. % Thậm chí, bạn có thể dùng cả lệnh
% {\tt doc} để xem đoạn thông tin từ Help Window. --> ko được.


\section{Phép gán và đẳng thức}

Trong toán học, dấu bằng dùng để chỉ hai vế của phương trình có
cùng giá trị. Trong Octave một phép gán {\em trông} giống như một
đẳng thức toán học, nhưng thực ra thì không phải.

Một điểm khác biệt là hai vế của một phép gán thì không thể đổi chỗ
cho nhau được. Vế phải có thể được thay bởi một biểu thức hợp lệ
bất kì, nhưng vế trái thì nhất thiết là một biến, được gọi là 
{\bf đích} của phép gán. Vì vậy các lệnh gán sau đều hợp lệ:

\begin{verbatim}
>> y = 1;
>> x = y+1
x = 2
\end{verbatim}
%
Nhưng lệnh gán sau thì không:

\begin{verbatim}
>> y+1 = x
error: invalid lvalue function called in expression
\end{verbatim}
%
Một điểm khác biệt nữa là ở chỗ phép gán chỉ là tạm thời, theo nghĩa
sau đây. Khi bạn gán {\tt x = y+1}, bạn nhận được giá trị 
{\em hiện thời} của {\tt y}.  Nếu sau này {\tt y} thay đổi, {\tt x}
sẽ không thay đổi theo.

Điểm khác biệt thứ ba là một đẳng thức toán là một phát biểu có thể
đúng hoặc không đúng. Chẳng hạn, $y = y+1$ là một phát biểu
sai với mọi giá trị của $y$.  Trong Octave, {\tt y = y+1} là câu lệnh gán
hợp lệ và có ích. Nó đọc vào giá trị hiện thời của {\tt y}, tăng thêm một, 
và thay thế giá trị cũ với giá trị mới này.

\begin{verbatim}
>> y = 1;
>> y = y+1
y = 2
\end{verbatim}
%
Với mã lệnh Octave, có thể bạn sẽ thấy lợi hơn khi 
đọc dấu bằng là ``nhận giá trị'' thay vì ``bằng.''  Do vậy {\tt x = y+1}
được đọc là ``{\tt x} nhận giá trị của {\tt y} cộng với 1.''

Để kiểm tra mức độ hiểu các lệnh gán của bạn, hãy thử làm
bài tập sau:

\begin{ex}
Hãy viết một số dòng lệnh nhằm tráo đổi giá trị của hai biến
{\tt x} và {\tt y}. Đặt mã lệnh bạn viết vào trong tập tin có tên 
là {\tt swap} và chạy thử nó.
\end{ex}


\section{Phát triển tăng dần}

Khi bắt đầu viết mã lệnh dài hơn một vài dòng, lúc đó bạn
có thể thấy mình dành càng nhiều thời gian để gỡ lỗi. Nếu như
bạn viết càng nhiều mã lệnh trước khi bắt tay vào việc gỡ lỗi
thì sẽ càng khó tìm ra trục trặc tiềm ẩn trong chương trình.

{\bf Phát triển tăng dần} là một cách lập trình nhằm giảm thiểu
công sức dành cho gỡ lỗi. Các bước cơ bản của nó gồm có:

\begin{enumerate}

\item Luôn bắt đầu với một chương trình chạy được. Nếu bạn 
có một ví dụ trong sách hoặc một chương trình mà bạn đã viết
tương đồng với chương trình đang làm, thì hãy lấy nó để bắt
đầu. Còn nếu không, hãy bắt đầu với điều mà bạn {\em biết}
rằng luôn đúng, như {\tt x=5}.  Chạy chương trình và khẳng định
chắc rằng bạn đang chạy chương trình mà bạn muốn chạy.

Bước này rất quan trọng, vì ở đa số các môi trường [xây dựng 
chương trình], có rất nhiều điều nhỏ nhặt làm bạn rối lên mỗi
khi bắt đầu một dự án mới. Hãy dẹp chúng qua một bên để
có thể tập trung vào lập trình.

\item Mỗi lúc chỉ sửa một chỗ, và có thể kiểm tra được chỗ sửa này.
``Kiểm tra được'' có nghĩa ảnh hưởng của việc sửa đổi có thể 
hiện trên màn hình và bạn kiểm tra được. Tốt nhất là bạn cần
biết được rằng kết quả đúng là gì, hoặc có khả năng kiểm tra nó
bằng một phép tính toán khác.

\item Chạy chương trình xem sự thay đổi có hiệu quả không. Nếu
có, hãy quay trở lại Bước 2. Nếu không, bạn cần phải gỡ lỗi, nhưng
nếu sự thay đổi nói trên rất nhỏ thì thường bạn sẽ nhanh chóng
tìm ra lỗi.

\end{enumerate}

Khi quá trình trên hoạt động tốt, bạn sẽ thấy rằng thường những
thay đổi có tác dụng ngay lần đầu, hoặc sai lầm (nếu có) sẽ dễ 
thấy. Đó là một điều tốt, và dẫn đến Định lý thứ năm về gỡ lỗi:

\begin{quote}
Cách gỡ lỗi tốt nhất là cách mà ở đó bạn không phải làm.
\end{quote}

Trên thực tế, có hai vấn đề gắn với phát triển tăng dần:

\begin{itemize}

\item Đôi khi bạn phải viết thêm mã lệnh để có thể tạo ra kết quả
dưới dạng nhìn thấy được, giúp cho việc kiểm tra. Mã lệnh thêm vào
này được gọi là {\bf dàn giáo} vì bạn dùng nó để xây dựng chương trình
nhưng sau này sẽ bỏ nó đi khi chương trình hoàn tất. Nhưng thời gian
tiết kiệm được từ việc gỡ lỗi thường luôn xứng đáng với thời gian
bỏ ra để dựng dàn giáo.

\item Khi bạn mới bắt đầu, thông thường sẽ không rõ bằng cách nào
bạn có thể chọn các bước kế tiếp từ {\tt x=5} đến chương trình mà
bạn muốn viết. Có một ví dụ về cách làm này ở Mục~\ref{increxample}.

\end{itemize}

Nếu bạn tự thấy mình viết nhiều dòng lệnh trước khi bắt tay vào 
kiểm tra, và phải dành nhiều thời gian để gỡ lỗi thì bạn nên thử
cách phát triển tăng dần.


\section{Kiểm tra thành phần}

Trong những dự án phần mềm lớn, {\bf kiểm tra thành phần} là 
quá trình kiểm tra những bộ phận riêng biệt cấu thành phần mềm,
trước khi sắp xếp chúng lại.

Những chương trình ta viết đến giờ đều chưa đủ lớn đến mức phải
kiểm tra thành phần, nhưng chính nguyên tắc này cũng có ích khi
lần đầu bạn thao tác với một hàm mới hoặc một đặc điểm mới của 
ngôn ngữ. Bạn cần kiểm tra nó riêng biệt trước khi đưa vào 
chương trình.

Chẳng hạn, giả sử rằng bạn biết là {\tt x} là sin của một góc nào đó
và bạn muốn tính góc này. Bạn tìm thấy hàm Octave có tên {\tt asin},
và tương đối chắc rằng nó được dùng để tính nghịch đảo của sin.
``Tương đối chắc chắn'' vẫn là chưa đủ; bạn phải tuyệt đối chắc
chắn.

Vì đã biết $\sin 0 = 0$, ta có thể thử

\begin{verbatim}
>> asin(0)
ans = 0
\end{verbatim}
%
\noindent vốn là kết quả đúng. Hơn nữa, ta đã biết sin của góc 90 độ 
bằng 1, vì vậy nếu ta thử {\tt asin(1)}, ta muốn kết quả bằng 90, 
phải không?

\begin{verbatim}
>> asin(1)
ans =  1.57079632679490
\end{verbatim}
%
Ối! Chúng ta quên mất rằng các hàm lượng giác trong Octave đều 
tính theo ra-đian, chứ không phải độ. Vì vậy đáp số đúng là $\pi/2$, 
và ta có thể khẳng định bằng cách chia kết quả cho {\tt pi}:

\begin{verbatim}
>> asin(1) / pi
ans =  0.500000000000000
\end{verbatim}
%
Với cách kiểm tra thành phần như thế này, bạn không thực sự kiểm tra
lỗi trong Octave, mà kiểm tra cách hiểu của bạn. Nếu bạn mắc lỗi
chỉ vì đã hiểu sai cách hoạt động của Octave thì sẽ mất rất nhiều
thời gian để tìm ra lỗi đó; vì khi nhìn vào mã lệnh bạn tưởng như
nó đúng.

Từ đó dẫn đến Định lý thứ sáu về gỡ lỗi:

\begin{quote}
Những lỗi tệ nhất không nằm ở mã lệnh mà ở trong đầu bạn.
\end{quote}



\section{Thuật ngữ}

\begin{description}

\item[tập tin M:] Tập tin có chứa một chương trình Octave.

\item[tập tin lệnh:] Tập tin M có chứa một loạt các lệnh Octave.

\item[đường dẫn tìm kiếm:] Một loạt các thư mục tại đó Octave tìm các
tập tin M.

\item[không gian làm việc:] Tập hợp các biến cùng giá trị của chúng.

\item[điều kiện trước:] Điều mà buộc phải đúng khi chương trình bắt đầu
chạy, để đảm bảo cho chương trình hoạt động đúng đắn.

\item[điều kiện sau:] Điều sẽ đúng khi chương trình hoàn tất.

\item[đích:] Biến ở vế trái của lệnh gán.

\item[phát triển tăng dần:] Cách lập trình thông qua việc tạo ra một
loạt những thay đổi nhỏ có thể kiểm tra được.

\item[dàn giáo:] Mã lệnh được viết để phục vụ cho việc lập trình hoặc
gỡ lỗi, nhưng không phải là một phần của sản phẩm chương trình.

\item[kiểm tra thành phần:] Quá trình kiểm tra phần mềm bằng việc
kiểm tra mỗi thành phần một cách riêng biệt.

\end{description}


\section{Bài tập}

\begin{ex}
\label{cargame}

Hãy tưởng tượng rằng bạn là chủ sở hữu một công ty cho thuê xe hơi
với hai địa điểm, Albany and Boston. Một số khách hàng của bạn thuê
``một chiều'', nghĩa là thuê xe lái từ Albany đến Boston, hoặc 
ngược lại. Sau một thời gian quan sát, bạn nhận thấy rằng mỗi tuần
có 5\% số xe đi từ Albany được trả ở Boston, và 3\% số xe đi từ
Boston được trả ở Albany. Vào đầu mỗi năm, có 150 xe ở mỗi trạm.

Hãy viết một tập tin lệnh có tên \verb#car_update# để cập nhật số xe
ở mỗi trạm theo từng tuần. Điều kiện trước là các biến {\tt a} 
và {\tt b} chứa số xe ở mỗi địa điểm vào đầu hàng tuần. Điều kiện 
sau là {\tt a} và {\tt b} sau khi thay đổi, phản ánh số xe đã 
di chuyển.

Để kiểm tra chương trình, hãy đặt các giá trị đầu cho {\tt a} 
và {\tt b} tại dấu nhắc lệnh và chạy tập tin lệnh. Chương trình cần
hiển thị các giá trị được cập nhật của {\tt a} và {\tt b}, 
nhưng không phải các biến trung gian khác.

Lưu ý rằng các xe là lượng đếm được, vì vậy {\tt a} và 
{\tt b} phải luôn là những giá trị nguyên. Bạn có thể sẽ cần dùng 
hàm {\tt round} để tính số xe di chuyển hằng tuần.

Nếu thực hiện tập tin lệnh lặp đi lặp lại, bạn có thể mô phỏng sự
di chuyển của xe từ tuần này qua tuần khác. Bạn nghĩ điều gì sẽ
xảy ra với số xe? Liệu rằng tất cả các xe sẽ tụ về một trạm không?
Liệu số xe sẽ đạt tới trạng thái cân bằng, hay dao động từ tuần này
qua tuần khác?

Ở chương tiếp theo ta sẽ đề cập đến cách tự động thực hiện tập tin lệnh, 
này và cách vẽ đồ thị các giá trị của {\tt a} và {\tt b} 
theo thời gian.
\end{ex}



% chap03
\chapter{Vòng lặp}

\section{Cập nhật các biến}

Ở Bài tập~\ref{cargame}, bạn có thể đã định viết

\begin{verbatim}
a = a - 0.05*a + 0.03*b
b = b + 0.05*a - 0.03*b
\end{verbatim}
%
Nhưng điều đó sai, rất sai. Tại sao? Vấn đề là ở chỗ dòng lệnh 
thứ nhất thay đổi giá trị của {\tt a}, nên khi dòng lệnh thứ hai 
được thực hiện, nó sẽ lấy giá trị cũ của {\tt b} và giá trị mới của
{\tt a}. Kết quả là, sự thay đổi ở {\tt a} không cùng lúc với thay
đổi ở {\tt b}; tức là đã vi phạm định luật bảo toàn số lượng xe!

Một cách làm là dùng các biến tạm thời, {\tt anew} và {\tt bnew}:

\begin{verbatim}
anew = a - 0.05*a + 0.03*b
bnew = b + 0.05*a - 0.03*b
a = anew
b = bnew
\end{verbatim}
%
Cách này có tác dụng cập nhật các biến ``đồng thời''; nghĩa là
nó đọc cả hai biến cũ trước khi ghi ra hai giá trị mới.

Dưới đây là một cách làm khác có lợi là làm việc tính toán được
đơn giản:

\begin{verbatim}
atob = 0.05*a - 0.03*b
a = a - atob
b = b + atob
\end{verbatim}
%
Xem xét đoạn mã này ta có thể thấy được nó tuân theo định luật
bảo toàn số xe. Ngay cả khi giá trị của {\tt atob} là sai thì ít nhất 
tổng số xe vẫn còn đúng. Và từ đó dẫn đến Định luật thứ bẩy về
gỡ lỗi:

\begin{quote}
Cách tốt nhất để tránh một lỗi là khiến nó không thể xảy ra.
\end{quote}

Trong trường hợp này, việc bỏ những chi tiết thừa cũng loại trừ 
khả năng gây lỗi.


\section{Các loại lỗi}

Có bốn loại lỗi sau:

\begin{description}

\item[Lỗi cú pháp:] Bạn đã viết một câu lệnh Octave mà không thể
thực thi được vì nó vi phạm các quy tắc về cú pháp. Chẳng hạn, bạn
không thể có hai toán hạng đi liền nhau mà không có toán tử, vì vậy
\verb+pi r^2+ là một lỗi cú pháp. Khi Octave phát hiện ra lỗi cú pháp,
nó sẽ hiển thị một thông báo lỗi và dừng chương trình.

\item[Lỗi thực thi:] Chương trình của bạn đã bắt đầu chạy, nhưng rồi
có điều gì trục trặc diễn ra. Chẳng hạn, nếu bạn cố gắng truy cập
một biến chưa tồn tại thì đó là một lỗi thực thi. Khi Octave phát hiện
được vấn đề, nó sẽ in ra thông báo lỗi và dừng lại.

\item[Lỗi logic:] Chương trình chạy mà không phát sinh bất cứ thông báo
lỗi nào, nhưng nó không thực hiện điều mong muốn. Vấn đề ta gặp ở
mục trước, khi thay đổi giá trị của {\tt a} trước lúc đọc giá trị cũ, là
một lỗi logic.

\item[Lỗi số trị:] Hầu hết những phép tính được thực hiện bởi Octave 
đều chỉ gần đúng. Trong đa số trường hợp, sai số là nhỏ và ta không
quan tâm đến, nhưng đôi khi các sai số do làm tròn lại là một vấn đề.

\end{description}

Các lỗi cú pháp luôn dễ xử lý nhất. Đôi khi dòng thông báo lỗi có thể
gây nhầm lẫn, nhưng thường Octave sẽ báo cho bạn biết lỗi ở đâu,
ít ra là một vị trí gần đúng.

Các lỗi thực thi nói chung là khó hơn vì như tôi đã đề cập ở trên, 
Octave nói được vị trí của nó nhưng không nói nguyên nhân gây ra nó.

Các lỗi logic đều khó vì Octave chẳng giúp gì được. Chỉ có bạn mới
biết được chương trình cần phải làm gì, vì vậy chỉ có bạn mới sửa được
lỗi. Theo quan điểm của Octave, nếu chương trình không có gì sai
thì lỗi nằm trong đầu bạn!

Các lỗi số trị có thể sẽ rất mẹo mực vì thật không rõ là cái sai có
thuộc về bạn hay không. Với những tính toán đơn giản nhất, 
Octave cho ta các giá trị số có dấu phẩy động gần sát với giá
trị đúng, có nghĩa là 15 chữ số ban đầu là đúng. Nhưng trong một số
bài toán với đặc thù ``tình trạng xấu'', có nghĩa là ngay cả khi 
chương trình của bạn đã đúng, các sai số do làm tròn vẫn tích tụ lại
và số chữ số đúng sẽ ít đi. Đôi khi Octave có thể cảnh báo cho bạn
biết điều này đang xảy ra, nhưng không phải luôn luôn như vậy! 
Độ chuẩn xác (số chữ số trong kết quả) không bao hàm độ
chính xác (số chữ số đúng).


\section{Sai số tuyệt đối và tương đối}

Có hai cách nghĩ về các sai số về số trị, đó là {\bf tuyệt đối}
và {\bf tương đối}.

Sai số tuyệt đối chính là độ chênh lệch giữa giá trị đúng và giá trị 
xấp xỉ. Ta thường biểu thị độ lớn của sai số này, mà bỏ qua dấu
của nó, vì dù giá trị xấp xỉ có cao hay thấp thì cũng chẳng ảnh
hưởng gì.

Chẳng hạn, ta muốn tính $9!$ bằng công thức $\sqrt
{18 \pi} ( 9 / e)^9$.  Đáp số đúng là $9 \times 8 \times 7 \times 6
\times 5 \times 4 \times 3 \times 2 \times 1 = 362880$.  Giá trị xấp xỉ
tính được là 359536,87. Sai số tuyệt đối là 3343,13.

Thoạt nhìn, ta tưởng chừng như đây là sai số lớn---ta đã 
tính sai đến hơn 3000---nhưng cũng cần phải xét đến độ lớn
của đại lượng mà ta cần tính. Chẳng hạn, \$3000 là con số lớn
khi nói về tiền lương năm của tôi, nhưng chẳng là gì cả nếu
ta nói về khoản nợ của quốc gia.

Một cách tự nhiên để xử lý ván đề này là dùng sai số tương đối,
vốn là tỉ lệ (hay số phần trăm) của sai số tuyệt đối so với 
giá trị đúng. Trong trường hợp này, ta cần chia sai số cho
362880, thu được 0,00921; tức là gần 1\%. Với phần lớn
các mục đích tính toán khác nhau, thì sai lệch 1\% là đạt yêu cầu.


\section{Vòng lặp for}

{\bf Vòng lặp} là một phần chương trình được thực hiện lặp đi
lặp lại. {\bf Vòng lặp for} là dạng vòng lặp có dùng câu lệnh {\tt for}.

Cách dùng vòng lặp {\tt for} đơn giản nhất là thực hiện lặp lại
một hay nhiều câu lệnh với số lần định trước. Chẳng hạn, ở chương
trước ta đã viết một đoạn mã có tên \verb#car_update# để 
mô phỏng diễn biến chạy trong một tuần của những xe thuộc
một công ty. Để mô phỏng diễn biến trong một năm, ta cần phải
chạy nó 52 lần:

\begin{verbatim}
for i=1:52
    car_update
end
\end{verbatim}
%
Dòng thứ nhất giống như một lệnh gán, và nó {\em đúng là} một
kiểu lệnh gán, nhưng được thực hiện nhiều lần. Lần đầu tiên được
chạy, nó tạo ra biến {\tt i} và gán cho nó giá trị bằng 1. Lần thứ hai,
{\tt i} nhận giá trị 2, và cứ như vậy cho đến 52.

Toán tử hai chấm, {\tt :}, biểu diễn một {\bf khoảng} số nguyên. Theo
tinh thần của cách kiểm tra từng phần, bạn có thể tạo ra một dãy
từ dấu nhắc lệnh:

\begin{verbatim} 
>> 1:5
ans =  1     2     3     4     5
\end{verbatim}
%
Biến được dùng trong lệnh for này được gọi là {\bf biến vòng lặp}.
Theo thông lệ, ta thường lấy các tên {\tt i}, {\tt j} và {\tt k} để đặt cho
các biến lặp.

Những câu lệnh bên trong vòng lặp được gọi là {\bf phần thân}.  
Theo thông lệ, chúng được viết thụt đầu dòng để cho thấy rằng
chúng nằm trong vòng lặp, tuy nhiên hình thức viết này không ảnh
hưởng đến việc thực hiện chương trình. Điểm kết thúc của vòng
lặp được chính thức đánh dấu bởi lệnh {\tt end}.

Để xem vòng lặp hoạt động thế nào, bạn có thể chạy vòng lặp
trong đó chỉ in ra biến lặp:

\begin{verbatim}
>> for i=1:5
    i
end

i = 1
i = 2
i = 3
i = 4
i = 5
\end{verbatim}
%
Như ví dụ trên cho thấy, bạn {\em có thể} chạy một vòng lặp
từ dấu nhắc lệnh, nhưng ta thường đặt nó vào một tập tin lệnh hơn.

\begin{ex}
Hãy tạo ra một tập tin lệnh có tên \verb#car_loop# trong đó dùng
một vòng lặp {\tt for} để chạy \verb#car_update# 52 lần. Hãy nhớ
rằng trước khi chạy \verb#car_update#, bạn phải gán các giá trị
cho {\tt a} và {\tt b}. Với bài tập này, hãy bắt đầu bằng các giá trị  
{\tt a = 150} và {\tt b = 150}.

Nếu mọi việc trôi chảy, chương trình của bạn sẽ hiển thị một 
đoạn dài các con số trên màn hình. Nhưng thường có quá nhiều
số để màn hình hiện ra hết; và ngay cả có hiện hết đi nữa cũng
rất khó diễn giải được. Có một đồ thị sẽ tốt hơn!
\end{ex}


\section{Đồ thị}
\label{plotting}

{\tt plot} là một hàm vẽ đồ thị rất đa năng, giúp ta vẽ các điểm,
các đường trên hệ tọa độ hai chiều. Thật không may, vì quá đa năng
nên nó có thể trở nên khó dùng. (và khó tra cứu thông tin về hàm này!)
Ta sẽ bắt đầu một cách đơn giản và dần làm khó hơn.

Để chấm một điểm, ta gõ vào

\begin{verbatim}
>> plot(1, 2)
\end{verbatim}

Một {\sf Figure Window} (cửa sổ hình vẽ) sẽ xuất hiện với một đồ thị
trên đó có chấm một điểm màu xanh lam tại tọa độ $x$ bằng 1 và 
$y$ bằng 2. Để khiến cho điểm này dễ nhìn hơn, bạn có thể chọn một
hình khác:

\begin{verbatim}
>> plot(1, 2, 'o')
\end{verbatim}
%
Chữ cái ở trong cặp dấu nháy đơn là một chuỗi chỉ định hình thức
của điểm cần chấm. Bạn cũng có thể chỉ định màu sắc:

\begin{verbatim}
>> plot(1, 2, 'ro')
\end{verbatim}
%
{\tt r} viết tắt cho red (đỏ); các màu khác gồm có {\bf g}reen (lục),
{\bf b}lue (lam), {\bf c}yan (da trời), {\bf m}agenta (tím hồng), 
{\bf y}ellow (vàng) và blac{\bf k} (đen).
Các hình khác gồm có {\tt +}, 
{\tt *}, 
{\tt x}, 
{\tt s} (square / hình vuông), 
{\tt d} (diamond / hình thoi), và 
\verb+^+ (hình tam giác). 

Khi bạn dùng hàm {\tt plot} theo cách này, mỗi lúc nó chỉ vẽ được một điểm.
Nếu bạn chạy {\tt plot} lần nữa, nó xóa toàn bộ hình vẽ trước khi vẽ hình mới. 
Lệnh {\tt hold} giúp bạn thay đổi đặc tính nêu trên. {\tt hold on} báo với 
Octave rằng không được xóa hình cũ khi vẽ hình mới; và {\tt hold off}
trở lại đặc tính ban đầu.

Hãy thử các lệnh này:

\begin{verbatim}
>> hold on
>> plot(1, 1, 'o')
>> plot(2, 2, 'o')
\end{verbatim}
%
Bạn sẽ nhìn thấy một hình có hai điểm. Octave co dãn tỉ lệ đồ thị
một cách tự động sao cho các trục chạy từ giá trị nhỏ nhất trên đồ thị
đến giá trị lớn nhất. Vì vậy ở ví dụ này, các điểm chấm xuất hiện ở
hai góc.

\begin{ex}
Hãy sửa lại \verb#car_loop# sao cho qua mỗi vòng lặp, chương trình
sẽ chấm lên đồ thị giá trị của {\tt a} theo {\tt i}.

Một khi chương trình của bạn chạy được, hãy sửa lại để nó chấm
các giá trị của {\tt a} bằng vòng tròn đỏ và của {\tt b} bằng 
hình thoi xanh lam.

Thêm nữa: nếu bạn dùng {\tt hold on} để ngăn không cho Octave 
xóa hình vẽ, bạn vẫn có thể tự xóa hình theo ý muốn bằng lệnh
{\tt clf}.
\end{ex}


\section{Dãy}

Trong toán học, một {\bf dãy} là một tập hợp các số tương ứng với
các số nguyên dương. Các số trong dãy được gọi là 
{\bf phần tử}. Theo kí hiệu toán học, các phần tử được kèm theo 
các chỉ số dưới, vì vậy phần tử đầu tiên của dãy $A$ là $A_1$,
tiếp theo là $A_2$, và cứ như vậy.

Vòng lặp {\tt for} là một cách tự nhiên để tính các phần tử trong một
dãy. Chẳng hạn, trong dãy hình học, mỗi phần tử là một bội số (với
hệ số không đổi) của số liền trước. Cụ thể, hãy xét dãy số với 
$A_1 = 1$ và tỉ lệ $A_{i+1} / A_i = 2$, với mọi $i$. Nói cách khác,
mỗi phần tử chỉ lớn bằng nửa phần tử liền trước nó.

Vòng lặp sau đây tính ra 10 phần tử đầu của $A$:

\begin{verbatim}
a = 1
for i=2:10
    a = a/2
end
\end{verbatim}
%
Mỗi lượt lặp, ta tìm được phần giá trị tiếp theo của {\tt a}
bằng cách chia giá trị trước cho 2. Lưu ý rằng dãy chỉ số bắt
đầu từ 2 vì giá trị đầu của {\tt a} tương ứng với $A_1$, vì vậy
lượt lặp đầu tiên ta đi tính $A_2$.

Mỗi lần qua vòng lặp, ta thay thế phần tử trước bởi phần tử
kế tiếp, vì vậy về cuối, {\tt a} chứa phần tử thứ 10. Các phần tử
khác được hiển thị trên màn hình, nhưng chúng không được lưu
lại trong một biến nào. Sau này, ta sẽ xem cách lưu toàn bộ các
phần tử của dãy vào một véc-tơ.

Vòng lặp này tính dãy theo cách {\bf truy hồi}, nghĩa là mỗi phần tử
đều phụ thuộc vào phần tử liền trước nó. Với dạng dãy này ta cũng
có thể tính {\bf trực tiếp} phần tử thứ $i$, theo một hàm của $i$,
mà không cần dùng đến phần tử đứng trước. Theo cách viết
toán học, $A_i = A_1 r^{i-1}$.  

\begin{ex}
Hãy viết một tập tin lệnh có tên {\tt sequence} trong đó dùng vòng lặp
để tính các phần tử của $A$ một cách trực tiếp.
\end{ex}


\section{Chuỗi}
\label{chuỗi}

Trong toán học, {\bf chuỗi} là tổng các phần tử của một dãy. 
Cách đặt tên này không hay trong tiếng Anh (``sequence'' và 
``series'' gần như có chung nghĩa); nhưng trong toán thì
dãy là một tập hợp số, còn chuỗi lại là một biểu thức (một
tổng) với một giá trị duy nhất. Theo kí hiệu toán học, một
chuỗi thường được viết với dấu tổng $\sum$.

Chẳng hạn, tổng của 10 phần tử đầu tiên của $A$ là

\[ \sum_{i=1}^{10} A_i \]

Một vòng lặp {\tt for} là cách tự nhiên để tính giá trị của
chuỗi này:

\begin{verbatim}
A1 = 1;
total = 0;
for i=1:10
    a = A1 * 0.5^(i-1);
    total = total + a;
end
ans = total
\end{verbatim}

{\tt A1} là phần tử đầu tiên của dãy, vì vậy ở mỗi lượt lặp, 
{\tt a} là phần tử thứ $i$.

Biến {\tt total}, theo cách dùng ở đây, đôi khi được gọi là 
{\bf biến tích lũy}; tức là một biến mà dồn lại lần lượt từng kết quả 
của các phép tính. Trước vòng lặp ta đặt biến này bằng 0.  Mỗi
lượt lặp ta cộng nó với phần tử thứ $i$. Ở cuối vòng lặp, 
{\tt total} sẽ chứa tổng của các phần tử. Vì đó là giá trị mà
ta cần tìm, ta gán nó cho {\tt ans}.

\begin{ex}
Ví dụ trên đã tính các phần tử của chuỗi một cách trực tiếp;
bạn hãy thử viết một tập tin lệnh tên là {\tt series} để tính
cùng tổng đó nhưng với từng phần tử được tính theo cách
truy hồi. Bạn sẽ phải cẩn thận về các vị trí bắt đầu và kết thúc
vòng lặp.
\end{ex}


\section{Khái quát hóa}

Như đã nói, ví dụ trên luôn luôn lấy tổng 10 phần tử đầu tiên
của dãy, nhưng ta có thể tò mò muốn biết giá trị {\tt total}
sẽ như thế nào khi ta tăng số lượng các số hạng có trong chuỗi.
Nếu bạn đã biết về chuỗi hình học, bạn thấy rằng chuỗi này
hội tụ về 2; nghĩa là khi số các số hạng tiến đến vô cùng, thì
tổng sẽ tiệm cận về 2.

Để thấy được liệu điều đó có đúng không, trong chương trình
ta sẽ thay thế hằng số, 10, với một biến có tên {\tt n}:

\begin{verbatim}
A1 = 1;
total = 0;
for i=1:n
    a = A1 * 0.5^(i-1);
    total = total + a;
end
ans = total
\end{verbatim}

Bây giờ đoạn chương trình có thể tính với bao nhiêu số hạng
cũng được, với điều kiện trước là bạn phải đặt {\tt n} trước khi
chạy chương trình này. Sau đây là cách chạy chương trình
với các giá trị {\tt n} khác nhau:

\begin{verbatim}
>> n=10; series
total = 1.99804687500000

>> n=20; series
total = 1.99999809265137

>> n=30; series
total = 1.99999999813735

>> n=40; series
total = 1.99999999999818
\end{verbatim}
%
Rõ ràng là nó đang hội tụ về 2.

Việc thay thế một hằng số bởi một biến được gọi là 
{\bf khái quát hóa}. Thay vì tính với một số lượng cụ thể 
và cố định các số hạng, chương trình mới này tổng quát hơn;
nó có thể tính với số các số hạng bất kì.

Đây là một ý tưởng quan trọng mà ta sẽ quay về khi thảo luận
đến các hàm.


\section{Thuật ngữ}

\begin{description}

\item[sai số tuyệt đối:] Độ chênh lệch giữa giá trị xấp xỉ và kết quả
đúng.

\item[sai số tương đối:] Độ chênh lệch giữa giá trị xấp xỉ và kết quả
đúng, biểu diễn dưới dạng một phần hoặc số phần trăm của giá trị
đúng.

\item[vòng lặp:] Phần của chương trình được chạy đi chạy lại
nhiều lần.

\item[biến lặp:] Biến được định nghĩa trong một câu lệnh {\tt for};
nó được gán các giá trị khác nhau qua mỗi lượt lặp.

\item[khoảng:] Tập hợp các giá trị được gán cho một biến lặp, thường
được biểu thị bởi toán tử hai chấm, chẳng hạn {\tt 1:5}.

\item[phần thân:] Những câu lệnh bên trong vòng lặp được thực hiện
lặp lại nhiều lần.

\item[dãy:] Trong toán học, một tật hợp các số tương ứng với những
số nguyên.

\item[phần tử:] Một thành viên của tập hợp các số trong dãy.

\item[truy hồi:] Cách tính phần tử kế tiếp trong dãy dựa trên những
phần tử liền trước.

\item[trực tiếp:] Cách tính phần tử trong dãy mà không cần dùng đến
những phần tử trước.

\item[chuỗi:] Tổng của các phần tử trong một dãy.

\item[biến tích lũy:] Biến được dùng để tích tụ kết quả từng ít một.

\item[khái quát hóa:] Cách làm chương trình linh hoạt hơn, chẳng hạn
bằng việc thay thế một giá trị cụ thể bởi một biến có thể nhận giá trị
bất kì.

\end{description}


\section{Bài tập}

\begin{ex}
\label{fib2}

Ta đã thấy các dãy Fibonacci, $F$, vốn được định nghĩa theo cách
truy hồi như sau

\[ F_{i} = F_{i-1} + F_{i-2} \]

Để bắt đầu, bạn phải chỉ định hai phần tử đầu tiên, nhưng một khi
có hai phần tử này rồi, bạn có thể tính toàn bộ các phần tử còn lại.
Dãy Fibonacci thông dụng nhất khởi đầu với $F_1 = 1$ và $F_2 = 1$.

Hãy viết một đoạn mã lệnh có tên là {\tt fibonacci2} trong đó dùng
một vòng lặp để tính 10 phần tử đầu tiên của dãy Fibonacci. Điều 
kiện cuối của chương trình là gán phần tử thứ 10 cho {\tt ans}.

Bây giờ hãy khái quát hóa chương trình để nó tính phần tử thứ
$n$ với {\tt n} bất kì, kèm theo điều kiện trước là bạn phải đặt 
giá trị cho {\tt n} trước khi chạy chương trình. Để đơn giản, tạm thời
ta giả sử rằng {\tt n} lớn hơn 2.

Gợi ý: bạn sẽ phải dùng hai biến để theo dõi hai phần tử liền trước
của dãy. Có thể đặt tên chúng là {\tt prev1} và {\tt prev2}.
Ban đầu, {\tt prev1 =} $F_1$ còn {\tt prev2 =} $F_2$.  Ở cuối
mỗi lượt lặp, bạn sẽ phải cập nhật {\tt prev1} và {\tt prev2}; 
hãy tính cẩn thận thứ tự cập nhật!
\end{ex}


\begin{ex}
\label{fib_plot}

Hãy viết một tập tin lệnh có tên \verb#fib_plot# trong đó lặp {\tt i}
từ 1 đến 20, dùng {\tt fibonacci2} để tính số Fibonacci, rồi chấm 
$F_i$ với mỗi $i$ dưới dạng một loạt điểm tròn màu đỏ.

\end{ex}


% chap04
\chapter{Véc-tơ}
\label{vectors}

\section{Kiểm tra điều kiện trước}

Một số vòng lặp ở chương trước sẽ không chạy đúng nếu
giá trị của {\tt n} không được đặt đúng trước khi vòng lặp bắt đầu
chạy. Chẳng hạn, vòng lặp sau đây dùng để tính tổng của {\tt n} 
phần tử đầu tiên của một dãy hình học:

\begin{verbatim}
A1 = 1;
total = 0;
for i=1:n
    a = A1 * 0.5^(i-1);
    total = total + a;
end
ans = total
\end{verbatim}
%
Nó chạy đúng với bất kì giá trị dương nào của {\tt n}, nhưng
điều gì sẽ xảy ra nếu {\tt n} âm? Lúc đó, bạn sẽ nhận được:

\begin{verbatim}
total = 0
\end{verbatim}
%
Vì sao? Bởi biểu thức {\tt 1:-1} nghĩa là ``tất cả các số từ
1 đến $-$1, đếm theo chiều xuôi.'' Điều này không thật hiển nhiên, 
nhưng Octave hiểu rằng chẳng có con số nào trong một
khoảng như vậy, vì thế kết quả là

\begin{verbatim}
>> 1:-1
ans = [](1x0)
\end{verbatim}
%
và ta thu được ma trận rỗng. Trong mọi trường hợp, nếu bạn lặp qua một
khoảng rỗng, thì vòng lặp không chạy chút nào; đó là lý do 
tại sao ở ví dụ này giá trị của {\tt total} bằng không với mọi
giá trị âm của {\tt n}.

Nếu bạn chắc rằng mình chẳng bao giờ mắc lỗi, và các 
điều kiện trước cho các hàm viết ra luôn được thỏa mãn, thì bạn
chẳng phải kiểm tra. Nhưng với hầu hết chúng ta, thật nguy hiểm
khi viết một chương trình như thế này, một chương trình có thể
cho kết quả sai (hoặc ít nhất là vô nghĩa) nếu giá trị đầu vào
là số âm. Một cách làm tốt hơn là dùng lệnh {\tt if}.


\section{{\tt if}}

Lệnh {\tt if} cho phép kiểm tra những điều kiện nhất định và
thực hiện câu lệnh nếu điều kiện được thỏa mãn. Ở ví dụ trước,
ta đã có thể viết:

\begin{verbatim}
if n<0
    ans = NaN
end
\end{verbatim}
%
Cú pháp ở đây cũng tương tự một vòng lặp {\tt for}. Dòng đầu tiên
chỉ định điều kiện mà ta quan tâm đến; trong trường hợp này
ta đang hỏi liệu {\tt n} có âm không.  Nếu có, Octave thực hiện
phần thân của câu lệnh, tức là các lệnh nằm giữa 
{\tt if} và {\tt end}.

Octave không yêu cầu bạn viết thụt đầu dòng những lệnh trong
phần thân của lệnh {\tt if}, nhưng nó giúp cho mã lệnh viết ra 
dễ đọc hơn; và bạn nên làm điều này, có lẽ tôi cũng không phải
nhắc nữa.

Ở ví dụ này, điều ``đúng đắn'' cần làm nếu {\tt n} âm là đặt
{\tt ans = NaN}, vốn là một cách tiêu chuẩn để cho thấy rằng
kết quả không được xác định (không phải một con số).

Nếu điều kiện không được thỏa mãn thì những câu lệnh trong phần thân
không được thực hiện. Đôi khi có những câu lệnh khác cần được
thực hiện khi điều kiện sai. Trong trường hợp đó bạn có thể
mở rộng lệnh {\tt if} với một vế {\tt else}.

Dạng hoàn chỉnh của chương trình ví dụ trên có thể trông như sau:

\begin{verbatim}
if n<0
    ans = NaN
else
    A1 = 1;
    total = 0;
    for i=1:n
        a = A1 * 0.5^(i-1);
        total = total + a;
    end
    ans = total
end
\end{verbatim}
%
Các lệnh như {\tt if} và {\tt for} trong đó chứa những câu lệnh khác
được gọi là lệnh {\bf phức hợp}. Tất cả các lệnh phức hợp đều 
kết thúc với {\tt end}.

Ở ví dụ này, một trong những câu lệnh trong vế {\tt else} là một 
vòng lặp {\tt for}. Việc đặt một câu lệnh phức hợp bên trong một
lệnh phức hợp khác là hợp lệ và cũng thường gặp; cách này đôi
khi được gọi là {\bf lồng ghép}.


\section{Toán tử quan hệ}

Các toán tử để so sánh hai giá trị, như toán tử {\tt <} và 
{\tt >}, được gọi là {\bf toán tử quan hệ} ví chúng kiểm tra 
mối tương quan giữa hai biến. Kết quả của một toán tử quan hệ
là một trong hai {\bf giá trị logic}: 1 (biểu diễn cho ``đúng''),
hoặc 0 (biểu diễn cho ``sai'').

Các toán tử quan hệ thường xuất hiện trong lệnh {\tt if},
nhưng bạn cũng có thể lượng giá chúng tại dấu nhắc lệnh:

\begin{verbatim}
>> x = 5;
>> x < 10
ans = 1
\end{verbatim}

Bạn cũng có thể gán một giá trị logic vào một biến:

\begin{verbatim}
>> flag = x > 10
flag = 0
\end{verbatim}

Một biến có chứa một giá trị logic thường được gọi là {\bf cờ}
vì chúng đánh dấu trạng thái của một điều kiện nào đó.

Các toán tử quan hệ khác gồm có {\tt <=} và {\tt >=}, vốn
rất dễ hiểu, {\tt ==}, nghĩa là ``bằng,'' và
\verb+~=+, nghĩa là ``khác''.  (Trong kí hiệu logic, dấu ``ngã''
còn biểu thị cho ``không.'')

Đừng quên rằng {\tt ==} là toán tử để kiểm tra độ bằng nhau, còn
{\tt =} là toán tử gán. Nếu bạn thử dùng {\tt =} trong
câu lệnh {\tt if}, mặc dù Octave không phàn nàn gì về
điều này nhưng tốt nhất là ta dùng {\tt ==} để đảm bảo 
tương thích với các đoạn chương trình khác:\footnote{MATLAB
chắc chắn sẽ báo lỗi khi bạn dùng một dấu bằng cho lệnh \texttt{if}.}

\begin{verbatim}
if x=5
end
warning: suggest parenthesis around assignment used as truth value
\end{verbatim}
%
% Octave nghĩ rằng bạn đang gán giá trị cho một biến tên là {\tt if x}! 


\section{Toán tử logic}
\label{logop}

Để kiểm tra rằng một số nào đó có rơi vào khoảng cho trước không,
bạn có thể muốn viết {\tt 0 < x < 10}, nhưng đó là cách làm sai.
Thật không may là trong nhiều trường hợp, bạn nhận được
kết quả đúng nhưng lại vì một lý do sai. Chẳng hạn:

\begin{verbatim}
>> x = 5;
>> 0 < x < 10            % right for the wrong reason
ans = 1
\end{verbatim}
%
Xin đừng bị đánh lừa!

\begin{verbatim}
>> x = 17
>> 0 < x < 10            % just plain wrong
ans = 1
\end{verbatim}
%
Vấn đề là ở chỗ Octave lượng giá các toán tử từ trái qua phải,
vì vậy đầu tiên là nó kiểm tra xem có phải {\tt 0<x} không. 
Đúng vậy, do đó kết quả bằng 1. Tiếp theo nó so sánh giá trị
logic 1 (chứ không phải giá trị của {\tt x}) với 10.  
Vì {\tt 1<10}, nên kết quả là đúng, ngay cả khi {\tt x}
không thuộc khoảng số.

Với những người mới bắt đầu lập trình, đây là một lỗi rất hiểm!

Một cách tránh tình huống này là dùng một cặp lệnh {\tt if} 
lồng ghép để kiểm tra riêng hai vế điều kiện:

\begin{verbatim}
ans = 0
if 0<x
    if x<10
        ans = 1
    end
end
\end{verbatim}
%
Nhưng sẽ gọn hơn nếu ta dùng toán tử AND (và), {\tt \&\&}, 
để kết hợp các điều kiện lại.

\begin{verbatim}
>> x = 5;
>> 0<x && x<10
ans = 1

>> x = 17;
>> 0<x && x<10
ans = 0
\end{verbatim}
%
Kết quả của AND là đúng nếu {\em cả hai} toán hạng đều đúng.
Toán tử OR (hoặc), {\tt ||}, sẽ đúng nếu 
{\em một trong hai, hoặc cả hai} toán hạng đúng.


\section{Véc-tơ}

Các giá trị mà ta đã thấy đến giờ đều là những con số đơn lẻ,
và được gọi là {\bf vô hướng} để phân biệt với {\bf véc-tơ}
và {\bf ma trận}, vốn là các tập hợp số.

Một véc-tơ trong Octave cũng giống như một dãy số trong
toán học, đó là một tập hợp các số tương ứng với những số
nguyên dương. Cái mà ta gọi là ``khoảng'' ở chương trước
thực ra là một véc-tơ.

Nói chung, bất kể phép tính gì thực hiện được với số vô hướng
đều cũng có thể thực hiện được với véc-tơ. Bạn có thể gán
giá trị véc-tơ cho một biến:

\begin{verbatim}
>> X = 1:5

X = 1     2     3     4     5
\end{verbatim}
%
Các biến chứa véc-tơ thường được kí hiệu bằng chữ in. Đó 
chỉ là quy ước; Octave không yêu cầu điều này, với nhưng người
mới lập trình, đây là một cách hữu ích để nhớ ra đâu là số vô hướng
và đâu là véc-tơ.

Cũng như với dãy, các số hợp thành một véc-tơ thì được gọi là các
{\bf phần tử}.


\section{Phép toán số học với véc-tơ}

Bạn có thể thực hiện phép tính số học với véc-tơ. Nếu bạn cộng
một số vô hướng với một véc-tơ, Octave sẽ cộng số vô hướng
đo cho từng phần tử của véc-tơ:

\begin{verbatim}
>> Y = X+5

Y = 6     7     8     9    10
\end{verbatim}
%
Kết quả là một véc-tơ mới; giá trị ban đầu của {\tt X} vẫn
không đổi.

Nếu bạn cộng hai véc-tơ, Octave sẽ cộng các phần tử tương ứng
của mỗi véc-tơ và tạo ra một véc-tơ mới chứa các tổng:

\begin{verbatim}
>> Z = X+Y

Z = 7     9    11    13    15
\end{verbatim}
%
Nhưng phép cộng véc-tơ chỉ được khi hai véc-tơ số hạng có cùng
kích cỡ. Nếu không thì:

\begin{verbatim}
>> W = 1:3

W = 1     2     3

>> X+W
error: operator +: nonconformant arguments (op1 is 1x5, op2 is 1x3)
\end{verbatim}
%
Thông báo lỗi này chỉ ra rằng các đối số trong phép cộng không tương thích
(nonconformant), đồng thời chỉ ra kích thước cụ thể của từng đối số. Bạn có
thể hình dung ra \texttt{1x5} là để chỉ kích thước của dãy này: có thể coi nó
là 1 hàng gồm 5 phần tử. À, điều này thì ta sẽ cụ thể trong mục sau.
%Vấn đề chỉ là một sự
%không khớp giữa từ vựng toán học và từ vựng trong Octave.


\section{Mọi thứ đều là ma trận}

Trong toán học (đặc biệt là đại số tuyến tính), một véc-tơ là một dãy
một chiều các giá trị còn ma trận có hai chiều (và nếu bạn muốn
nghĩ theo cách đó thì số vô hướng là đại lượng không chiều). 
Trong Octave, mọi thứ đều là ma trận.

Bạn có thể thấy điều này khi dùng lệnh {\tt whos} để hiển thị các
biến trong không gian làm việc.  {\tt whos} cũng giống như 
{\tt who}, chỉ khác ở chỗ nó còn hiển thị cả kích cỡ và kiểu của
từng biến.

Trước hết tôi sẽ tạo ra các giá trị có kiểu khác nhau:

\begin{verbatim}
>> scalar = 5
scalar = 5

>> vector = 1:5
vector = 1     2     3     4     5

>> matrix = ones(2,3)
matrix =

     1     1     1
     1     1     1
\end{verbatim}
%
{\tt ones} là một hàm để lập một ma trận mới với số hàng và
số cột đã cho, rồi đặt tất cả các phần tử bằng 1. Bây giờ hãy
xem ta có gì.

\begin{verbatim}
>> whos
Variables in the current scope:

  Attr Name        Size                  Bytes  Class
  ==== ====        ====                  =====  ===== 
       matrix      2x3                      48  double
       scalar      1x1                       8  double
       vector      1x5                      24  double

Total is 12 elements using 80 bytes
\end{verbatim}
%
Theo Octave, mọi thứ đều là ma trận có độ chính xác kép:  
``double'' là tên gọi khác của số có dấu chấm động với 
độ chính xác kép.

Điểm khác biệt duy nhất giữa các biến này là kích cỡ, vốn được chỉ định
bởi số hàng và số cột. Biến số vô hướng, {\tt scalar}, theo
Octave, là một ma trận có 1 hàng và 1 cột.  Còn {\tt vector} là
một ma trận thực sự với 1 hàng và 5 cột. Và tất nhiên, 
{\tt matrix} là một ma trận.

Mục đích của tât cả những điều trên là bạn có thể coi các 
giá trị trong chương trình như là số vô hướng, véc-tơ và ma trận,
và tôi nghĩ rằng bạn nên như vậy, chỉ cần nhớ rằng Octave
coi mọi thứ như ma trận.

Sau đây là một ví dụ khác trong đó thông báo lỗi chỉ có nghĩa
nếu bạn hiểu được điều gì đang xảy ra bên trong:

\begin{verbatim}
>> X = 1:5

X = 1     2     3     4     5

>> Y = 1:5

Y = 1     2     3     4     5

>> Z = X*Y
error: operator *: nonconformant arguments (op1 is 1x5,
	op2 is 1x5)
\end{verbatim}
%
Lại điều gì nữa đây?---lần này bạn có thể tự hỏi như vậy. Nhưng
Octave đã đúng, vì theo nguyên tắc định nghĩa phép nhân ma trận
trong đại số tuyến tính, cột của {\tt X} phải bằng số hàng
của {\tt Y}.

Nếu bạn không biết đại số tuyến tính thì cũng không sao. Khi 
nhìn thấy {\tt X*Y} có lẽ bạn mong đợi rằng từng phần tử của
{\tt X} phải được nhân với từng phần tử của 
{\tt Y} và kết quả được đưa vào một véc-tơ mới. Phép toán đó
được gọi là phép nhân {\bf phần tử}, và toán tử thực hiện
công việc này là {\tt .*}:

\begin{verbatim}
>> X .* Y

ans = 1     4     9    16    25
\end{verbatim}
%
Ta sẽ trở lại các toán tử thao tác trên phần tử vào một dịp
khác; bạn có thể tạm quên chúng.




\section{Chỉ số}

Bạn có thể chọn phần tử trong một véc-tơ bằng cách dùng
cặp ngoặc tròn:

\begin{verbatim}
>> Y = 6:10

Y = 6     7     8     9    10

>> Y(1)
ans = 6

>> Y(5)
ans = 10
\end{verbatim}
%
Điều này nghĩa là phần tử thứ nhất của {\tt Y} bằng 6 và
phần tử thứ năm bằng 10. Con số trong ngoặc tròn được gọi
là {\bf chỉ số} vì nó biểu thị phần tử mà bạn muốn của
véc-tơ.

Chỉ số có thể là một biểu thức bất kì.

\begin{verbatim}
>> i = 1;
>> Y(i+1)
ans = 7
\end{verbatim}
%
Vòng lặp đi cùng véc-tơ cũng tựa như hổ mọc thêm cánh.
Chẳng hạn, vòng lặp này hiển thị các phần tử của {\tt Y}.

\begin{verbatim}
for i=1:5
     Y(i)
end
\end{verbatim}
%
Mỗi lượt lặp ta dùng một giá trị khác của {\tt i} làm chỉ số
cho {\tt Y}.

Một hạn chế trong ví dụ này là nếu ta phải biết trước số
phần tử của {\tt Y}. Ta có thể khái quát hóa bằng cách dùng
hàm {\tt length}, vốn để trả lại số phần tử trong một véc-tơ.

\begin{verbatim}
for i=1:length(Y)
     Y(i)
end
\end{verbatim}
%
Vậy đấy. Bây giờ nó sẽ chạy được với một véc-tơ có độ dài tùy ý.


\section{Lỗi chỉ số}

Một chỉ số có thể là biểu thức bất kì, nhưng giá trị của 
biểu thức này phải là số nguyên dương, và nó phải nhỏ hơn
hoặc bằng chiều dài của véc-tơ. Nếu nó bằng không hoặc âm,
bạn sẽ nhận được thông báo sau:

\begin{verbatim}
>> Y(0)
error: subscript indices must be either positive integers
	or logicals
\end{verbatim}
%
``Subscript indices'' chính là ``indices'', chỉ số trong Octave.
``positive integers'' tức là số nguyên dương. Và bạn cũng có thể 
tạm quên đi ``logicals'' (kiểu giá trị logic).

Nếu chỉ số quá lớn, bạn sẽ thu được:

\begin{verbatim}
>> Y(6)
error: A(I): index out of bounds; value 6 out of bound 5
\end{verbatim}
%
Thông báo lỗi này tương đối rõ ràng: giá trị chỉ số vượt ngoài  khoảng
cho phép là 5.

Sau cùng, đừng quên rằng chỉ số phải là một số nguyên:

\begin{verbatim}
>> Y(1.5)
error: subscript indices must be either positive integers
	or logicals
\end{verbatim}


\section{Véc-tơ và dãy số}

Véc-tơ và dãy số thường gắn bó mật thiết với nhau. Chẳng hạn, một
cách khác để tính dãy Fibonacci là bằng cách lưu các giá trị liên
tiếp vào một véc-tơ. Một lần nữa, định nghĩa của dãy Fibonacci là
$F_1 = 1$, $F_2 = 1$, và $F_{i} = F_{i-1} +
F_{i-2}$ với $i \ge 3$.  Trong Octave, câu lệnh sẽ có dạng

\begin{verbatim}
F(1) = 1
F(2) = 1
for i=3:n
    F(i) = F(i-1) + F(i-2)
end
ans = F(n)
\end{verbatim}
%
Lưu ý rằng tôi dùng chữ cái viết in cho véc-tơ {\tt F}
và chữ cái thường cho các số vô hướng {\tt i} và {\tt n}.
Cuối cùng, đoạn chương trình lấy phần tử chót của {\tt F} và
lưu nó vào {\tt ans}, vì kết quả của chương trình phải là
số Fibonacci thứ $n$, chứ không phải cả dãy số.

Nếu từng gặp vướng mắc ở Bài tập~\ref{fib2}, bạn phải 
trân trọng sự giản đơn của phiên bản chương trình trên. 
Cú pháp của Octave cũng tương đồng với kí hiệu toán học; nó
làm ta dễ kiểm tra tính đúng đắn của chương trình. Song 
có những nhược điểm cần lưu ý gồm

\begin{itemize}

\item Bạn phải cẩn thận với khoảng số của vòng lặp. Ở đoạn
chương trình trên, vòng lặp chạy từ {\tt 3} đến {\tt n},
và mỗi lần ta gán một giá trị vào phần tử thứ {\tt i}.
Nó cũng chạy khi ta ``đẩy'' chỉ số đi hai đơn vị, cho
vòng lặp chạy từ 1 đến {\tt n-2}:

\begin{verbatim}
F(1) = 1
F(2) = 1
for i=1:n-2
    F(i+2) = F(i+1) + F(i)
end
ans = F(n)
\end{verbatim}
%
Bạn dùng phiên bản nào cũng được, nhưng cần chọn một cách
làm và phải thống nhất với nó. Nếu bạn kết hợp các phần tử
của cả hai cách, bạn sẽ bị lẫn. Tôi ưa dùng dạng có {\tt F(i)}
bên vế trái lệnh gán, vì vậy mỗi lượt lặp nó sẽ gán cho phần
tử thứ {\tt i}.

\item Nếu bạn thực sự chỉ muốn số Fibonacci thứ $n$, việc 
lưu trữ cả dãy số sẽ làm tốn dung lượng bộ nhớ của máy. Nhưng
nếu mất dung lượng mà đoạn mã trở nên dễ viết và gỡ lỗi hơn
thì có lẽ vẫn tốt.

\end{itemize}

\begin{ex}
Hãy viết một vòng lặp để tính {\tt n} phần tử đầu tiên của
dãy hình học $A_{i+1} = A_i/2$ với $A_1 = 1$. Lưu ý rằng
kí hiệu toán học đặt $A_{i+1}$ ở vế trái của đẳng thức.
Khi chuyển sang mã lệnh Octave, có thể bạn sẽ phải đẩy dịch
chỉ số.
\end{ex}


\section{Vẽ đồ thị các véc-tơ}

Tính năng vẽ đồ thị rất hữu ích đối với biểu diễn véc-tơ. Nếu bạn
gọi {\tt plot} với đối số là một véc-tơ, Octave sẽ lấy các 
chỉ số tọa độ theo phương $x$ và giá trị các phần tử làm tọa độ
theo phương $y$. Để biểu diễn giá trị các số Fibonacci đã tính được ở
mục trước:

\begin{verbatim}
plot(F)
\end{verbatim}
%
Hình biểu diễn này thường có ích cho việc gỡ lỗi, đặc biệt là khi
véc-tơ của bạn lớn đến nỗi việc in các giá trị số lên màn hình
trở nên vô hiệu.

Nếu bạn gọi {\tt plot} với đối số là hai véc-tơ, Octave sẽ 
vẽ véc-tơ thứ hai như một hàm số của véc-tơ đầu; nghĩa là 
giá trị của véc-tơ đầu làm các tọa độ $x$ còn các giá trị tương ứng
của véc-tơ sau làm tọa độ $y$ rồi vẽ các cặp điểm $(x, y)$.

\begin{verbatim}
X = 1:5
Y = 6:10
plot(X, Y)
\end{verbatim}
%
Octave mặc định màu nét vẽ là xanh lam, nhưng bạn có thể thay đổi
bằng một chuỗi kí tự có dạng giống như ta đã thấy ở Mục~\ref{plotting}.
Chẳng hạn, chuỗi {\tt 'ro-'} ra lệnh cho Octave vẽ những vòng tròn nhỏ
ở mỗi điểm dữ liệu; dấu gạch ngang ngụ ý rằng các điểm cần được nối
bởi đường thẳng.

Trong ví dụ này, tôi gắn chặt với quy ước đặt tên đối số thứ nhất
là {\tt X} (vì nó ứng với tọa độ $x$) và đối số thứ hai {\tt Y}.
Không có gì đặc biệt với những cái tên này; bạn hoàn toàn
có thể vẽ {\tt X} như là hàm theo {\tt Y}. Octave luôn coi 
véc-tơ thứ nhất là biến độc lập, và véc-tơ thứ hai là biến phụ thuộc.



\section{Phép rút gọn}
\label{reduce}

Một cách dùng hay thấy ở vòng lặp là chạy qua các phần tử của một
mảng vầ cộng chúng lại, hoặc nhân với nhau, hoặc tính tổng các
bình phương, v.v. Kiểu tính toán này được gọi là {\bf phép rút gọn},
vì nó rút gọn một véc-tơ với nhiều phần tử về một con số vô hướng.

Chẳng hạn, vòng lặp này cộng lại những phần tử của một véc-tơ có tên
{\tt X} (mà ta coi rằng nó đã được định nghĩa trước).

\begin{verbatim}
total = 0
for i=1:length(X)
    total = total + X(i)
end
ans = total
\end{verbatim}
%
Các dùng {\tt total} như một biến thu gom cũng giống như điều ta đã
thấy ở Mục~\ref{series}.  Một lần nữa, ta dùng hàm {\tt length}
để xác định giới hạn trên của khoảng, vì vậy vòng lặp này sẽ chạy
được bất kể độ dài của {\tt X} bằng bao nhiêu. Mỗi lượt lặp, 
ta cộng {\tt total} với phần tử thứ {\tt i} của {\tt X}, 
vì vậy khi hết vòng lặp {\tt total} sẽ mang giá trị tổng của
tất cả phần tử.

\begin{ex}
Hãy viết một vòng lặp để nhân tất cả các phần tử của một véc-tơ
với nhau. Có thể bạn sẽ cần đặt một biến thu gom {\tt product}, 
và phải nghĩ xem đặt giá trị ban đầu bằng bao nhiêu trước khi
vòng lặp được thực thi.
\end{ex}


\section{Áp dụng}
\label{apply}

Một công dụng khác của hàm là chạy qua các phần tử của một
véc-tơ, thực hiện một phép toán nào đó lên từng phần tử, rồi
tạo ra véc-tơ mới chứa các kết quả. Dạng tính toán này được
gọi là {\bf áp dụng}, bởi vì khi đó bạn áp dụng phép toán với
từng phần tử của véc-tơ.

Chẳng hạn, vòng lặp sau đây tính một véc-tơ {\tt Y} trong đó
chứa các bình phương của từng phần tử thuộc {\tt X} 
(một lần nữa, ta giả sử rằng {\tt X} đã được định nghĩa).

\begin{verbatim}
for i=1:length(X)
    Y(i) = X(i)^2
end
\end{verbatim}
%
\begin{ex}
Hãy viết một vòng lặp để tính một véc-tơ {\tt Y} trong đó
chứa các giá trị sin của từng phần tử thuộc {\tt X}.  Để kiểm tra
vòng lặp của bạn, hãy viết một chương trình 

\begin{enumerate}

\item sử dụng {\tt linspace} (xem thông tin cách dùng) để gán
{\tt X} là véc-tơ gồm 100 phần tử từ 0 đến $2 \pi$.

\item dùng vòng lặp vừa viết để lưu các giá trị sin vào {\tt Y}.

\item Vẽ đồ thị các phần tử của {\tt Y} như là hàm của từng phần tử
thuộc {\tt X}.

\end{enumerate}
\end{ex}

\section{Tìm kiếm}
\label{search}

Một cách dùng khác của vòng lặp là tìm kiếm những phần tử trong
một véc-tơ rồi trả lại chỉ số của giá trị mà bạn cần tìm (hoặc
giá trị đầu tiên thỏa mãn đặc tính nào đó). Chẳng hạn, nếu một
véc-tơ bao gồm các giá trị độ cao tính được của một vật thể
rơi, bạn có lẽ cũng muốn biết chỉ số nào của véc-tơ đó ứng với
lúc vật thể chạm đất (coi rằng mặt đất ở cao độ bằng 0).

Để tạo ra dữ liệu giả định, ta sẽ dùng một dạng đầy đủ của 
toán tử hai chấm:

\begin{verbatim}
X = 10:-1:-10
\end{verbatim}
%
Các giá trị trong khoảng này chạy từ 10 đến $-10$, với 
{\bf độ dài bước} là $-1$. Độ dài bước là khoảng cách giữa các
phần tử cạnh nhau trong khoảng.

Vòng lặp sau tìm ra chỉ số của phần tử bằng 0 trong {\tt X}:

\begin{verbatim}
for i=1:length(X)
    if X(i) == 0
        ans = i
    end
end
\end{verbatim}
%
Một điều buồn cười ở vòng lặp này là nó tiếp tục chạy ngay cả khi
đã tìm được giá trị mong muốn. Đây có lẽ không phải là điều bạn
cần. Song cũng có thể bạn muốn làm cách này, nếu giá trị cần tìm
xuất hiện nhiều lần; khi đó vòng lặp sẽ cho chỉ số của phần tử
{\em cuối cùng} thỏa mãn điều kiện đề ra.

Nhưng nếu bạn muốn chỉ số của phần tử đầu tiên (hay biết rằng chỉ
có một phần tử như vậy), bạn có thể tiết kiệm một số vòng lặp 
không cần thiết bằng cách dùng câu lệnh {\tt break}.

\begin{verbatim}
for i=1:length(X)
    if X(i) == 0
        ans = i
        break
    end
end
\end{verbatim}
%
{\tt break} có tác dụng giống như tên gọi của nó: thoát khỏi
vòng lặp. Nó dừng vòng lặp và thực hiện câu lệnh ngay sau 
vòng lặp (trong trường hợp này, không còn câu lệnh nào nữa,
và chương trình kết thúc).

Ví dụ trên minh hoạ cho ý tưởng cơ bản của công việc tìm kiếm,
nhưng cũng cho thấy một cách dùng nguy hiểm của lệnh {\tt if}.
Hãy nhớ rằng các giá trị dấu phẩy động thường chỉ gần đúng. 
Điều đó có nghĩa là nếu bạn tìm kiếm dựa trên sự bằng nhau tuyệt
đối, có thể bạn sẽ không tìm ra. Chẳng hạn, hãy thử đoạn lệnh sau:

\begin{verbatim}
X = linspace(1,2)
for i=1:length(X)
    Y(i) = sin(X(i))
end
plot(X, Y)
\end{verbatim}
%
Bạn có thể thấy rằng trên đồ thị, giá trị của $\sin x$ đi qua
0.9 trong khoảng này, nhưng nếu tìm một chỉ số sao cho
{\tt Y(i) == 0.9}, bạn sẽ trắng tay.

\begin{verbatim}
for i=1:length(Y)
    if Y(i) == 0.9
        ans = i
        break
    end
end
\end{verbatim}
%
Điều kiện này không bao giờ đúng, vì thế phần thân của lệnh {\tt if} 
không bao giờ được thực hiện.

Ngay cả khi đồ thị biểu diễn một đường liên tục, bạn đừng quên rằng
cả {\tt X} và {\tt Y} đều là các chuỗi rời rạc, và thường chỉ là 
giá trị xấp xỉ. Như một quy tắc, bạn nên tránh việc dùng toán tử 
{\tt ==} để so sánh hai giá trị số có dấu phẩy động. Có một số cách
khắc phục điều này mà ta sẽ trở lại sau.

\begin{ex}
Hãy viết một vòng lặp để tìm chỉ số của số nguyên đầu tiên xuất hiện
trong một véc-tơ và lưu nó vào trong {\tt ans}.  Nếu không có
giá trị số âm nào, bạn nên luôn đặt {\tt ans} bằng $-1$ (vốn
không phải là một chỉ số hợp lệ) vì đó là cách biểu thị một trường
hợp bất thường.
\end{ex}



\section{Sự thật có thể gây mất hứng}

Những người lập trình Octave có kinh nghiệm sẽ không bao giờ viết
những vòng lặp như trong chương này, vì Octave cung cấp những cách
làm đơn giản và nhanh hơn cho việc rút gọn, áp dụng và tìm kiếm.

Chẳng hạn, hàm {\tt sum} có thể dùng để tính tổng của các phần tử
trong véc-tơ và {\tt prod} để tính tích.

Nhiều thao tác áp dụng có thể được thực hiện bằng các toán tử đối
với từng phần tử. Câu lệnh sau đây gọn hơn là vòng lặp ở 
Mục~\ref{apply}

\begin{verbatim}
Y = X .^ 2
\end{verbatim}
%
Ngoài ra, đa số các hàm Octave lập sẵn đều tính được với véc-tơ:

\begin{verbatim}
X = linspace(0, 2*pi)
Y = sin(X)
plot(X, Y)
\end{verbatim}

Sau cùng, hàm {\tt find} có thể đảm nhiệm thao tác tìm kiếm, nhưng
để hiểu được nó ta cần biết một số khái niệm khác nữa, vì vậy tạm
thời bạn cần bằng lòng với cách làm của mình.

Tôi bắt đầu bằng việc đề cập các vòng lặp đơn giản vì muốn cho thấy
những khái niệm cơ bản và tạo điều kiện cho bạn thực hành. Đến lúc
nào đó bạn có thể phải viết một vòng lặp mà Octave không có sẵn
một cách làm tắt, mà bạn phải tự lập nên.

Nếu bạn hiểu được các vòng lặp và thấy thoải mái với cách làm tắt
thì hãy dùng chúng! Cò nếu không bạn luôn có thể viết hẳn vòng lặp
ra.

\begin{ex}
Hãy viết một biểu thức để tính tổng của các bình phương từng phần tử
trong một véc-tơ.
\end{ex}


\section{Thuật ngữ}

\begin{description}

\item[lệnh phức hợp:] Một lệnh như {\tt if} và {\tt for}, trong đó
chứa các câu lệnh khác ở phần thân được viết thụt đầu dòng.

\item[lồng ghép:] Đặt một lệnh phức hợp vào trong phần thân của một
lệnh phức hợp khác.

\item[toán tử quan hệ:] Toán tử để so sánh hia giá trị và trả lại
kết quả là một giá trị logic.

\item[giá trị logic:] Giá trị biểu thị cho ``đúng'' hoặc
``sai''.  Octave dùng các giá trị tương ứng là 1 và 0.

\item[cờ:] Biến bao gồm một giá trị logic, thường được dùng để lưu trữ
trạng thái của một điều kiện nào đó.

\item[vô hướng:] Một giá trị đơn lẻ.

\item[véc-tơ:] Dãy các giá trị.

\item[ma trận:] Tập hợp các giá trị xếp theo hai chiều (cũng gọi là
``array'' (mảng) trong một số tài liệu về Octave).

\item[chỉ số:] Số nguyên dùng để chỉ thị một trong các giá trị trong
một véc-tơ hay ma trận (cũng gọi là ``subscript'' (chỉ số dưới) trong
một số tài liệu về Octave).

\item[phần tử:] Một trong các giá trị của véc-tơ hay ma trận.

\item[theo phần tử:] Phép tính thực hiện trên từng phần tử của một
véc-tơ hay ma trận (khác với các phép toán trong môn đại số tuyến tính).

\item[rút gọn:] Cách xử lý các phần tử của một véc-tơ để trả về một
giá trị đơn lẻ, như tổng các phần tử.

\item[áp dụng:] Cách xử lý một véc-tơ bằng việc thực hiện phép
toán đối với mỗi phần tử, để cho ra một véc-tơ chứa các kết quả.

\item[tìm kiếm:] Cách xử lý một véc-tơ bằng việc kiểm tra từng phần tử
một theo thứ tự đến khi tìm thấy một phần tử thỏa mãn điều kiện mong muốn.

\end{description}

\section{Bài tập}

\begin{ex}
\label{fibratio}

Tỉ số giữa hai số Fibonacci liên tiếp, $F_{n+1}/F_{n}$, sẽ hội tụ về
một hằng số khi $n$ tăng lên. Hãy viết một chương trình tính ra một
véc-tơ gồm $n$ phần tử đầu tiên của dãy Fibonacci sequence (giả thiết
rằng biến {\tt n} đã được định nghĩa), rồi tính một véc-tơ mới chứa
các tỉ số của cac số Fibonacci liên tiếp. Hãy vẽ đồ thị véc-tơ này 
xem nó có xu hướng hội tụ không. Nếu có thì nó hội tụ về giá trị nào?

% fibonacci4.m
\end{ex}

\begin{ex}
Có một hệ phương trình vi phân nổi tiếng được xấp xỉ bởi hệ phương trình
như sau:
%
\begin{eqnarray}
x_{i+1} &=& x_i + \sigma \left( y_i - x_i \right) dt  \\
y_{i+1} &=& y_i + \left[ x_i (r - z_i) - y_i \right] dt   \\
z_{i+1} &=& z_i + \left( x_i y_i - b z_i \right) dt
\end{eqnarray}
%
\begin{itemize}

\item Hãy viết một chương trình tính 10 phần tử đầu tiên của các dãy
$X$, $Y$ và $Z$ lưu chúng vào các véc-tơ có tên {\tt X}, {\tt Y}
và {\tt Z}.

Hãy dùng các giá trị khởi đầu $X_1 = 1$, $Y_1 = 2$ và $Z_1 = 3$, cùng
$\sigma = 10$, $b = 8/3$ và $r = 28$, bước thời gian $dt = 0.01$.

\item Hãy đọc các giải thích cách dùng {\tt plot3} và {\tt comet3} rồi
vẽ kết quả trong không gian 3 chiều.

\item Một khi mã lệnh đã chạy được, hãy dùng các dấu chấm phẩy để
ngăn các kết quả in ra rồi sau đó chạy chương trình với các dãy
có độ dài lần lượt là 100, 1000 và 10000.

\item Chạy lại chương trình với các điều kiện khởi đầu khác nhau.
Điều này có ảnh hưởng gì đến kết quả?

\item Hãy chạy chương trình với các giá trị khác nhau của $\sigma$, 
$b$ và $r$ rồi xem liệu bạn có thể hiểu được từng biến có ảnh hưởng
gì đến hệ.

\end{itemize}

\end{ex}


\begin{ex}

Phép khớp logistic thường được đem ra làm ví dụ cho việc một biểu hiện
phức tạp, hỗn loạn có thể nảy sinh từ các phương trình động lực đơn giản
[một số nội dung trong bài này được lấy từ trang Wikipedia]. Nó 
trở nên phổ biến từ khi xuất hiện bài báo năm 1976 của nhà sinh vật học
Robert May.

Phép khớp logistic được dùng để mô phỏng sinh khối của một loài khi
có mặt các yếu tố hạn chế như nguồn thức ăn và dịch bệnh. Trong 
trường hợp này, có hai yếu tố cần xét đến:
(1) Quá trình sinh sản làm tăng sinh khối của các loài tỉ lệ với
số cá thể hiện tại.
(2) Quá trình chết đói khiến cho sinh khối giảm với tốc độ tỉ lệ
với hiệu số giữa sức mang của môi trường với số cá thể hiện tại.

Điều này có thể viết bằng biểu thức sau

\[ X_{i+1} = r X_i (1-X_i) \]

trong đó $X_i$ là một số giữa 0 và 1 để biểu thị sinh khối vào năm
thứ $i$, còn $r$ là một số dương biểu thị tốc độ tổng hợp của sinh sản
và chết đói.

\begin{itemize}

\item Hãy viết một tập tin lệnh có tên {\tt logmap} để tính 50
phần tử đầu tiên của $X$ với {\tt r=3.9} và {\tt X1=0.5}, trong đó
{\tt r} là tham số của phép khớp logistic còn {\tt X1} là số cá
thể ban đầu.

\item Hãy vẽ đồ thị kết quả với một khoảng các giá trị của $r$ từ 
2.4 đến 4.0. Biểu hiện của hệ thống sẽ thay đổi ra sao khi bạn
thay đổi ra sao khi bạn thay đổi $r$?

\item Một cách đặc trưng cho ảnh hưởng của $r$ là vẽ một đồ thị với
$r$ là tọa độ $x$ và sinh khối là tọa độ $y$, để cho thấy ứng với
mỗi giá trị của $r$, giá trị sinh khối ở trạng thái ổn định là bao
nhiêu. Thử xem bạn có hình dung được cách vẽ biểu đồ này không?

\end{itemize}

\end{ex}


% chap05
\chapter{Hàm}

\section{Sự xung đột về tên}

Hãy nhớ rằng tất cả các tập tin lệnh bạn viết đều chạy trong cùng
một không gian làm việc, vì vậy nếu một chương trình làm thay đổi 
giá trị một biến thì tất cả các chương trình khác đều thấy được
sự thay đổi đó. Với một ít các chương trình đơn giản, điều này
không đáng kể, nhưng rồi sau này những tương tác giữa các chương
trình trở nên không thể quản lý được.

Chẳng hạn, chương trình sau tính tổng của {\tt n} số đầu tiên
trong một dãy hình học, nhưng cũng có {\bf hiệu ứng phụ} là 
gán các giá trị cho {\tt A1}, {\tt total}, {\tt i} và {\tt a}.

\begin{verbatim}
A1 = 1;
total = 0;
for i=1:10
    a = A1 * 0.5^(i-1);
    total = total + a;
end
ans = total
\end{verbatim}
%
Nếu bạn dùng bất cứ tến biến nào nêu trên trước khi gọi mã lệnh này
thì bạn có thể sẽ ngạc nhiên khi thấy rằng sau khi chạy đoạn 
chương trình, các giá trị đó đã thay đổi. Nếu bạn có 2 đoạn chương
trình dùng cùng tên biến, bạn có thể thấy rằng chúng hoạt động
riêng biệt nhưng đổ vỡ khi bạn cố gắng kết hợp các chương trình lại.
Kiểu tương tác này được gọi là {\bf xung đột về tên}.

Khi số tập tin lệnh của bạn viết tăng lên, đồng thời cũng dài hơn
và phức tạp hơn thì sự xung đột về tên càng nghiêm trọng. Để tránh
được vấn đề này, cần tạo ra các hàm.


\section{Hàm}
\label{functions}

Một {\bf hàm} cũng giống như một tập tin lệnh, chỉ khác ở chỗ

\begin{itemize}

\item Mỗi hàm có không gian làm việc riêng của nó, vì vậy bất kì
biến nào được định nghĩa trong hàm đều chỉ tồn tại khi hàm đang
chạy, và không ảnh hưởng đến các biến trong không gian làm việc khác,
ngay cả khi các biến đó có cùng tên.

\item Các dữ liệu đầu vào và kết quả đầu ra của hàm đều được định
nghĩa một cách cẩn thận để tránh sự tương tác không mong muốn.

\end{itemize}

Để định nghĩa một hàm, bạn cần tạo ra một tập tin M với tên gọi
mong muốn, và đặt một lời định nghĩa hàm vào trong đó. Chẳng hạn, để
tạo ra một hàm có tên {\tt myfunc}, hãy tạo ra tập tin M là {\tt myfunc.m}
và đặt vào đó định nghĩa hàm sau.

\begin{verbatim}
function res = myfunc(x)
    s = sin(x)
    c = cos(x)
    res = abs(s) + abs(c)
end
\end{verbatim}
%
Từ đầu tiên của tập tin phải là {\tt function}, vì đó là dấu hiệu đẻ
Octave nhận biết một tập tin hàm thay vì tập tin lệnh.

Một định nghĩa hàm chính là một câu lệnh phức hợp. Dòng đầu tiên là
{\bf dấu} của hàm; nó chỉ định các số liệu đầu vào và đầu ra của hàm. 
Trong trường hợp này {\bf biến đầu vào} có tên là {\tt x}. Khi hàm này
được gọi, đối số do người dùng cung cấp sẽ được gán cho {\tt x}.

{\bf Biến đầu ra} được gọi là {\tt res}, chữ viết tắt của ``result''
(kết quả). Bạn có thể gọi biến đầu ra bằng tên gì cũng được, nhưng
theo thông lệ, tôi thường đặt nó là {\tt res}.  Thường thì việc cuối
cùng mà một hàm thực hiện là gán một giá trị cho biến đầu ra.

Một khi bạn đã định nghĩa một hàm mới, bạn có thể gọi nó theo cách
giống như gọi các hàm có sẵn trong Octave. Nếu bạn gọi hàm như một
câu lệnh, Octave sẽ đặt kết quả vào {\tt ans}:

\begin{verbatim}
>> myfunc(1)

s = 0.84147098480790

c = 0.54030230586814

res = 1.38177329067604

ans = 1.38177329067604
\end{verbatim}
%
Nhưng thường thấy hơn (đồng thời là cách tốt hơn) là nên gán 
kết quả cho một biến:

\begin{verbatim}
>> y = myfunc(1)

s = 0.84147098480790

c = 0.54030230586814

res = 1.38177329067604

y = 1.38177329067604
\end{verbatim}
%
Khi bạn gỡ lỗi một hàm mới, có thể bạn sẽ phải hiển thị các
giá trị trung gian như thế này, nhưng một khi hàm đã chạy tốt, bạn
sẽ phải thêm vào các dấu chấm phẩy để khiến nó trở thành một 
{\bf hàm lặng}. Đa số các hàm có sẵn trong Octave đều là hàm lặng,
chúng tính ra kết quả, nhưng không hiển thị gì (ngoại trừ những
thông báo trong một số trường hợp).

Mỗi hàm có một không gian làm việc riêng của nó, vốn được tạo ra khi
hàm bắt đầu chạy và bị xóa đi khi hàm kết thúc. Nếu bạn thử 
truy cập (đọc hay ghi) biến được định nghĩa bên trong hàm, bạn sẽ
thấy nó không tồn tại.

\begin{verbatim}
>> clear
>> y = myfunc(1);
>> who
Variables in the current scope:
y  
>> s
error: `s' undefined near line 13 column 1
\end{verbatim}
%
Giá trị duy nhất của hàm mà bạn có thể truy cập được là kết quả của
nó, ở đây là giá trị gán cho biến {\tt y}.

Nếu bạn có các biến tên là {\tt s} hoặc {\tt c} trong không gian
làm việc trước khi gọi {\tt myfunc}, chúng sẽ vẫn ở đó ngay cả khi
hàm kết thúc.

\begin{verbatim}
>> s = 1;
>> c = 1;
>> y = myfunc(1);
>> s, c
s = 1
c = 1
\end{verbatim}
%
Như vậy ở trong hàm bạn có thể dùng bất kì tên biến nào bạn muốn
mà không sợ xung đột.


\section{Thông tin về hàm}

Tại chỗ bắt đầu của mỗi tập tin hàm, bạn nên ghi một lời chú thích
nhằm giải thích tác dụng của hàm được viết ra.

\begin{verbatim}
% res = myfunc (x)
% Compute the Manhattan distance from the origin to the
% point on the unit circle with angle (x) in radians.

function res = myfunc (x)
    s = sin(x);
    c = cos(x);
    res = abs(s) + abs(c);
end
\end{verbatim}
%
khi bạn yêu cầu trợ giúp bằng {\tt help}, Octave sẽ in ra
lời chú thích mà bạn đã ghi.

\begin{verbatim}
>> help myfunc
  res = myfunc (x)
  Compute the Manhattan distance from the origin to the
  point on the unit circle with angle (x) in radians.
\end{verbatim}

Có nhiều điều quy định về việc viết các lời chú thích này. 
Một số chi tiết nên đưa vào bao gồm:

\begin{itemize}

\item Dấu của hàm, bao gồm tên hàm, (các) biến đầu vào, và
(các) biến đầu ra.

\item Một lời mô tả rõ ràng, ngắn gọn về công dụng của hàm. 
Lời mô tả phải {\bf khái quát}: nên bỏ qua những chi tiết về
{\em cách} hoạt động của hàm, mà chỉ bao gồm những thông tin 
mà người dùng hàm muốn biết. Bạn có thể thêm vào các chú thích
bên trong hàm để lý giải những chi tiết.

\item Một lời giải thích ý nghĩa các biến đầu vào; chẳng hạn,
trong trường hợp này cần lưu ý rằng {\tt x} được coi là số đo góc
tính theo ra-đian.

\item Các điều kiện trước và điều kiện sau.

\end{itemize}



\section{Tên hàm}

Có ba điều rất phải lưu ý khi bạn mới đặt tên hàm. Thứ nhất là tên 
``thực sự'' của hàm được quyết định bởi tên tập tin chứ {\em không}
phải tên mà bạn ghi ở dấu của hàm. Theo phong cách, bạn nên
chắc rằng hai cái tên này phải luôn giống nhau, nhưng nếu bạn
lầm, hoặc đã đổi tên của hàm, thì rất dễ bị rối.

Theo tinh thần cố ý gây lỗi, hãy thử đổi tên hàm từ
{\tt myfunc} sang \verb#something_else#, và chạy lại hàm đó.

Đây là những gì bạn đưa vào trong {\tt myfunc.m}:

\begin{verbatim}
function res = something_else (x)
    s = sin(x);
    c = cos(x);
    res = abs(s) + abs(c);
end
\end{verbatim}
%
Và đây là những gì bạn nhận được:

\begin{verbatim}
>> y = myfunc(1);
>> y = something_else(1);
error: `something_else' undefined near line 12 column 5
\end{verbatim}

Điều thứ hai là tên của tập tin không được phép chứa dấu cách.
Chẳng hạn, nếu bạn viết một hàm và đặt tên tập tin là {\tt my func.m},
thì mặc dù trình soạn thảo Octave vẫn đồng ý, nhưng khi thử chạy,
bạn sẽ nhận được:

\begin{verbatim}
>> y = my func(1)
parse error:

  syntax error

>>> y = my func(1)
              ^
\end{verbatim}

Điều thứ ba là tên hàm được viết có thể xung đột với các hàm lập sẵn
của Octave. Chẳng hạn, nếu bạn tạo ra tập tin M có tên {\tt sum.m}, 
rồi gọi {\tt sum}, Octave có thể sẽ gọi hàm mới do {\em bạn} viết,
chứ không phải hàm lập sẵn! Hàm nào được gọi sẽ tùy thuộc vào thứ tự
của các thư mục xếp trong đường dẫn tìm kiếm, và (trong một số
trường hợp) phụ thuộc vào đối số. Chẳng hạn, hãy đặt các lệnh sau
vào tập tin có tên {\tt sum.m}:

\begin{verbatim}
function res = sum(x)
   res = 7;
end
\end{verbatim}

Rồi thử gõ:

\begin{verbatim}
>> sum(1:3)
ans = 6

>> sum
ans = 7
\end{verbatim}
%
Trong trường hợp đầu Octave đã dùng hàm lập sẵn; ở trường hợp 
thứ hai nó thực hiện hàm bạn viết! Kiểu tương tác này có thể 
rất gây lẫn. Trước khi tạo ra hàm mới, bạn cần kiểm tra xem
có sẵn hàm nào của Octave có cùng tên không. Nếu có, hãy đặt
một tên khác!


\section{Nhiều biến đầu vào}
\label{hypotenuse}

Các hàm có thể, và thường, nhận nhiều biến đầu vào. Chẳng hạn,
hàm sau đây nhận hai biến đầu vào, {\tt a} và {\tt b}:

\begin{verbatim}
function res = hypotenuse(a, b)
    res = sqrt(a^2 + b^2);
end
\end{verbatim}
%
Nếu bạn còn nhớ Định lý Py-ta-go, bạn có thể đã hình dung ra là
hàm này để tính chiều dài cạnh huyền của tam giác vuông nếu các
cạnh góc vuông là {\tt a} và {\tt b}.  (Có một hàm Octave tên là 
{\tt hypot} thực hiện điều tương tự.)

Nếu ta gọi hàm này từ cửa sổ dòng lệnh với các đối số 3 và 4, ta có thể
chắc rằng chiều dài cạnh thứ ba sẽ bằng 5.

\begin{verbatim}
>> c = hypotenuse(3, 4)
c = 5
\end{verbatim}
Các đối số mà bạn cấp vào đây được gán cho các biến đầu vào theo
đúng thứ tự, vì vậy ở trường hợp này 3 được gán cho {\tt a} còn 4 
được gán cho {\tt b}.  Octave kiểm tra để đảm bảo rằng bạn cung
cấp đủ đối số; nếu cung cấp thiếu, bạn sẽ nhận được:

\begin{verbatim}
>> c = hypotenuse(3)
error: `b' undefined near line 2 column 22
error: evaluating argument list element number 1
error: called from:
error:   hypotenuse at line 2, column 9
\end{verbatim}
%
Thông báo lỗi này nói rằng giá trị \texttt{b} trong biểu thức tính 
\texttt{res} đã không được xác định. Vì vậy bạn phải xem lại 
lời gọi hàm. 

Nếu cung cấp thừa đối số:

\begin{verbatim}
>> c = hypotenuse(3, 4, 5)
ans = 5
\end{verbatim}
%
Hãy cẩn thận! Octave không bắt lỗi kiểu này và do đó bạn có thể tính sai
bằng cách cung cấp nhiều đối số hơn mức cần thiết. Hãy luôn kiểm tra lại
hướng dẫn cách dùng hàm trước khi gọi.


\section{Các hàm logic}

Ở Mục~\ref{logop} ta đã dùng các toán tử logic để so sánh các 
giá trị. Octave cũng cung cấp các {\bf hàm logic} để kiểm tra những
điều kiện nhất định và trả lại những giá trị logic: 1 với nghĩa là 
``đúng'' và 0 với nghĩa là ``sai''.

Chẳng hạn, {\tt isprime} dùng để kiểm tra xem số đã cho có
phải là số nguyên tố hay không.

\begin{verbatim}
>> isprime(17)
ans = 1

>> isprime(21)
ans = 0
\end{verbatim}
%
Các hàm {\tt isscalar} và {\tt isvector} là để kiểm tra xem một
giá trị là số vô hướng hay véc-tơ; nếu cả hai đều sai, bạn có thể
tạm coi đối số là một ma trận.

Để kiểm tra xem một giá trị bạn đã tính có phải là số nguyên không,
bạn có thể muốn dùng {\tt isinteger}.  Nhưng cách làm này sai.
{\tt isinteger} kiểm tra xem giá trị có thuộc về một trong bốn kiểu
số nguyên (một chủ đề mà ta chưa bàn luận đến), chứ nó không kiểm
tra xem một số có dấu phẩy động tình cờ nhận giá trị nguyên hay không.

\begin{verbatim}
>> c = hypotenuse(3, 4)
c = 5

>> isinteger(c)
ans = 0
\end{verbatim}
%
Để làm điều này, ta cần tự viết một hàm logic, và sẽ gọi nó
là {\tt isintegral}:

\begin{verbatim}
function res = isintegral(x)
    if round(x) == x
        res = 1;
    else
        res = 0;
    end
end
\end{verbatim}
%
Hàm này dùng được trong phần lớn các trường hợp, nhưng nhớ rằng
các giá trị dấu phẩy động chỉ xấp xỉ đúng, trong một số trường hợp
giá trị xấp xỉ là số nguyên nhưng giá trị thực lại không phải.


\section{Một ví dụ phát triển tăng dần}
\label{increxample}

Giả dụ rẳng ta muốn viết một chương trình tìm các ``bộ ba số
Py-ta-go'': những tập hợp số nguyên như 3, 4, và 5, là độ dài
các cạnh của một tam giác vuông. Nói cách khác, ta muốn tìm các
giá trị nguyên $a$, $b$ và $c$ sao cho $a^2 + b^2 = c^2$.

Sau đây là các bước mà ta sẽ làm theo để phát triển chương trình
một cách tăng dần.

\begin{itemize}

\item Viết một tập tin lệnh có tên \verb#find_triples# và bắt đầu
với một câu lệnh đơn giản như {\tt x=5}.

\item Viết một vòng lặp để liệt kê các giá trị $a$ từ 1 đến 3, và
hiển thị chúng.

\item Viết một vòng lặp lồng ghép để liệt kê các giá trị $b$ từ 1 đến 4,
và hiển thị chúng.

\item Bên trong vòng lặp, gọi {\tt hypotenuse} để tính $c$ và
hiển thị nó.

\item Dùng {\tt isintegral} để kiểm tra xem $c$ có bằng một số nguyên
hay không.

\item Dùng một lệnh if để chỉ in ra những cặp giá trị $a$, $b$ và $c$
nào thỏa mãn điều kiện.

\item Chuyển nội dung tập tin lệnh vào trong một hàm.

\item Khái quát hóa hàm này để nhận vào các biến chỉ định khoảng các
giá trị cần được tìm kiếm.

\end{itemize}

Như vậy bản nháp đầu tiên của chương trình này là {\tt x=5}, 
trông có vẻ ngốc nghếch, nhưng nếu bạn bắt đầu một cách đơn giản và
mỗi lúc chỉ thêm vào ít một, bạn sẽ tránh được gỡ lỗi rất nhiều.

Sau đây là bản nháp thứ hai:

\begin{verbatim}
for a=1:3
    a
end
\end{verbatim}

Ở mỗi bước, chương trình đều có thể chạy thử được: nó có in ra kết quả
(hay một hiệu ứng thấy được) mà ta có thể kiểm tra.


\section{Vòng lặp lồng ghép}

Bản nháp thứ ba chứa một vòng lặp lồng ghép:

\begin{verbatim}
for a=1:3
    a
    for b=1:4
        b
    end
end
\end{verbatim}

Vòng lặp trong được thực hiện 3 lần, mỗi lần với một giá trị 
khác nhau của {\tt a}, vì vậy sau đây là kết quả (tôi đã chỉnh
lại độ dãn cách để làm nổi bật cấu trúc):

\begin{verbatim}
>> find_triples

a = 1   b = 1
        b = 2
        b = 3
        b = 4

a = 2   b = 1
        b = 2
        b = 3
        b = 4

a = 3   b = 1
        b = 2
        b = 3
        b = 4
\end{verbatim}
%
Bước tiếp theo là tính $c$ với mỗi cặp giá trị của $a$ và $b$.

\begin{verbatim}
for a=1:3
    for b=1:4
        c = hypotenuse(a, b);
        [a, b, c]
    end
end
\end{verbatim}
%
Để hiển thị các giá trị của {\tt a}, {\tt b} và {\tt c}, tôi
dùng đến một đặc điểm của Octave mà ta chưa gặp. Toán tử
ngoặc vuông tạo ra một ma trận mới mà, khi được hiển thị, sẽ
cho thấy các giá trị trên cùng một dòng:

\begin{verbatim}
>> find_triples

ans = 1.0000    1.0000    1.4142
ans = 1.0000    2.0000    2.2361
ans = 1.0000    3.0000    3.1623
ans = 1.0000    4.0000    4.1231
ans = 2.0000    1.0000    2.2361
ans = 2.0000    2.0000    2.8284
ans = 2.0000    3.0000    3.6056
ans = 2.0000    4.0000    4.4721
ans = 3.0000    1.0000    3.1623
ans = 3.0000    2.0000    3.6056
ans = 3.0000    3.0000    4.2426
ans = 3         4         5
\end{verbatim}
%
Bạn đọc tinh mắt sẽ phát hiện được rằng chúng ta đang lãng phí một
ít công sức lập trình. Sau khi kiểm tra $a=1$ và $b=2$, sẽ chẳng cần
kiểm tra $a=2$ và $b=1$. Ta có thể loại bỏ công việc thừa
này bằng cách chỉnh lại khoảng lặp của vòng thứ hai:

\begin{verbatim}
for a=1:3
    for b=a:4
        c = hypotenuse(a, b);
        [a, b, c]
    end
end
\end{verbatim}
%
Nếu bạn vẫn theo kịp nội dung, hãy chạy phiên bản mã lệnh này và
chắc chắn rằng nó cho kết quả như mong muốn.


\section{Điều kiện và cờ}

Bước tiếp theo là kiểm tra xem giá trị $c$ có nguyên không. Vòng lặp
này gọi {\tt isintegral} và in ra giá trị logic thu được.

\begin{verbatim}
for a=1:3
    for b=a:4
        c = hypotenuse(a, b);
        flag = isintegral(c);
        [c, flag]
    end
end
\end{verbatim}
%
Bằng cách không hiển thị {\tt a} và {\tt b} tôi làm cho việc soát
kết quả dễ dàng hơn để đảm bảo rằng các giá trị của {\tt c} và 
{\tt flag} trông đúng đắn.

\begin{verbatim}
>> find_triples

ans = 1.4142         0
ans = 2.2361         0
ans = 3.1623         0
ans = 4.1231         0
ans = 2.8284         0
ans = 3.6056         0
ans = 4.4721         0
ans = 4.2426         0
ans = 5              1
\end{verbatim}
%
Tôi chọn các khoảng {\tt a} và {\tt b} đều nhỏ (vì vậy số dòng
kết quả đầu ra có thể kiểm soát được), nhưng phải bao gồm
ít nhất là một bộ ba số Py-ta-go. Một khó khăn thường gặp khi
gỡ lỗi là phải phát sinh đủ kết quả để cho thấy rằng mã lệnh
có (hoặc không) hoạt động mà không quá thừa thãi.

Bước tiếp theo là dùng {\tt flag} để chỉ hiển thị những bộ ba
thỏa mãn yêu cầu:

\begin{verbatim}
for a=1:3
    for b=a:4
        c = hypotenuse(a, b);
        flag = isintegral(c);
        if flag
            [a, b, c]
        end
    end
end
\end{verbatim}
%
Bây giờ kết quả đẹp và đơn giản hơn:

\begin{verbatim}
>> find_triples

ans = 3     4     5
\end{verbatim}



\section{Bao bọc và khái quát hóa}

Dưới dạng tập tin lệnh, chương trình này có tác dụng phụ là đã gán các
giá trị cho {\tt a}, {\tt b}, {\tt c} và {\tt flag}, vốn sẽ làm 
chương trình khó dùng hơn khi các tên biến trên đang được sử dụng.
Bằng cách bọc mã lệnh này vào trong một hàm, ta có thể tránh được sự
xung đột về tên; quá trình này được gọi là {\bf bao bọc} vì nó 
cô lập chương trình khỏi không gian làm việc.

Để đưa mã lệnh đã viết vào trong một hàm, ta phải viết thụt đầu dòng 
toàn bộ. Trong trình soạn thảo SciTE, ta chỉ cần chọn (bôi đen) đoạn mã lệnh
rồi ấn phím Tab. (Shift+Tab để giảm độ thụt đầu dòng.)
% Just don't forget to unselect the
% text before you start typing!

Bản nháp đầu tiên của hàm trong đó không có biến đầu vào như sau:

\begin{verbatim}
function res = find_triples ()
    for a=1:3
        for b=a:4
            c = hypotenuse(a, b);
            flag = isintegral(c);
            if flag
                [a, b, c]
            end
        end
    end
end
\end{verbatim}
%
Cặp ngoặc tròn trong đó không có gì ở dấu của hàm là không cần thiết,
nhưng chúng làm rõ là không có biến đầu vào nào. Tương tự, khi tôi gọi
một hàm mới, tôi cũng ưa dùng cặp ngoặc để tự nhủ rằng đó là một hàm
chứ không phải nội dung tập tin lệnh:

\begin{verbatim}
>> find_triples()
\end{verbatim}
%
Biến đầu ra cũng không nhất thiết phải có; nó không bao giờ được gán
một giá trị. Nhưng tôi vẫn đặt nó ở đây như một thói quen, cũng là
nhờ vậy mà các dấu hàm của tôi tất cả đều có chung một dạng.

Bước tiếp theo là khái quát hóa hàm này bằng cách thêm các biến
đầu vào. Cách khái quát khá tự nhiên là thay thế các hằng số
3 và 4 bằng một biến để ta có thể tìm kiếm trên một khoảng lớn
tùy ý.

\begin{verbatim}
function res = find_triples (n)
    for a=1:n
        for b=a:n
            c = hypotenuse(a, b);
            flag = isintegral(c);
            if flag
                [a, b, c]
            end
        end
    end
end
\end{verbatim}
%
Sau đây là các kết quả thu được trong khoảng từ 1 đến 15:

\begin{verbatim}
>> find_triples(15)

ans = 3     4     5
ans = 5    12    13
ans = 6     8    10
ans = 8    15    17
ans = 9    12    15
\end{verbatim}
%
Trong các kết quả này có cái hay, có cái không. Các cặp 
$5,12,13$ và $8,15,17$ thật sự ``mới,'' còn các cặp khác
chỉ là các bội số của cặp $3,4,5$ mà ta đã biết.


\section{Một sai sót}

Khi bạn thay đổi dấu của hàm, bạn cũng phải thay đổi tất cả
mọi chỗ gọi đến hàm đó. Chẳng hạn, nếu tôi định thêm
một biến thứ ba vào {\tt hypotenuse}:

\begin{verbatim}
function res = hypotenuse(a, b, d)
    res = (a.^d + b.^d) ^ (1/d);
end
\end{verbatim}
%
Khi {\tt d} bằng 2, hàm này có tác dụng giống như cũ. Hiện
không có lý do nào phù hợp để khái quát hàm này theo cách trên;
đây chỉ là ví dụ. Bây giờ khi bạn chạy \verb find_triples , 
bạn sẽ nhận được:

\begin{verbatim}
>> find_triples(20)
error: `d' undefined near line 2 column 15
error: called from:
error:   C:\Users\tencuaban\matlab\hypotenuse.m at line 2, column 9
error:   C:\Users\tencuaban\matlab\find_triples.m at line 4, column 15
\end{verbatim}
% is it easy or hard to find the error? 
Như vậy thật khó tìm ra lỗi. Đây là một ví dụ cho kĩ thuật phát triển
mà đôi khi có ích: thay vì tìm kiếm mọi chỗ trong chương trình
có dùng đến {\tt hypotenuse}, bạn có thể chạy chương trình và
theo các dòng thông báo để tìm ra lỗi.

Nhưng kĩ thuật này rất mạo hiểm, đặc biệt khi các thông báo lỗi
đưa ra gợi ý phải sửa đổi những gì. Nếu bạn làm theo chúng, bạn
có thể làm biến mất thông báo lỗi, nhưng điều đó không có nghĩa
là chương trình đã làm đúng điều ta muốn. Octave không biết rằng
chương trình {\em cần phải} làm gì, mà bạn phải có trách nhiệm
về điều này.

Và từ đó dẫn đến Định lý thứ tám về gỡ lỗi:

\begin{quote}
Các lời thông báo lỗi đôi khi bảo cho bạn biết điều gì trục trặc,
nhưng hiếm khi chúng bảo cho bạn cách làm (và nếu chúng cố gắng
giúp đi nữa thì cũng thường nói sai).
\end{quote}


\section{{\tt continue}}

Ở khâu cải tiến cuối cùng, ta hãy sửa hàm này sao cho nó chỉ 
hiểu thị những bộ ba số Py-ta-go ``thấp nhất'', chứ không kể tất cả
các bội số của chúng.

Cách làm đơn giản nhất để loại bỏ các bội số là kiểm tra xem 
$a$ và $b$ có thừa số chung hay không. Nếu có, thì việc chia
các số này cho thừa số chung sẽ cho ra một bộ ba số nhỏ hơn
mà ta đã kiểm tra.

Octave có một hàm {\tt gcd} để tính ước số chung nhỏ nhất
của hai số. Nếu kết quả lớn hơn 1, thì $a$ và $b$ có một 
ước số chung và ta có thể dùng lệnh {\tt continue} để
nhảy sang cặp tiếp theo:

\begin{verbatim}
function res = find_triples (n)
    for a=1:n
        for b=a:n
            if gcd(a,b) > 1
                continue
            end
            c = hypotenuse(a, b);
            if isintegral(c)
                [a, b, c]
            end
        end
    end
end
\end{verbatim}
%
{\tt continue} làm cho chương trình dừng vòng lặp hiện tại
(tức là không thực hiện phần còn lại của thân lệnh nữa), 
nhảy đến đầu vòng lặp, và ``tiếp tục'' với lượt lặp liền sau.

Trong trường hợp này, vì ta có hai vòng lặp nên sẽ không hiển
nhiên là vòng lặp nào được nhảy đến, nhưng quy tắc là nhảy đến
vòng lặp sâu bên trong nhất (đúng theo ý định của ta ở đây).

Tôi cũng làm đơn giản chương trình một chút bằng cách loại bỏ
{\tt flag} và dùng {\tt isintegral} làm điều kiện cho lệnh
{\tt if}.

Sau đây là các kết quả với {\tt n=40}:

\begin{verbatim}
>> find_triples(40)

ans =  3     4     5
ans =  5    12    13
ans =  7    24    25
ans =  8    15    17
ans =  9    40    41
ans = 12    35    37
ans = 20    21    29
\end{verbatim}
%
Có một sự liên hệ thú vị giữa các số Fibonacci và cặp số
Py-ta-go. Nếu $F$ là một dãy số Fibonacci, thì

\[ (F_n F_{n+3}, 2 F_{n+1} F_{n+2}, F_{n+1}^2 + F_{n+2}^2 ) \]
%
 là một cặp số Py-ta-go với mọi $n \ge 1$.

\begin{ex}
Hãy viết một hàm có tên \verb#fib_triple# để nhận vào một
biến {\tt n}, dùng {\tt fibonacci2} để tính
{\tt n} số Fibonacci đầu tiên, rồi kiểm tra xem công thức
nói trên có tạo thành bộ ba số Py-ta-go với mỗi số trong 
dãy không.
\end{ex}



\section{Khoa học và niềm tin}

Ta hãy xem lại một loạt các bước xảy ra khi bạn gọi một hàm:

\begin{enumerate}

\item Trước khi hàm bắt đầu chạy, Octave tạo ra một không gian
làm việc mới cho nó.

\item Octave lượng giá từng đối số và gán các giá trị tìm được
lần lượt cho từng biến đầu vào (vốn tồn tại trong không gian
làm việc {\em mới}).

\item Mã lệnh ở phần thân của hàm được thực thi. Đâu đó trong 
phần thân (thường là ở dòng cuối cùng) một giá trị sẽ được gán
cho biến đầu ra.

\item Không gian làm việc của hàm bị xóa bỏ; thứ duy nhất 
còn lại là giá trị của biến đầu ra và mọi hiệu ứng phụ của hàm
(như hiển thị các giá trị hoặc vẽ một hình).

\item Chương trình tiếp tục tại điểm mà nó tạm dừng để thực
hiện hàm. Giá trị của lời gọi hàm là giá trị của biến đầu ra.

\end{enumerate}

Khi bạn đang đọc chương trình và gặp một lời gọi hàm, có hai cách
diễn giải nó:

\begin{itemize}

\item Bạn có thể nghĩ cách khoa học như tôi đã trình bày, và theo
các bước thực hiện của chương trình, tiến vào trong hàm rồi sau đó
trở lại, hoặc

\item Bạn có dựa vào ``niềm tin'': giả sử rằng hàm hoạt động đúng,
và đọc tiếp lệnh sau lời gọi hàm đó.

\end{itemize}

Khi bạn dùng những hàm lập sẵn, cách tự nhiên là dựa vào niềm tin,
một phần là do bạn trông đợi rằng đại đa số các hàm Octave đều hoạt
động đúng, và một phần là do bạn không xem được mã lệnh bên trong
phần thân hàm.

Khi bắt đầu tự viết các hàm, bạn có thể sẽ tự thấy mình trong 
đi theo ``luồng thực hiện'' của chương trình. Điều này có thể 
giúp ích khi bạn đang học, nhưng khi đã có kinh nghiệm, bạn nên
quen với ý tưởng viết một hàm, kiểm tra để đảm bảo nó chạy đúng,
và sau đó quên đi những chi tiết về cách hoạt động của nó.

Việc quên đi các chi tiết được gọi là {\bf trừu tượng hóa};
trong ngữ cảnh này, trừu tượng hóa có nghĩa là quên đi {\em cách} 
hoạt động của một hàm, và chỉ giả sử (sau khi kiểm tra hợp lý)
rằng hàm chạy được.


\section{Thuật ngữ}

\begin{description}

\item[hiệu ứng phụ:] Hiệu ứng như thay đổi không gian làm việc,
mà không phải là mục đích của chương trình.

\item[xung đột về tên:] Hoàn cảnh trong đó hai tập tin chương trình
dùng cùng một tên biến đã can thiệp nhau.

\item[biến đầu vào:] Biến trong một hàm, được nhận giá trị 
từ một trong các đối số, khi ta gọi hàm.

\item[biến đầu ra:] Biến trong một hàm, dùng để trả một giá trị
từ hàm về chương trình gọi.

\item[dấu của hàm:] Dòng đầu tiên của một lời định nghĩa hàm,
trong đó có chỉ định tên hàm, các biến đầu vào và biến đầu ra.

\item[hàm lặng:] Hàm không làm hiển thị giá trị nào, cũng không
vẽ hình hay có bất kì hiệu ứng phụ gì.

\item[hàm logic:] Hàm trả lại một giá trị logic (1 đóng vai trò ``đúng''
và 0 đóng vai trò ``sai'').

\item[bao bọc:] Quá trình gói một phần của chương trình vào trong
một hàm nhằm hạn chế những tương tác (trong đó có xung đột về tên)
giữa hàm và phần còn lại của chương trình.

\item[khái quát hóa:] Làm cho hàm trở nên linh hoạt hơn bằng cách
thay những giá trị cụ thể bằng các biến đầu vào.

\item[trừu tượng hóa:] Sự bỏ qua những chi tiết hoạt động của một hàm
nhằm tập trung vào một mô hình đơn giản hơn: hàm làm việc gì?

\end{description}

\section{Bài tập}

\begin{ex}
Chọn bất kì tập tin lệnh nào bạn đã viết, bao bọc nó vào trong
một hàm có tên thích hợp, rồi khái quát hóa hàm này bằng cách
bổ sung một hoặc nhiều biến đầu vào.

Làm cho hàm trở nên lặng bằng cách gọi nó từ Command
Window và đảm bảo rằng bạn có thể hiển thị giá trị đầu ra.
\end{ex}



% chap06
\chapter{Tìm nghiệm}


\section{Tại sao lại cần dùng hàm?}

Chương vừa rồi đã giải thích một số ưu điểm của hàm, bao gồm

\begin{itemize}

\item Mỗi hàm có không gian làm việc riêng của nó, vì vậy dùng hàm 
sẽ tránh được xung đột về tên.

\item Các hàm rất hợp với cách phát triển tăng dần: bạn có thể gỡ lỗi
phần thân của hàm trước (dưới dạng tập tin lệnh), rồi gói nó vào
trong một hàm, sau đó khái quát hóa bằng cách thêm các biến đầu vào.

\item Hàm cho phép ta chia một vấn đề lớn thành những phần nhỏ
để xử lý từng phần một, rồi lắp ghép trở lại thành lời giải hoàn chỉnh.

\item Một khi đã có hàm chạy được, bạn có thể quên đi những chi tiết
về cách hoạt động của nó, mà chỉ cần biết nó làm gì. Quá trình trừu tượng hóa
này là một cách thức quan trọng để ta quản lý được sự phức tạp của
những chương trình lớn.

\end{itemize}

Một lý do khác khiến bạn phải cân nhắc việc dùng hàm là nhiều công cụ
quan trọng của Octave yêu cầu bạn phải viết hàm. Chẳng hạn, ở 
chương này ta sẽ dùng {\tt fzero} để tìm nghiệm của phương trình
phi tuyến. Sau đó ta sẽ dùng {\tt ode45} để tìm nghiệm xấp xỉ của
các phương trình vi phân.


\section{Ánh xạ}
\label{map}

Trong toán học, {\bf ánh xạ} là sự tương ứng giữa một tập hợp
gọi là {\bf tập nguồn} và một tập hợp khác được gọi là
{\bf tập đích}. Với mỗi phần tử của tập nguồn, phép ánh xạ sẽ
chỉ ra phần tử tương ứng của tập đích.

Bạn có thể tưởng tượng một dãy như là ánh xạ từ tập các số nguyên dương
đến tập các phần tử của dãy đó. Bạn có thể tưởng tượng véc-tơ như một
ánh xạ từ tập các chỉ số đến các phần tử. Trong các trường hợp này,
những ánh xạ là {\bf rời rạc} vì các phần tử trong tập nguồn là đếm được.

Bạn cũng có thể tưởng tượng một hàm như một ánh xạ từ số liệu đầu vào
đến số liệu đầu ra, nhưng trong trường hợp này tập nguồn là 
{\bf liên tục} vì số liệu đầu vào có thể nhận bất kì giá trị nào chứ không
riêng gì các số nguyên. (Chặt chẽ mà nói, tập hợp của các số có dấu 
phẩy động là rời rạc, nhưng vì các số dấu phẩy động nhằm biểu diễn
cho các số thực, nên ta hiểu rằng chúng liên tục.)


\section{Nói thêm về cách kí hiệu}
\label{notation}

Trong chương này, tôi bắt đầu nói về các hàm toán học, và tôi sẽ
dùng dạng kí hiệu mà có thể chưa gặp bao giờ.

Nếu bạn đã học đến hàm qua môn toán, bạn có thể thấy kí hiệu
như sau

\[ f(x) = x^2 - 2x -3 \]
%
với ý nghĩa rằng $f$ là một hàm chiếu từ
$x$ đến $x^2 - 2x -3$.  Vấn đề là $f(x)$ cũng được dùng để chỉ
giá trị của $f$ tương ứng với một giá trị của $x$. Vì vậy, tôi 
không thích các kí hiệu này. Tôi ưa dùng kí hiệu sau hơn:

\[ f : x \to x^2 - 2x -3 \]
%
với ý nghĩa rằng ``f là hàm chiếu từ
$x$ đến $x^2 - 2x -3$.''  Trong Octave, điều này được diễn đạt
bởi:

\begin{verbatim}
function res = error_func(x)
    res = x^2 - 2*x -3;
end
\end{verbatim}

Tôi sẽ sớm giải thích lý do tại sao hàm này được gọi là 
\verb error_func . Bây giờ, ta hãy quay trở lại việc lập trình.



\section{Phương trình phi tuyến}

Việc ``giải'' phương trình có nghĩa là gì? Điều này dường như quá
rõ ràng, nhưng tôi muốn chúng ta dành một phút để nghĩ về nó,
bắt đầu với một câu hỏi đơn giản: giả sử ta muốn biết giá trị của
một biến, $x$, nhưng tất cả những gì ta biết về nó chỉ là một 
hệ thức $x^2 = a$.

Nếu đã học môn đại số, chắc bạn biết cách ``giải'' phương trình
này: chỉ cần lấy căn bậc hai của hai vế và ta có $x = \sqrt{a}$. 
Sau đó, khi thoải mái vì đã giải xong, bạn chuyển sang bài toán
tiếp theo.

Nhưng thực sự bạn đã làm gì? Hệ thức mà bạn rút ra tương đương
với hệ thức ở đề bài---chúng có cùng thông tin về $x$---nhưng
tại sao hệ thức thứ hai lại được ưa chuộng hơn thứ nhất?

Có hai lý do sau. Đầu tiên là hệ thứ thứ hai đã ``tường minh
theo $x$;'' bởi vì chỉ có $x$ ở bên vế trái, ta có thể coi vế phải
như là một phương thức dễ dàng để tính $x$, với giả sử là ta
đã biết $a$.

Lý do còn lại là phương thức tính toán này được viết dưới dạng các
phép toán mà ta biết cách thực hiện. Giả sử rằng ta biết cách tính
căn bậc hai, ta có thể tính được giá trị của $x$ với giá trị $a$ bất kì.

Khi ta nói về giải phương trình, ý nghĩa thông thường của nó là 
kiểu như ``đi tìm một hệ thức tương đương trong đó một ẩn được
viết dưới dạng tường minh.'' Trong phạm vi cuốn sách này, một
hệ thức như vậy được tôi gọi là {\bf nghiệm giải tích}, để phân biệt
với {\bf nghiệm số trị}, là thứ mà ta cần tìm trong phần tiếp theo đây.

Để ví dụ cho việc tìm nghiệm số trị, ta hãy xét phương trình $x^2 - 2x = 3$. 
Bạn có thể giải phương trình này theo cách giải tích, bằng phép
phân tích thừa số hay dùng công thức giải phương trình bậc hai, để
tìm được hai nghiệm của nó, $x=3$ và $x=-1$. Một cách khác là bạn
có thể giải phương trình bằng cách viết $x = \sqrt{2x+3}$.

Phương trình này không tường minh, vì $x$ xuất hiện ở cả 2 vế, 
vì vậy chưa rõ là bước biến đổi này có ích gì. Nhưng giả như là
vì lý do nào đó ta biết có một nghiệm gần với 4, ta có thể 
lấy $x=4$ làm ``ước đoán ban đầu,'' rồi dùng phương trình
$x = \sqrt{2x+3}$ lặp lại nhiều lần để tính những liên tiếp những
giá trị xấp xỉ của nghiệm.

Sau đây là điều có thể xảy ra:

\begin{verbatim}
>> x = 4;

>> x = sqrt(2*x+3)
x = 3.3166

>> x = sqrt(2*x+3)
x = 3.1037

>> x = sqrt(2*x+3)
x = 3.0344

>> x = sqrt(2*x+3)
x = 3.0114

>> x = sqrt(2*x+3)
x = 3.0038
\end{verbatim}
%
Sau mỗi lượt lặp, {\tt x} đã gần hơn đáp số đúng,
và sau 5 lần lặp, sai số tương đối chỉ còn khoảng 0.1\%, vốn
đã đạt yêu cầu cho mọi mục đích tính toán.

Các kĩ thuật giúp tính ra nghiệm số trị được gọi là 
{\bf phương pháp số}. Điều hay ở phương pháp mà tôi vừa
trình bày là nó đơn giản, nhưng không phải lúc nào cũng
hoạt động được như ở ví dụ trên, và thực tế nó thường
không được dùng nhiều. Ta sẽ xem một phương pháp 
thông dụng hơn ngay sau đây.


\section{Tìm nghiệm}
\label{zero}

Một phương trình phi tuyến như $x^2 - 2x = 3$ là một 
khẳng định đẳng thức chỉ đúng với một số ít các giá trị của $x$
và sai với tất cả các giá trị khác. Một giá trị khiến cho đẳng thức
đúng được gọi là nghiệm; các giá trị khác không phải nghiệm.
Nhưng với bất kì một giá trị không phải nghiệm cho trước, cũng
chẳng có dấu hiệu gì cho thấy nó gần hay xa một nghiệm, hay
ta có thể tìm nghiệm trong khoảng nào.

Để giải quyết hạn chế này, ta cần viết lại phương trình
phi tuyến dưới dạng bài toán tìm nghiệm:

\begin{itemize}

\item Bước đầu tiên là định nghĩa một
``hàm sai số'' để tính xem một giá trị cho trước
của $x$ cách xa nghiệm là bao nhiêu.

Ở ví dụ này, hàm sai số là

\[ f : x \to x^2 - 2x -3 \]

Bất kì giá trị nào của $x$ làm cho $f(x) = 0$ chính là một
nghiệm của phương trình ban đầu.

\item Bước tiếp theo là tìm các giá trị của $x$ làm cho
$f(x) = 0$. Các giá trị này được gọi là {\bf nghiệm của phương trình}.

\end{itemize}

Việc tìm nghiệm rất hợp với cách giải số trị vì ta có thể dùng
các giá trị của $f$, được tính từ những giá trị khác nhau của $x$, 
để suy luận hợp lý về vị trí cần tìm nghiệm.

Chẳng hạn, nếu ta có thể tìm hai giá trị $x_1$ và $x_2$ sao cho
$f(x_1) > 0$ và $f(x_2) < 0$, thì ta có thể chắc rằng có ít nhất một
nghiệm nằm giữa $x_1$ và $x_2$ (miễn là $f$ liên tục). Trong trường
hợp này, ta sẽ nói rằng $x_1$ và $x_2$ bao một nghiệm.

Sau đây là một hình minh họa cho tình huống nói trên:

% \beforefig 
\centerline{\includegraphics[height=1.5in]{figs/secant.eps}}

Nếu như đó là tất cả những gì bạn biết về $f$, thì bạn sẽ tìm
nghiệm ở đâu? Nếu bạn nói ``điểm chính giữa $x_1$ và $x_2$,''
thì xin chúc mừng bạn! Bạn đã tìm ra phương pháp số có tên là
phân đôi!

Nếu bạn nói, ``tôi sẽ nối hai điểm chấm bằng một đường thẳng rồi
tính nghiệm của hàm đường thẳng này,'' thì xin chúc mừng bạn! Bạn đã
tìm ra phương pháp cát tuyến!

Còn nếu bạn nói, ``tôi sẽ tính $f$ tại một điểm thứ ba, và vẽ một
đường parabol đi qua ba điểm này, rồi tìm các nghiệm của hàm
parabol,'' thì... ồ, có lẽ bạn sẽ không nói vậy đâu.

Cuối cùng, nếu bạn nói, ``tôi sẽ dùng hàm lập sẵn của Octave trong đó
kết hợp những đặc điểm hay nhất của một số thuật toán mạnh và
hiệu quả,'' thì bạn đã sẵn sàng chuyển sang mục tiếp theo.


\section{{\tt fzero}}
\label{fzero}

{\tt fzero} là một hàm lập sẵn của Octave trong đó kết hợp các
đặc điểm tốt nhất của một vài phương pháp số mạnh và hiệu quả.

Để dùng được {\tt fzero}, bạn phải định nghĩa một hàm Octave 
để tính hàm sai số suy từ phương trình phi tuyến ban đầu, và bạn
phải cung cấp một giá trị ước đoán ban đầu về vị trí nghiệm.

Ta đã thấy một ví dụ của hàm sai số:

\begin{verbatim}
function res = error_func(x)
    res = x^2 - 2*x -3;
end
\end{verbatim}
%
Bạn có thể gọi \verb#error_func# từ dấu nhắc lệnh, và
đảm bảo rằng có các nghiệm ở 3 và $-1$.

\begin{verbatim}
>> error_func(3)
ans = 0

>> error_func(-1)
ans = 0
\end{verbatim}
%
Nhưng hãy giả vờ rằng ta không biết chắc vị trí của các nghiệm;
ta chỉ biết rằng một nghiệm ở gần 4.  Sau đó ta có thể gọi 
{\tt fzero} như sau:

\begin{verbatim}
>> fzero(@error_func, 4)
ans = 3
\end{verbatim}
%
Được rồi! Ta đã tìm thấy một trong số các nghiệm.

Đối số thứ nhất là một {\bf chuôi của hàm} vốn là tên của 
tập tin M để lượng giá hàm sai số. Kí hiệu  {\tt @} cho phép
ta nhắc đến tên hàm mà không gọi nó. Cái hay ở đây là bạn
thực sự không trực tiếp gọi \verb#error_func#; bạn chỉ
báo cho {\tt fzero} biết nó ở đâu.  Đến lượt mình, {\tt fzero}
gọi đến hàm sai số---thật ra là hơn một lần.

Đối số thứ hai là giá trị ước đoán ban đầu. Nếu ta cung cấp 
một ước đoán khác, thì (đôi khi) ta sẽ nhận được nghiệm khác.

\begin{verbatim}
>> fzero(@error_func, -2)
ans = -1
\end{verbatim}
%
Mặt khác, nếu biết được hai giá trị bao quanh một nghiệm,
bạn có thể cung cấp cả hai giá trị đó:

\begin{verbatim}
>> fzero(@error_func, [2,4])
ans = 3.0000
\end{verbatim}
%
Đối số thứ hai thực ra là một véc-tơ chứa hai phần tử. Toán tử
ngoặc vuông là một trong số vài cách làm tiện lợi để tạo ra 
một véc-tơ mới.

Bạn có thể tò mò muốn biết {\tt fzero} gọi đến hàm sai số bao nhiêu
lần, và gọi ở những vị trí nào. Nếu bạn sửa \verb#error_func# 
sao cho nó hiển thị giá trị của {\tt x} mỗi lần được gọi, rồi chạy lại 
{\tt fzero} thì bạn sẽ thu được:

\begin{verbatim}
>> fzero(@error_func, [2,4])
x =  2
x =  4
x =  2.75000000000000
x =  3.37500000000000
x =  3.00785843300030
x =  2.99996273999525
x =  3.00003711388783
x =  3.00000000000024
x =  2.99999998600024
ans =  2.99999998600024
\end{verbatim}
%
Không ngạc nhiên là, nó bắt đầu bằng việc tính $f(2)$ và $f(4)$. 
Sau mỗi lần lặp, khoảng bao nghiệm đã co ngắn lại; {\tt fzero} 
dừng khi khoảng bao quá nhỏ và nghiệm được ước tính chính xác
đến 16 chữ số. Nếu không cần đạt độ chính xác đến thế, bạn
có thể bảo {\tt fzero} cho một đáp số thô hơn một cách nhanh
chóng (hãy xem lời giải thích cách dùng hàm để biết thêm chi tiết).


\section{Điều gì có thể trục trặc?}

Vấn đề thường gặp nhất khi dùng {\tt fzero} là quên mất dấu
{\tt @}. Trong trường hợp đó, bạn sẽ nhận được:

\begin{verbatim}
>> fzero(error_func, [2,4])
error: `x' undefined near line 2 column 5
error: called from:
error:   C:\Users\tencuaban\matlab\error_func.m at 
	line 2, column 5
error: evaluating argument list element number 1
\end{verbatim}
%
Đây là thông báo lỗi rất dễ lẫn. Vấn đề là ở chỗ Octave coi đối số
thứ nhất là một lời gọi hàm, vì vậy nó gọi \verb#error_func# mà
không kèm theo đối số nào. Vì \verb#error_func# cần một đối số nên
thông báo ghi là đối số nhập vào là ``không xác định,''  dù
có thể rõ hơn nếu ghi là bạn chưa cung cấp giá trị cho đối số.

Một vấn đề thường gặp khác là viết một hàm sai số mà không bao giờ
gán giá trị cho một biến đầu ra. Nói chung, các hàm nên 
{\em luôn luôn} gán một giá trị cho biến đầu ra, nhưng Octave
không bắt buộc điều này, vì vậy ta rất dễ quên. Chẳng hạn, nếu
bạn viết:

\begin{verbatim}
function res = error_func(x)
    y = x^2 - 2*x -3
end
\end{verbatim}
%
và sau đó gọi nó từ dấu nhắc lệnh:

\begin{verbatim}
>> error_func(4)
y = 5
\end{verbatim}

Dường như nó đã hoạt động, nhưng đừng bị mắc lừa. Hàm này
gán giá trị cho {\tt y}, rồi hiển thị kết quả, nhưng khi hàm kết thúc,
{\tt y} sẽ biến mất cùng với không gian làm việc của hàm. Nếu bạn
thử dùng nó với {\tt fzero}, bạn sẽ nhận được

\begin{verbatim}
>> fzero(@error_func, [2,4])
y = -3
warning: error_func: some elements in list of return values are undefined
y =  5
warning: error_func: some elements in list of return values are undefined
y = 0
warning: error_func: some elements in list of return values are undefined
error: fzero: zero point is not bracketed
error: called from:
error:   /usr/share/octave/3.4.2/m/optimization/fzero.m at line 300, column 1
\end{verbatim}
%
Từ một lỗi về cách viết hàm, máy đã thông báo lỗi liên quan về vấn đề
khác: nghiệm không bao trong khoảng cần tìm. (Điều này sẽ sớm được
đề cập ngay sau đây.)

Bạn có thể đã thấy thông báo lỗi này khi gọi \verb#error_func# từ
trình thông dịch, nhưng chỉ khi bạn đã gán kết quả cho một biến:

\begin{verbatim}
>> x = error_func(4)
y =  5
warning: error_func: some elements in list of return values are undefined
x = [](0x0)
\end{verbatim}
%
Bạn có thể tránh trục trặc này nếu nhớ hai quy tắc sau:

\begin{itemize}

\item Hàm nên luôn gán các giá trị cho các biến đầu ra\footnote{Ừ,
công nhận là vẫn có ngoại lệ, như {\tt find\_triples}.  Các hàm không
trả lại giá trị đôi khi vẫn được gọi là ``lệnh,'' vì chúng làm việc gì đó 
(như hiển thị giá trị hoặc vẽ hình) nhưng hoặc là không có biến đầu ra
hay không gán giá trị cho nó.}.

\item Khi gọi một hàm, bạn phải luôn làm điều gì đó với kết quả thu được
(gán nó cho một biến hoặc dùng nó như một phần của biểu thức, v.v.).

\end{itemize}

Khi bạn tự viết các hàm và dùng chúng, rất dễ nảy sinh những lỗi không
phát hiện ra. Nhưng khi dùng các hàm bạn viết cùng với các hàm của
Octave như {\tt fzero}, bạn phải viết đúng!

Còn một điều nữa có thể sai: nếu bạn cung cấp một khoảng số để làm 
ước đoán ban đầu mà nó lại không chứa nghiệm nào, bạn sẽ nhận được

\begin{verbatim}
>> fzero(@error_func, [0,1])
error: fzero: not a valid initial bracketing
error: called from:
error:   /usr/share/octave/3.4.2/m/optimization/fzero.m at line 172, column 5
\end{verbatim}
%
Còn một điều trục trặc nữa có thể xảy ra khi bạn dùng {\tt fzero}, nhưng
điều này có vẻ như ít tại bạn. Có khả năng là {\tt fzero} không thể tìm
được nghiệm.

Nói chung {\tt fzero} khá mạnh, vì vậy bạn có thể không bao giờ gặp
vấn đề khi dùng nó, nhưng nhớ rằng không có bảo đảm gì là {\tt fzero}
sẽ chạy, đặc biệt là nếu bạn chỉ cung cấp được một giá trị làm ước đoán
ban đầu. Ngay cả khi bạn cung cấp một khoảng bao nghiệm, mọi thứ
vẫn có thể trục trặc nếu như hàm sai số bị gián đoạn.


\section{Tìm giá trị ước đoán ban đầu}

Giá trị (hay khoảng) ước đoán ban đầu của bạn gần đúng bao nhiêu, thì
khả năng hoạt động của {\tt fzero} sẽ cao bấy nhiêu, và càng cần ít
lần lặp hơn.

Khi bạn giải bài toán trong thực tế, thường bạn sẽ có sự nhận định
về đáp số. Nhận định này thường đảm bảo có được một ước đoán
ban đầu gần đúng để tìm nghiệm.

Một cách làm khác là vẽ đồ thị hàm số và xem nếu bạn có thể
tìm nghiệm gần đúng bằng mắt thường. Nếu bạn có một hàm,
như \verb#error_func# nhận một biến vô hướng và trả lại một
biến đầu ra vô hướng, thì bạn có thể vẽ nó bằng {\tt ezplot}:

\begin{verbatim}
>> ezplot(@error_func, [-2,5])
\end{verbatim}

Đối số thứ nhất là tên chuôi của hàm; đối số thứ hai là khoảng
phạm vi mà bạn muốn vẽ hàm.

Theo mặc định, {\tt ezplot} gọi hàm của bạn 100 lần (dĩ nhiên là mỗi lần
với một giá trị {\tt x} khác). Vì vậy bạn có thể muốn làm cho hàm trở nên
lặng trước khi vẽ nó.


\section{Nói thêm về xung đột tên}

Các hàm và biến chiếm cùng một ``không gian tên,'' nghĩa là mỗi khi 
một tên xuất hiện trong biểu thức, Octave bắt đầu đi tìm một biến
có tên như vậy, và nếu biến đó không tồn tại, thì tìm một hàm.

Kết quả là, nếu bạn có một biến có cùng tên với một hàm thì biến sẽ 
{\bf lấn át} hàm. Chẳng hạn, nếu bạn gán một giá trị cho {\tt sin}, 
rồi thử dùng hàm {\tt sin}, bạn {\em có thể} sẽ nhận được lỗi:

\begin{verbatim}
>> sin = 3;
>> x = 5;
>> sin(x)
error: A(I): index out of bounds; value 5 out of bound 1
\end{verbatim}
%
Trong ví dụ này, vấn đề đã rõ ràng. Vì giá trị của {\tt sin} là
một số vô hướng, mà số vô hướng thực ra là ma trận 1x1, Octave sẽ
cố gắng truy cập phần tử thứ 5 của ma trận và thấy rằng không có
phần tử nào như vậy. Dĩ nhiên là nếu ``lời gọi hàm'' này đặt cách xa
lệnh gán thì thông báo lỗi này còn có thể làm ta bối rối hơn nữa.

Nhưng điều duy nhất còn tệ hơn cả nhận thông báo lỗi là {\em không}
nhận được thông báo lỗi. Nếu giá trị của {\tt sin} là một véc-tơ,
hoặc nếu giá trị của {\tt x} đã nhỏ hơn thì bạn gặp rắc rối thực sự.

\begin{verbatim}
>> sin = 3;
>> sin(1)
ans = 3
\end{verbatim}
%
Hãy xem, sin của 1 đâu có bằng 3 !

Lỗi ngược lại cũng có thể xuất hiện nếu bạn thử truy cập một biến
không xác định mà nó tình cờ trùng tên với một hàm. Chẳng hạn, nếu
bạn đã có một hàm tên là {\tt f}, và bây giờ thử tăng một biến
cùng tên {\tt f} (trước đó biến này quên không được khởi tạo), bạn
sẽ thấy:

% Different in octave
\begin{verbatim}
>> f = f+1
error: `x' undefined near line 2 column 7
error: called from:
error:   f at line 2, column 5
\end{verbatim}
%
% ------- lược bỏ lỗi matlab không có trong octave
Không có một cách làm chung để tránh tất cả những lỗi xung đột
kiểu này, nhưng bạn có thể giảm khả năng xảy ra lỗi bằng cách chọn
các tên biến không trùng với các hàm có sẵn, và bằng cách chọn tên
các hàm mà chúng ít có khả năng bị lấy làm tên biến. Đó là lý do
tại sao trong Mục~\ref{notation} tôi gọi hàm sai số là
\verb#error_func# thay vì {\tt f}.  Tôi thường đặt tên các hàm
kết thúc với {\tt func}, và điều này cũng giúp ích.


\section{Gỡ lỗi bằng bốn hành động}

Khi gỡ lỗi một chương trình, đặc biệt nếu bạn phải đương đầu với
một lỗi khó, có bốn việc mà bạn cần thử làm:

\begin{description}

\item[đọc:] Kiểm tra mã lệnh, tự đọc nhẩm, và kiểm tra xem có đúng
là chương trình này có ý định thực hiện đúng điều bạn muốn không.

\item[chạy:] Thử nghiệm bằng cách sửa đổi và chạy các phiên bản mã lệnh
khác nhau. Thường nếu bạn hiển thị đúng thứ ở đúng chỗ trong chương
trình, vấn đề sẽ trở nên hiểu nhiên, nhưng đôi khi bạn phải dành 
thời gian để dựng dàn giáo.

\item[nghiền ngẫm:] Hãy dành thời gian suy nghĩ! Đó là loại lỗi gì:
cú pháp, thực thi, logic? Bạn có thể tìm được thông tin gì từ dòng
thông báo lỗi, hay từ kết quả đầu ra của chương trình? Loại lỗi gì
có thể gây ra vấn đề mà bạn đang thấy? Lần gần nhất bạn đã thay đổi
gì ở mã lệnh, trước khi xảy ra lỗi?

\item[rút lui:] Đến một lúc nào đó, cách tốt nhất là rút lui, hoàn lại
những thay đổi mới nhất, đến khi bạn trở về trạng thái của chương
trình hoạt động, mà bạn hiểu được. Sau đó bạn có thể bắt đầu lập
lại chương trình.

\end{description}

Những người mới lập trình đôi khi lún sâu vào một trong những hoạt
động này mà quên những hoạt động khác. Mỗi cái có những 
nhược điểm riêng của nó.

Chẳng hạn, việc đọc mã lệnh có thể giúp ích nếu vấn đề nằm ở lỗi
đánh máy, nhưng vô ích nếu vấn đề ở chỗ hiểu sai về khái niệm. Nếu
bạn không hiểu chương trình làm gì, thì dù có đọc lại 100 lần bạn
cũng chẳng tìm thấy lỗi, vì lỗi nằm ngay trong đầu bạn.

Chạy thử nghiệm có thể giúp ích, đặc biệt với các kiểm tra nhỏ,
đơn giản. Nhưng nếu chạy thử mà không nghĩ hoặc đọc mã lệnh thì bạn
có thể rơi vào tình trạng mà tôi gọi là ``lập trình bước ngẫu
nhiên''---một quá trình thực hiện những thay đổi ngẫu nhiên đến
khi chương trình hoạt động đúng. Khỏi phải nói, lập trình bước
ngẫu nhiên có thể tốn rất nhiều thời gian.

Lối thoát là dành thêm thời gian suy nghĩ. Gỡ lỗi cũng giống như
môn khoa học thực nghiệm. Bạn ít nhất phải có được giả thiết về
vấn đề. Nếu có nhiều khả năng, hãy cố gắng thực hiện phép thử
để loại trừ một trong số các khả năng đó.

Nghỉ ngơi đôi khi cũng giúp ích cho suy nghĩ. Nói chuyện cũng như
vậy. Nếu bạn giải thich vấn đề cho ai đó (và ngay cả cho bản thân),
bạn đôi khi có thể tìm thấy lời giải ngay trước khi đặt xong câu
hỏi.

Nhưng ngay cả những kĩ thuật gỡ lỗi tốt nhất cũng thất bại nếu có
quá nhiều lỗi, hay nếu lỗi bạn cố sửa đang quá lớn và phức tạp. 
Đôi khi lựa chọn hay nhất là rút lui, làm đơn giản chương trình
đến khi bạn có được một chương trình hoạt động, rồi sau đó phát triển
lại.

Người mới lập trình thường miễn cưỡng không muốn rút lui,
vì họ không thể chịu được nếu phải xóa một dòng lệnh (dù dòng lệnh
đó có sai đi nữa). Nếu bạn cảm thấy được, thì hãy sao lưu chương trình
vào một tập tin khác trước khi lược bỏ mã lệnh. Sau đó bạn dán 
lại những mảnh chương trình vào, mỗi lúc một ít.

Tóm lại, sau đây là Định luật thứ chín về gỡ lỗi:

\begin{quote}
Để tìm ra một lỗi khó, cần phải đọc, chạy thử, suy nghĩ, và đôi khi
rút lui. Nếu bạn lún sâu vào một trong những hoạt động này mà không
có kết quả, hãy thử hoạt động khác.
\end{quote}



\section{Thuật ngữ}

\begin{description}

\item[nghiệm giải tích:] Cách giải phương trình bằng việc thực hiện
biến đổi đại số để rút ra một biểu thức tường minh để tính giá trị
của một ẩn.

\item[nghiệm số trị:] Cách giải phương trình bằng việc tìm một 
giá trị số thỏa mãn phương trình đó, thường chỉ là xấp xỉ.

\item[phương pháp số:] Phương pháp (hoặc thuật toán) để tính ra
nghiệm số trị.

\item[ánh xạ:] Sự tương ứng giữa các phần tử thuộc một tập hợp
(tập nguồn) và các phần tử thuộc tập hợp khác (tập đích). Bạn có thể
hình dung các dãy, véc-tơ và hàm như các loại ánh xạ khác nhau.

\item[tập nguồn:] Tập hợp các giá trị điểm đầu của ánh xạ.

\item[tập đích:] Tập hợp các giá trị điểm cuối của ánh xạ.

\item[tập rời rạc:] Một tập hợp, như tập các số nguyên, trong đó
các phần tử là đếm được.

\item[tập liên tục:] Một tập hợp, như tập các số thực, trong đó
các phần tử không đếm được. Bạn có thể hình dung tập các số dấu
phẩy động như một tập liện tục.

\item[nghiệm (của hàm):] Giá trị trong tập xác định (tập nguồn) của
hàm mà ánh xạ của nó chiếu đến 0.

\item[chuôi của hàm:] Trong Octave, chuôi của hàm là một cách
tham chiếu đến hàm bằng một cái tên (và truyền nó dưới dạng một
đối số) mà không gọi hàm đó.

\item[lấn át:] Trường hợp xung đột về tên trong đó một định nghĩa mới
khiến cho định nghĩa cũ trở nên không truy cập được. Trong Octave,
các tên biến có thể lấn át được các hàm lập sẵn (có thể dẫn đến những
kết quả rất hài hước).

\end{description}

\section{Bài tập}

\begin{ex}

\begin{enumerate}

\item Hãy viết một hàm có tên {\tt cheby6} để lượng giá đa thức
Chebyshev bậc 6. Hàm cần nhận một biến đầu vào, $x$, và trả lại

\begin{equation}
32 x^6 - 48 x^4 + 18 x^2 - 1
\end{equation}
%
\item Hãy dùng {\tt ezplot} để hiển thị một đồ thị của hàm này trong
khoảng từ 0 đến 1. Hãy tìm các nghiệm trong khoảng này.

\item Hãy dùng {\tt fzero} để tìm càng nhiều nghiệm càng tốt. Liệu
{\tt fzero} có luôn tìm được nghiệm gần sát giá trị ước đoán ban đầu
nhất hay không?

\end{enumerate}
\end{ex}


\begin{ex}
\label{duck}

Khối lượng riêng của một con vịt, $\rho$, là 0,3 g/cm${}^3$ (bằng 0,3 
lần khối lượng riêng của nước).

Thể tích của một khối cầu\footnote{Ví dụ này được chính sửa từ Gerald
and Wheatley, {\em Applied Numerical Analysis}, Fourth Edition,
Addison-Wesley, 1989.} có bán kính $r$ là $\frac{4}{3} \pi r^3$.

Nếu khối cầu có bán kính $r$ được nhúng trong nước ngập đến độ sâu $d$, 
thì thể tích của khối cầu phần bị ngập là

\[ volume = \frac{\pi}{3} (3r d^2 - d^3) \quad 
\mbox{khi} \quad d < 2 r \]

Một vật thể luôn nổi lơ lửng ở độ cao sao cho trọng lượng phần bị chìm 
trong nước đúng bằng trọng lượng của vật ban đầu.

Giả sử rằng con vịt có hình dáng tương đương một quả cầu bán kính 10 cm,
phần nhúng nước của con vịt sẽ sâu bao nhiêu?

Sau đây là một số gợi ý để bạn giải bài này:

\begin{itemize}

\item Hãy viết một phương trình liên hệ giữa $\rho$, $d$ và $r$.

\item Sắp xếp lại phương trình sao cho vế phải là số không.
Mục tiêu của chúng ta là tìm những giá trị của $d$ là nghiệm phương trình này.

\item Hãy viết một hàm Octave để lượng giá hàm đã thành lập. Hãy kiểm tra
   nó, rồi sửa nó thành một hàm lặng.

\item Hãy dự đoán giá trị của $d_0$ để làm ước tính ban đầu.

\item Dùng {\tt fzero} để tìm ra nghiệm gần $d_0$.

\item Kiểm tra để bảo đảm rằng kết quả có ý nghĩa. Đặc biệt, kiểm tra
   điều kiện $d < 2 r$, bởi nếu không thì công thức thể tích sẽ sai!

\item Thử các giá trị khác nhau của $\rho$ và $r$ và xem hiện tượng có diễn ra
như bạn mong đợi hay không. Điều gì sẽ xảy ra khi $\rho$ tăng? Lên đến
vô cùng? Hạ xuống bằng 0 ? Điều gì sẽ xảy ra khi $r$ tăng?  Lên đến vô cùng?
Hạ xuống bằng không?

\end{itemize}


\end{ex}

% for another time, figure out how to use fzero to find zeros of...

%\item The Riemann zeta function can be written

%\[ zeta \equiv w \to sum_{k=1}^\infty k^w \]

%where $w$ is a complex number.  If you are not familiar with
%complex numbers, you should skip this problem.







% chap07
\chapter{Hàm số của véc-tơ}


\section{Hàm số và tập tin}
\label{funfiles}

Đến giờ ta mới chỉ đưa một hàm vào trong mỗi tập tin. Cũng có thể
đặt nhiều hàm vào trong một tập tin, nhưng chỉ có hàm đầu tiên,
{\bf hàm cấp cao nhất} mới gọi được từ dấu nhắc lệnh. Các 
{\bf hàm phụ trợ} khác có thể được gọi từ bất kì đâu trong tập tin,
nhưng không thể gọi từ tập tin khác.

Những chương trình lớn thường cần đến nhiều hàm; việc giữ tất cả
các hàm trong cùng một tập tin tuy tiện lợi, nhưng làm cho việc gỡ lỗi
trở nên khó khăn vì bạn không thể gọi các hàm phụ trợ từ dấu nhắc lệnh.

Để giúp giải quyết vấn đề này, tôi thường dùng hàm cấp cao nhất
để phat triển và thử nghiệm các hàm phụ trợ. Chẳng hạn, tôi có thể
tạo ra một tập tin tên là {\tt duck.m} và khởi đầu với một hàm cấp 
cao nhất có tên là {\tt duck} mà không nhận vào bất kì biến đầu vào
cũng như trả lại bất kì biến đầu ra nào.

Sau đó tôi sẽ viết một hàm có tên là \verb#error_func# để lượng giá
hàm sai số cho {\tt fzero}. Để thử nghiệm \verb#error_func# tôi sẽ
gọi nó từ  {\tt duck} rồi gọi {\tt duck} từ dấu nhắc lệnh.

Bản nháp chương trình đầu tiên của tôi có thể trông như sau:

\begin{verbatim}
function res = duck()
    error = error_func(10)
end

function res = error_func(h)
    rho = 0.3;      % density in g / cm^3
    r = 10;         % radius in cm
    res = h;
end
\end{verbatim}
%
Dòng lệnh {\tt res = h} chưa xong, nhưng để phục vụ mục đích thử nghiệm
thì từng ấy mã lệnh cũng đủ.
Một khi đã hoàn thành và thử nghiệm \verb#error_func#, tôi sẽ sửa
{\tt duck} sao cho nó dùng {\tt fzero}.

Ở bài toán này tôi có thể chỉ cần đến hai hàm, nhưng nếu có nhiều hàm hơn,
tôi có thể lần lượt viết và thử nghiệm từng hàm một, rồi sau đó kết hợp 
chúng lại thành một chương trình chạy được.



\section{Mô hình hóa vật lý}
\label{modeling}

Các ví dụ mà chúng ta đã đề cập đến giờ đều liên quan đến toán học;
Bài tập~\ref{duck}, ``bài toán con vịt,'' là ví dụ đầu tiên mà chúng ta
tìm hiểu một hiện tượng vật lý. Nếu bạn chưa làm bài này, hãy quay lại
và ít nhất là đọc kỹ bài toán.

Cuốn sách này được viết về chủ đề {\bf mô hình hóa vật lý}, vì vậy
tôi nên giải thích ý nghĩa của cụm từ trên. Mô hình hóa vật lý là một
công đoạn thiết lập những phỏng đoán về các hệ thống vật lý và 
giải thích biểu hiện của chúng. Một {\bf hệ vật lý} là thứ tồn tại 
khách quan mà ta cần quan tâm, chẳng hạn như con vịt.

Hình vẽ sau minh họa các bước của quá trình này:

% \beforefig 
\centerline{\includegraphics[height=1.5in]{figs/model_vi.eps}}

Một {\bf mô hình} là một dạng biểu diễn được đơn giản hóa cho một
hệ vật lý. Quá trình lập một mô hình được gọi là {\bf trừu tượng hóa}.
Trong phạm vi bàn đến ở đây, ``trừu tượng'' ngược nghĩa với ``hiện thực;''
một mô hình trừu tượng ít có sự tương đồng trực tiếp đến hệ vật lý mà
nó mô phỏng, cũng như hội họa trừu tượng không trực tiếp biểu diễn
hình ảnh của vạn vật ngoài đời. Một mô hình hiện thực là mô hình
bao gồm nhiều chi tiết hơn và tương đồng hơn với thế giới thực.

Sự trừu tượng hóa sẽ dẫn đến việc phải quyết định đúng đắn về việc
đưa các yếu tố nào vào mô hình và đơn giản bớt hoặc lược bỏ những
yếu tố nào. Chẳng hạn, trong bài toán con vịt, ta xét đến trọng lượng riêng
của vịt và lực đẩy nổi của nước, nhưng bỏ qua lực đẩy nổi do không khí 
và tác động đạp nước của chân vịt. Ta cũng
đơn giản hóa hình dạng con vịt bằng cách giả thiết rằng phần con vịt
ngập trong nước cũng gần giống một chỏm cầu. Và chúng ta đã sử dụng
những ước tính sơ lược về kích thước và khối lượng của con vịt.

Trong số các quyết định giản hóa trên, có cái chấp nhận được. Khối lượng riêng
của con vịt cao hơn của không khí rất nhiều nên ảnh hưởng của lực đẩy nổi
của không khí có lẽ sẽ rất nhỏ. Những quyết định khác, như hình dạng
khối cầu, thì khó chấp nhận hơn, nhưng có ích. Hình dạng thực tế
của con vịt rất phức tạp; mô hình khối cầu giúp ta có thể tính được
một kết quả gần đúng mà không phải thực hiện đo đạc chi tiết hình dạng
của những con vịt thật.

Một mô hình giống thật hơn chưa chắc đã tốt hơn. Mô hình rất có ích
vì chúng có thể được phân tích về mặt toán học và mô phỏng về
mặt số trị. Các mô hình quá giống thật sẽ khó có thể mô phỏng được
và hoàn toàn không thể phân tích được.

Một mô hình được gọi là thành công nếu nó đạt yêu cầu đề ra. Nếu ta
chỉ cần một ước đoán rất thô sơ về phần của con vịt ngập trong nước
thì mô hình khối cầu cũng là đủ. Nếu ta cần một lời giải chính xác hơn
(vì lý do nào đó) thì ta có thể cần đến một mô hình giống thật hơn.

% Einstein's actual quote: ``It can scarcely be denied that the supreme
% goal of all theory is to make the irreducible basic elements as simple
% and as few as possible without having to surrender the adequate
% representation of a single datum of experience.

%     * "On the Method of Theoretical Physics" The Herbert Spencer
%       Lecture, delivered at Oxford (10 June 1933); also published in
%       Philosophy of Science, Vol. 1, No. 2 (April 1934),
%       pp. 163-169. [thanks to Dr. Techie @ www.wordorigins.org and
%       JSTOR]

Việc kiểm tra xem một mô hình có đủ tính đúng đắn hay không được
gọi là {\bf thẩm định}. Hình thức chặt chẽ nhất của thẩm định là 
tiến hành đo trên hệ vật lý và so sánh với kết quả dự đoán của một
mô hình.

Nếu điều này không thực hiện được, ta vẫn còn những hình thức 
thẩm định khác tuy không chặt chẽ bằng. Một hình thức là so sánh
nhiều mô hình của cùng một hệ. Nếu chúng không thống nhất thì
có biểu hiện là (ít nhất) một trong số các mô hình đó đã sai, và
độ lớn của sự khác biệt chính là dấu hiệu về độ tin cậy của những
ước tính đó.

Đến giờ chúng ta chỉ thấy được một mô hình vật lý, vì vậy mà 
một phần của đoạn thảo luận trên vẫn chưa thể làm rõ. Ta sẽ 
quay trở lại chủ đề này sau, nhưng trước hết cần tìm hiểu thêm
về véc-tơ.



\section{Véc-tơ với vai trò là biến đầu vào}

Vì nhiều hàm lập sẵn chấp nhận véc-tơ làm đối số, nên sẽ không
có gì lạ khi bạn có thể viết các hàm nhận vào véc-tơ. Sau đây là
một ví dụ (ngốc nghếch):

\begin{verbatim}
function res = display_vector(X)
    X
end
\end{verbatim}
%
Chẳng có gì đặc biệt về hàm này cả. Điểm khác biệt duy nhất
so với hàm vô hướng mà ta gặp từ trước đó là tôi đã dùng một
chữ cái viết in để gợi nhớ rằng {\tt X} là một véc-tơ.

Sau đây là một ví dụ khác về một hàm không trả về giá trị nào;
nó chỉ hiển thị giá trị của biến đầu vào:

\begin{verbatim}
>> display_vector(1:3)

X = 1     2     3
\end{verbatim}
%
Tiếp theo là một ví dụ lý thú hơn, trong đó gói đoạn mã lệnh ở
Mục~\ref{reduce} để tính tổng các phần tử của một véc-tơ:

\begin{verbatim}
function res = mysum(X)
    total = 0;
    for i=1:length(X)
        total = total + X(i);
    end
    res = total;
end
\end{verbatim}
%
Tôi gọi nó là {\tt mysum} để tránh xung đột tên với hàm lập sẵn
{\tt sum}, nhưng về công dụng thì hai hàm giống nhau.

Sau đây là cách gọi nó từ dấu nhắc lệnh:

\begin{verbatim}
>> total = mysum(1:3)
total = 6
\end{verbatim}
%
Vì hàm này có một giá trị trả về nên tôi đã cố ý gán nó cho một
biến.


\section{Véc-tơ đóng vai trò là biến đầu ra}

Cũng không có gì sai khi gán véc-tơ cho một biến đầu ra. Sau đây
là một ví dụ trong đó gói đoạn mã lệnh ở Mục~\ref{apply}:

\begin{verbatim}
function res = myapply(X)
    for i=1:length(X)
        Y(i) = X(i)^2
    end
    res = Y
end
\end{verbatim}
%
Lý tưởng nhất lẽ ra phải thay đổi tên của biến đầu ra thành
{\tt Res}, để nhắc rằng nó nhận một giá trị véc-tơ, nhưng
tôi đã không làm vậy.

Sau đây là cách dùng {\tt myapply}:

\begin{verbatim}
>> V = myapply(1:3)

V = 1     4     9
\end{verbatim}
%
\begin{ex}
Hãy viết một hàm có tên là \verb#find_target# để gói đoạn lệnh
từ Mục~\ref{search}, để tìm vị trí của giá trị mong muốn trong
một véc-tơ.
\end{ex}


\section{Véc-tơ hóa hàm của bạn}

Những hàm tính trên véc-tơ thường cũng dùng được với các số
vô hướng, vì Octave coi rằng số vô hướng là véc-tơ có chiều dài
bằng 1.

\begin{verbatim}
>> mysum(17)
ans = 17

>> myapply(9)
ans = 81
\end{verbatim}

Không may là, điều còn lại không phải luôn đúng. Nếu bạn viết
một hàm để tính cho đầu vào là số vô hướng, thì nó có thể không
dùng được cho véc-tơ.

Nhưng có trường hợp vẫn được! Nếu các toán tử và hàm bạn dùng
trong thân hàm có thể tính được với véc-tơ thì hàm của bạn sẽ
tính được cho véc-tơ.

Chẳng hạn, sau đây chính là hàm đầu tiên mà ta viết:

\begin{verbatim}
function res = myfunc (x)
    s = sin(x)
    c = cos(x)
    res = abs(s) + abs(c)
end
\end{verbatim}
%
Này! Nó làm việc được với véc-tơ đấy:

\begin{verbatim}
>> Y = myfunc(1:3)

Y = 1.3818    1.3254    1.1311
\end{verbatim}
%
Đến đây, tôi muốn dừng lại một chút để thừa nhận rằng tôi đã
khắt khe một chút khi trình bày về Octave, vì có một số 
đặc điểm mà tôi nghĩ đã làm khó người mới học một cách
không cần thiết. Nhưng rồi cuối cùng, ở đây ta thấy được 
những đặc điểm chứng tỏ sức mạnh của Octave.

Một số hàm khác ta đã viết lại không dùng được với véc-tơ, nhưng
chúng có thể sửa được dễ dàng. Chẳng hạn, có hàm 
{\tt hypotenuse} từ Mục~\ref{hypotenuse}:

\begin{verbatim}
function res = hypotenuse(a, b)
    res = sqrt(a^2 + b^2);
end
\end{verbatim}
%
Hàm này không tính được với véc-tơ vì toán tử \verb+^+ 
dành cho phép lũy thừa ma trận, và chỉ tính cho các ma trận
vuông.

\begin{verbatim}
>> hypotenuse(1:3, 1:3)
error: for A^b, A must be square
error: evaluating argument list element number 1
error: called from:
error:   C:\Users\tencuaban\matlab\hypotenuse.m at line 2, column 9
\end{verbatim}
%
Nhưng nếu bạn thay thế \verb+^+ bởi toán tử tính theo phần tử
\verb+.^+, nó lại chạy được!

\begin{verbatim}
>> A = [3,5,8];
>> B = [4,12,15];
>> C = hypotenuse(A, B)

C = 5    13    17
\end{verbatim}
 %
Ở trường hợp này, nó ghép cặp các phần tử tương ứng từ hai
véc-tơ đầu vào, nên các phần tử của {\tt C} là độ dài cạnh huyền
lần lượt của các cặp $(3,4)$, $(5,12)$ và $(8,15)$.

Nói chung, nếu bạn muốn viết một hàm trong đó chỉ dùng các toán tử
theo phần tử và các hàm làm việc trên véc-tơ, thì hàm mới viết cũng
sẽ làm việc được với véc-tơ.


\section{Tổng và hiệu}

Một phép toán với véc-tơ quan trọng khác là {\bf tổng lũy tích}, vốn
nhận một véc-tơ đầu vào và tính một véc-tơ mới gồm tất cả các tổng
thành phần của véc-tơ ban đầu. Theo kí hiệu toán, nếu $V$ là véc-tơ
ban đầu, thì các phần tử của tổng lũy tích, $C$, là:

\[ C_i = \sum_{j=1}^i V_j \]

Nói cách khác, phần tử thứ $i$ của $C$ là tổng của 
$i$ phần tử đầu tiên trong $V$.  Octave cung cấp một hàm có tên
là {\tt cumsum} để tính tổng lũy tích:

\begin{verbatim}
>> V = 1:5

V = 1     2     3     4     5

>> C = cumsum(V)

C = 1     3     6    10    15
\end{verbatim}
%
\begin{ex}
Hãy viết một hàm có tên là \verb#cumulative_sum# trong đó dùng
một vòng lặp để tính tổng lũy tích của véc-tơ đầu vào.
\end{ex}

Phép tính ngược với {\tt cumsum} là {\tt diff}, vốn tính hiệu giữa
các phần tử kế tiếp trong véc-tơ đầu vào.

\begin{verbatim}
>> D = diff(C)

D = 2     3     4     5
\end{verbatim}
%
Lưu ý rằng véc-tơ đầu ra ngắn hơn 1 phần tử so với véc-tơ đầu vào.
Vì vậy, phiên bản {\tt diff} trong Octave không thật sự là hàm ngược
của {\tt cumsum}. Nếu là hàm ngược thì ta đã có thể trông đợi 
{\tt cumsum(diff(X))} bằng {\tt X}:

\begin{verbatim}
>> cumsum(diff(V))

ans = 1     2     3     4
\end{verbatim}
%
Nhưng nó đã không thỏa mãn điều kiện trên.

\begin{ex}
Hãy viết một hàm {\tt mydiff} để tính nghịch đảo của 
{\tt cumsum}, sao cho cả {\tt cumsum(mydiff(X))} và
{\tt mydiff(cumsum(X))} đều trả lại {\tt X}.
\end{ex}


\section{Tích và thương}

Dạng phép nhân của {\tt cumsum} là {\tt cumprod}, dùng để
tính {\bf tích số lũy tích}.  Theo kí hiệu toán học thì:

\[ P_i = \prod_{j=1}^i V_j \]

Trong Octave, hàm đó như sau:

\begin{verbatim}
>> V = 1:5

V = 1     2     3     4     5

>> P = cumprod(V)

P = 1     2     6    24   120
\end{verbatim}
%
\begin{ex}
Hãy viết một hàm tên là \verb#cumulative_prod# trong đó dùng
vòng lặp để tính tích số lũy tích từ véc-tơ đầu vào.
\end{ex}

Octave không cung cấp một phiên bản phép nhân tương ứng với
{\tt diff}, mà lẽ ra đã có tên {\tt ratio}, để tính tỉ số giữa các
phần tử kế tiếp nhau trong véc-tơ đầu vào.

\begin{ex}
Hãy viết một hàm tên là {\tt myratio} để tính nghịch đảo của
{\tt cumprod}, sao cho cả {\tt cumprod(myratio(X))} và
{\tt myratio(cumprod(X))} đều trả lại {\tt X}.

Bạn có thể dùng một vòng lặp, hoặc nếu khéo hơn, có thể lợi dụng
hệ thức $e^{\ln a + \ln b} = a b$.

Nếu áp dụng {\tt myratio} cho một véc-tơ có chứa các số Fibonacci,
bạn có thể khẳng định được rằng tỉ số giữa các phần tử kế tiếp nhau 
hội tụ về tỉ số vàng, $(1+\sqrt{5})/2$ (xem Bài tập~\ref{fibratio}).
\end{ex}



\section{Kiểm tra sự tồn tại}

Đôi khi ta phải kiểm tra các phần tử của một véc-tơ xem nếu có
bất kì phần tử nào thỏa mãn một điều kiện cho trước hay không.
Chẳng hạn, bạn muốn biết rằng có phần tử số dương trong véc-tơ
hay không. Theo logic học, điều kiện này được gọi là 
{\bf kiểm tra sự tồn tại}, và nó được kí hiệu bởi dấu $\exists$, 
đọc là ``tồn tại.''  Chẳng hạn, biểu thức sau

\[ \exists x \mbox{~thuộc~} S: x>0 \]

\noindent nghĩa là ``tồn tại phần tử $x$ nào đó trong tập hợp $S$ sao cho
$x>0$.''  Trong Octave, ý này có thể được thể hiện tự nhiên bằng
một hàm logic như {\tt exists}, vốn trả lại 1 nếu có phần tử như vậy
và 0 nếu không có.

\begin{verbatim}
function res = exists(X)
    for i=1:length(X)
        if X(i) > 0
            res = 1;
            return
        end
    end
    res = 0;
end
\end{verbatim}
%
Trước đây chưa bắt gặp lệnh {\tt return}; nó tương tự như 
{\tt break}, chỉ khác là nó thoát khỏi cả hàm chứ không chỉ vòng lặp.
Điều đó rất cần đến trong trường hợp này vì ngay khi tìm được một
phần tử dương, ta biết được câu trả lời (có tồn tại!) và có thể
kết thúc hàm lập tức mà không cần xét đến các phần tử còn lại.

Nếu ta thoát ở cuối vòng lặp, điều đó nghĩa là ta không thể tìm
thấy giá trị mong muốn (vì nếu có, ta đã gặp lệnh {\tt return}).



\section{Kiểm tra sự toàn vẹn}

Một phép toán véc-tơ thường gặp khác là kiểm tra xem {\em tất cả}
các phần tử có cùng thỏa mãn một điều kiện không; nó được gọi là
{\bf kiểm tra sự toàn vẹn} và được kí hiệu bằng dấu $\forall$ và
được đọc là ``với mọi.''  Vì vậy biểu thức này

\[ \forall x \mbox{~thuộc~} S: x>0 \]

\noindent có nghĩa là ``với mọi phần tử $x$ trong tập hợp $S$, $x>0$.''

Một cách khá ngốc nghếch để lượng giá biểu thức này trong Octave
là đếm số phần tử thỏa mãn điều kiện trên. Một cách tốt hơn là
rút gọn bài toán về kiểm tra sự tồn tại; nghĩa là viết lại

\[ \forall x \mbox{~thuộc~} S: x>0 \]

\noindent theo dạng

\[ \sim \exists x \mbox{~thuộc~} S: x \le 0 \]

Trong đó $\sim \exists$ nghĩa là ``không tồn tại.'' Nói cách khác,
kiểm tra để đảm bảo tất cả các phần tử phải dương thì cũng như
kiểm tra điều ngược lại, có tồn tại phần tử không dương.

\begin{ex}
Hãy viết một hàm có tên {\tt forall} nhận vào một véc-tơ và trả lại
giá trị 1 nếu tất cả các phần tử đều dương và 0 nếu có bất kì phần
tử nào không dương.
\end{ex}




\section{Véc-tơ logic}

Khi áp dụng một toán tử logic cho một véc-tơ, kết quả là một
{\bf véc-tơ logic}; nghĩa là một véc-tơ trong đó các phần tử
đều là những giá trị logic 1 và 0.

\begin{verbatim}
>> V = -3:3

V = -3    -2    -1     0     1     2     3

>> L = V>0

L =  0     0     0     0     1     1     1
\end{verbatim}
%
Ở ví dụ này, {\tt L} là véc-tơ logic có các phần tử tương ứng với
các phần tử của {\tt V}. Với mỗi phần tử dương của
{\tt V}, phần tử tương ứng của {\tt L} bằng 1.

Véc-tơ logic có thể được dùng như \emph{cờ} để lưu giữ trạng thái
của một điều kiện. Chúng thường được dùng với hàm {\tt find},
vốn nhận vào một véc-tơ logic và trả lạ một véc-tơ bao gồm các
chỉ số của những phần tử ``đúng.''

Áp dụng {\tt find} vào {\tt L} ta được

\begin{verbatim}
>> find(L)

ans = 5     6     7
\end{verbatim}
%
\noindent nghĩa là các phần tử thứ 5, 6 và 7  có giá trị bằng 1.

Nếu không có phần tử ``đúng'' nào, kết quả sẽ là véc-tơ rỗng.

\begin{verbatim}
>> find(V>10)
ans = [](1x0)
\end{verbatim}
%
Ví dụ này tính toán véc-tơ logic và truyền nó làm đối số cho
{\tt find} mà không gán nó vào một biến trung gian. Bạn có thể
đọc đoạn mã lệnh này theo cách trừu tượng là ``tìm tất cả
những chỉ số của các phần tử trong {\tt V} có giá trị lớn hơn 10.''

Bạn cũng có thể dùng {\tt find} để viết lại {\tt exists} cho gọn hơn:

\begin{verbatim}
function res = exists(X)
    L = find(X>0)
    res = length(L) > 0
end
\end{verbatim}
%
\begin{ex}
Hãy viết một phiên bản của {\tt forall} có dùng {\tt find}.
\end{ex}


\section{Thuật ngữ}

\begin{description}

\item[hàm cấp cao nhất:]  Hàm đầu tiên trong một tập tin M;
là hàm duy nhất có thể gọi đến từ dấu nhắc lệnh hoặc từ
một tập tin khác.

\item[hàm phụ trợ:] Hàm trong tập tin M nhưng không phải
hàm cấp cao nhất; nó chỉ có thể được gọi từ một hàm khác
trong cùng tập tin.

\item[mô hình hóa vật lý:] Quá trình đưa ra phỏng đoán về các
hệ vật lý cũng như giải thích biểu hiện của chúng.

\item[hệ vật lý:] Thứ tồn tại trong thế giới thực mà chúng ta
quan tâm nghiên cứu.

\item[mô hình :] Sự mô tả được đơn giản hóa của hệ vật lý,
rất thích hợp cho việc phân tích và mô phỏng.

\item[trừu tượng hóa:] Quá trình xây dựng một mô hình bằng cách
quyết định những yếu tố nào cần được giản hóa hoặc lược bỏ.

\item[thẩm định:] Kiểm tra xem mô hình có đạt yêu cầu sử dụng
hay không.

\item[kiểm tra sự tồn tại:] Một điều kiện logic nhằm diễn đạt ý
``có tồn tại'' một phần tử thỏa mãn một thuộc tính nhất định 
trong tập hợp cho trước.

\item[kiểm tra sự toàn vẹn:] Một điều kiện logic nhằm diễn đạt ý
tất cả các phần tử trong tập hợp đều có chung một thuộc tính nhất định.

\item[véc-tơ logic:] Một véc-tơ gồm các giá trị logic 1 hoặc 0, 
thường là kết quả của phép áp dụng một toán tử logic vào một 
véc-tơ ban đầu.


\end{description}

%\section{Exercises}

%\begin{ex}
%\end{ex}


% chap08
\chapter{Phương trình vi phân thường}


\section{Phương trình vi phân}

{\bf Phương trình vi phân} là phương trình mô tả các đạo hàm của
một hàm số chưa biết. ``Giải phương trình vi phân'' nghĩa là tìm
một hàm số có các đạo hàm thỏa mãn phương trình đã cho.

Chẳng hạn, khi vi phuẩn sống trong môi trường đặc biệt thuận
lợi thì tốc độ sinh trưởng tại bất kì thời điểm nào cũng tỉ lệ thuận
với số vi khuẩn lúc đó. Có lẽ điều ta quan tâm là số vi khuẩn được
biểu diễn dưới dạng hàm theo thời gian. Ta hãy định nghĩa 
$f$ là hàm chiếu từ thời gian, $t$, đến số vi khuẩn, $y$.  Dù không
biết $y$ bằng bao nhiêu, nhưng ta vẫn có thể viết một phương trình 
để mô tả nó:

\[ \frac{df}{dt} = a f \]
%
trong đó $a$ là hằng số đặc trưng cho mức độ vi khuẩn tăng 
nhanh bao nhiêu.

Lưu ý rằng cả hai vế của phương trình đều là hàm số. Khi ta nói
hai hàm số bằng nhau nghĩa là các giá trị của chúng luôn luôn
bằng nhau. Nói cách khác:

\[ \forall t: \frac{df}{dt}(t) = a f(t) \]
%
Đây là một phương trình vi phân {\bf thường} (PVT) vì tất cả các
đạo hàm đều được lấy theo cùng một biến. Nếu như phương trình
liên hệ các đạo hàm theo nhiều biến khác nhau (đạo hàm từng
phần), thì ta sẽ có phương trình đạo hàm {\bf riêng}.

Phương trình này là {\bf bậc nhất} vì nó chỉ có chứa những đạo hàm
cấp một. Nếu có mặt đạo hàm bậc hai, phương trình sẽ là bậc hai, 
và cứ như vậy.

Phương trình này là {\bf tuyến tính} vì mỗi số hạng chứa $t$, $f$ hoặc
$df/dt$ đều chỉ với bậc lũy thừa bằng một; nếu bất kì số hạng nào
có chứa tích các đại lượng trên hoặc các lũy thừa của $t$, $f$ và 
$df/dt$ thì phương trình sẽ là phi tuyến.

Các PVT bậc nhất, tuyến tính đều có thể giải được theo cách giải tích;
nghĩa là ta có thể biểu diễn nghiệm dưới dạng một hàm số của $t$.
Riêng PVT này có vô số nghiệm, nhưng tất cả nghiệm đó đều có chung
dạng sau:

\[ f(t) = b e^{at} \]
%
Với giá trị $b$ bất kì, hàm số này đều thỏa mãn PVT. Nếu bạn không 
tin điều này, hãy tự lấy đạo hàm và kiểm tra.

Nếu ta biết số vi khuẩn tại một thời điểm nhất định thì ta có thể dùng
thông tin nói trên để xác định trong số vô hạn các nghiệm, đâu là
nghiệm duy nhất thỏa mãn điều kiện trên để mô tả diễn biến của
số vi khuẩn thực tế theo thời gian.

Chẳng hạn, nếu đã biết rằng $f(0) = 5$ tỷ tế bào thì ta có thể viết:

\[ f(0) = 5 = b e^{a 0} \]
%
và giải tìm ra $b$ bằng 5. Từ đó ta tìm được hàm mong muốn:

\[ f(t) = 5 e^{at} \]
%
Thông tin thêm nói trên, vốn quyết định giá trị của $b$, được
gọi là {\bf điều kiện ban đầu} (cho dù không phải lúc nào nó
cũng được chỉ định tại $t=0$).

Không may là phần lớn các hệ vật lý thú vị đều được mô tả bởi
các phương trình vi phân phi tuyến, mà đa số đều không thể
giải được theo cách giải tích. Một cách khác là giải bằng phương pháp
số.


\section{Phương pháp Euler}

Phương pháp số đơn giản nhất để giải PVT là phương pháp Euler.
Sau đây là một bài kiểm tra nhỏ để xem bạn có thông minh được như
Euler không. Giả sử như ở thời điểm $t$ bạn đo được số vi khuẩn, 
$y$, và tốc độ tăng, $r$. Theo bạn thì số vi khuẩn sẽ là bao nhiêu
sau một thời gian $\Delta t$ trôi qua?

Nếu bạn nói rằng $y + r \Delta t$ thì xin chúc mừng! Bạn vừa 
phát minh ra phương pháp Euler (nhưng bạn vẫn chưa giỏi bằng Euler).

Cách ước tính này dựa trên giả sử rằng $r$ là hằng số, nhưng
nhình chung thì không phải vậy, do đó ta chỉ trông đợi là ước lượng
sẽ tốt nếu $r$ thay đổi từ từ và $\Delta t$ nhỏ.

Nhưng hãy (tạm) giả sử rằng PVT đang xét có thể được viết sao cho

\[ \frac{df}{dt}(t) = g(t, y) \]

\noindent trong đó $g$ là một hàm nào đó chiếu từ $(t, y)$ đến $r$; nghĩa là,
cho trước thời điểm và số vi khuẩn, hàm này sẽ tính tốc độ thay đổi.
Sau đó ta có thể tiến từ một thời điểm đến thời điểm tiếp theo bằng
các phương trình sau đây:

\begin{eqnarray}
\label{euler1}
T_{n+1} = T_n + \Delta t           \\
\label{euler2}
F_{n+1} = F_n + g(t,y)~\Delta t
\end{eqnarray}
%
Ở đây $\{T_i\}$ là một dãy các thời điểm mà tại đó ta cần tính các
giá trị của $f$, còn $\{F_i\}$ là một dãy các giá trị ước tính được. Với
mỗi chỉ số $i$, $F_i$ là một ước lượng của $f(T_i)$. Khoảng $\Delta t$
được gọi là {\bf bước thời gian}.

Giả sử rằng ta khởi đầu tại $t=0$ và có một điều kiện ban đầu
$f(0) = y_0$ (trong đó $y_0$ là một giá trị cụ thể đã biết); đặt
$T_1 = 0$ và $F_1 = y_0$, sau đó dùng các PT~\ref{euler1} 
và~\ref{euler2} để tính các giá trị của $T_i$ và $F_i$ đến khi $T_i$
nhận giá trị của $t$ mà ta quan tâm.

Nếu tốc độ tăng thay đổi không quá nhanh và bước thời gian không 
quá dài thì phương pháp Euler cũng đủ chính xác với nhiều mục đích
tính toán. Một cách kiểm tra là chạy nó lần đầu với bước thời gian 
$\Delta t$ và lần sau với bước thời gian $\Delta t/2$. Nếu các kết quả
như nhau, thì có lẽ kết quả là đúng; nếu không, hãy thử rút ngắn
bước thời gian một lần nữa.

Phương pháp Euler là {\bf bậc nhất}, nghĩa là mỗi lần bạn chia đôi
bước tính, bạn trông đợi sai số của giá trị ước tính sẽ giảm bớt 
một nửa. Với một phương pháp bậc hai, bạn trông đợi sai số giảm
đi 4 lần; với phương pháp bậc ba giảm 8 lần, v.v. Cái giá phải trả
cho phương pháp bậc cao là chúng phải lượng giá $g$ nhiều lần hơn
trong cùng một bước thời gian.


\section{Lưu ý thêm về cách viết}

Có rất nhiều kí hiệu toán học trong chương này, vì vậy tôi sẽ tạm dừng
ở đây để ôn lại những gì chúng ta đã học được đến giờ. Dưới đây là
các biến số, ý nghĩa, và kiểu của chúng:

\begin{tabular}{|l|l|l|}
\hline
Tên     &  Ý nghĩa             &  Kiểu  \\
\hline \hline
$t$     &  thời gian                 & biến vô hướng \\\hline
$\Delta t$  &  bước thời gian         & hằng vô hướng \\\hline

$y$     &  số cá thể           & biến vô hướng \\\hline
$r$     &  tốc độ thay đổi       & biến vô hướng \\\hline

$f$     &  Hàm chưa biết được chỉ định    &  hàm $t \to y$  \\
        &  dưới hình thức ẩn trong PVT.             &    \\\hline

$df/dt$  &  Đạo hàm bậc nhất theo thời gian của $f$  &  hàm $t \to r$  \\ \hline

$g$     &  ``Hàm tốc độ,'' được suy ra từ     &  \\
        &  PVT, để tính tốc độ thay đổi với     &  hàm $t, y \to r$  \\
        &  giá trị bất kì của $t$, $y$.           &   \\\hline

$T$     & một loạt các thời điểm, $t$, tại đó   & dãy \\
              & ta ước tính $f(t)$    &           \\\hline
$F$     & một loạt các giá trị ước tính của $f(t)$  & dãy \\
\hline
\end{tabular}

Như vậy $f$ là một hàm để tính số cá thể (vi trùng), có dạng một hàm
theo thời gian, $f(t)$ là giá trị của hàm được tính ở một thời điểm nhất định,
và nếu ta gán $f(t)$ cho một biến, ta thường gọi biến đó là $y$.

Tương tự, $g$ là một ``hàm tốc độ'' để tính tốc độ thay đổi dưới
hình thức một hàm phụ thuộc vào thời gian và số cá thể. Nếu ta gán
$g(t,y)$ cho một biến, ta thường gọi nó là $r$.

$df/dt$ là đạo hàm bậc nhất của $f$, nó chiếu từ $t$ đến một giá trị
tốc độ.  Nếu ta gán $df/dt(t)$ cho một biến, ta gọi nó là $r$.

Thường thì $df/dt$ rất dễ bị lẫn với $g$, nhưng lưu ý rằng cả về kiểu
chúng đã khác nhau rồi.  $g$ có tính khái quát hơn: nó có thể tính
được tốc độ thay đổi của bất kì số cá thể (giả định) nào tại thời điểm
bất kì; $df/dt$ thì cụ thể hơn: đó là tốc độ thay đổi thực sự tại thời
điểm $t$, khi biết số cá thể là $f(t)$.


\section{{\tt ode45}}
\label{ode45}

Một hạn chế của phương pháp Euler là bước thời gian không đổi qua
các lượt lặp khác nhau. Nhưng có những phần của lời giải lại khó
ước tính hơn phần khác; nếu bước thời gian đủ ngắn để giải được
phần khó thì cũng bước thời gian này sẽ khiến việc tính toán trở nên
quá nhiều đối với những phần dễ. Cách làm lý tưởng nhất là điều 
chỉnh bước thời gian trong khi giải. Các phương pháp như vậy được
gọi là {\bf thích ứng}, và một trong những phương pháp thích ứng
tốt nhất là phương pháp Dormand-Prince dùng cặp công thức 
Runge-Kutta. Bạn chưa cần biết chi tiết về công thức này, vì những
người phát triển Octave đã đưa nó vào một hàm có tên là 
{\tt ode45}.  Trong đó chữ {\tt ode} có nghĩa là ``ordinary differential
equation [solver];'' ([chương trình giải] PVT) còn số 45 là để chỉ
rằng đã dùng cách kết hợp các công thức bậc 4 và bậc 5.

Cần lưu ý rằng {\tt ode45} cũng như một số hàm khác để giải PVT 
không có sẵn trong Octave, mà trước hết bạn phải cài đặt gói 
\texttt{odepkg}. Hãy tìm cụm từ ``Octave odepkg'' trên mạng 
rồi tải về một tập tin có tên giống như \texttt{odepkg-0.8.0.tar.gz}.
Lưu tập tin này vào thư mục hiện thời và gõ lệnh sau tại dấu nhắc:

\begin{verbatim}
>> pkg install odepkg-0.8.0.tar.gz
\end{verbatim}

Quay trở lại bài toán, để dùng {\tt ode45}, bạn phải viết một hàm Octave để ước tính
$g$ như một hàm của $t$ và $y$.

% where did the rats example come from?

Sau đây là một ví dụ minh họa. Giả sử rằng tốc độ tăng trưởng của
chuột phụ thuộc vào số con chuột hiện thời và mức độ sẵn có của
thức ăn, vốn thay đổi theo thời gian trong năm.
Phương trình cơ bản sẽ có dạng

\[ \frac{df}{dt}(t) = a f(t) \left[1 + \sin (\omega t) \right] \]
%
trong đó $t$ là thời gian tính theo ngày và $f(t)$ là 
số con chuột tại thời điểm $t$.

$a$ và $\omega$ là các {\bf tham số}. Tham số là một giá trị 
đặc trưng cho một khía cạnh vật lý của hệ được mô phỏng. 
Chẳng hạn, ở Bài tập~\ref{duck} ta đã dùng các tham số {\tt rho} 
và {\tt r} để định lượng khối lượng riêng và bán kính của một
con vịt. Các tham số thường không đổi, nhưng cũng có thể
thay đổi theo thời gian trong một số mô hình.

Ở ví dụ này, $a$ đặc trưng cho tốc độ sinh sản, còn $\omega$
là tần số của một hàm tuần hoàn để mô tả ảnh hưởng của mức
độ cung cấp thức ăn đến sự sinh sản.

Phương trình này đặc trưng cho quan hệ giữa một hàm với
đạo hàm của nó. Để ước tính được các giá trị của $f$ bằng cách
số trị, ta phải chuyển nó về một hàm tốc độ.

Bước đầu tiên là giới thiệu một biến, $y$, là một tên gọi khác 
của $f(t)$

\[ \frac{df}{dt}(t) = a y \left[1 + \sin (\omega t) \right] \]
%
Phương trình này có nghĩa là nếu cho trước các giá trị $t$ và $y$, 
ta có thể tính $df/dt(t)$, vốn là tốc độ thay đổi của $f$. Bước
tiếp theo là biểu diễn phép tính đó đưới dạng một hàm gọi là $g$:

\[ g(t, y) = a y \left[1 + \sin (\omega t) \right] \]
%
Cách viết này rất có ích vì ta có thể dùng hàm với phương pháp
Euler hoặc {\tt ode45} để ước tính các giá trị của $f$. Tất cả những
việc ta cần làm chỉ là viết một hàm Octave để lượng giá $g$. 
Sau đây là mã lệnh ứng với các giá trị $a = 0.01$ và 
$\omega = 2 \pi/365$ (một chu kì mỗi năm):

\begin{verbatim}
function res = rats(t, y)
    a = 0.01;
    omega = 2 * pi / 365;
    res = a * y * (1 + sin(omega * t));
end
\end{verbatim}
%
Bạn có thể kiểm tra hàm này từ dấu nhắc lệnh bằng cách 
gọi nó với các giá trị khác nhau của {\tt t} và {\tt y}; kết quả sẽ là
tốc độ thay đổi (đơn vị là số chuột mỗi ngày):

\begin{verbatim}
>> r = rats(0, 2)
r = 0.020000
\end{verbatim}
%
Như vậy nếu có 2 con chuột vào ngày 1/1, ta sẽ trông đợi chúng
đẻ thêm với một tốc độ sao cho cứ 2 con chuột được sinh ra trong
vòng 100 ngày. Nhưng đến tháng 4, tốc độ này đã tăng gấp đôi:

\begin{verbatim}
>> r = rats(120, 2)
r = 0.037600
\end{verbatim}

Vì tốc độ tăng thì luôn thay đổi, nên không dễ dự đoán số con 
chuột trong tương lai; song đó chính là việc mà {\tt ode45} đảm nhiệm.
Sau đây là cách dùng nó:

\begin{verbatim}
>> ode45(@rats, [0, 365], 2)
\end{verbatim}
%
Đối số đầu tiên là chuôi của hàm để tính $g$. Đối số thứ hai là khoảng
thời gian mà ta quan tâm, ở đây là 1 năm. Đối số thứ ba là số con chuột
ban đầu, $f(0) = 2$.

Khi bạn gọi {\tt ode45} mà không gán kết quả cho một biến,
Octave sẽ biểu thị kết quả dưới dạng hình vẽ:

% % \beforefig 
\centerline{\includegraphics[height=2in]{figs/rats.eps}}

Trục $x$ chỉ thời gian từ 0 đến 365 ngày; trục $y$ chỉ số con chuột,
bắt đầu là 2 rồi tăng dần đến gần 80. Tốc độ tăng khá chậm vào 
mùa đông và mùa hè, và nhanh hơn vào mùa xuân và mùa thu,
đồng thời cũng tăng nhanh hơn khi số chuột nhiều lên.


\section{Nhiều biến đầu ra}
\label{rats}

{\tt ode45} chỉ là một trong số nhiều hàm Octave trả lại kết quả
dưới dạng nhiều biến. Cú pháp của lời gọi nó và lưu giữ kết quả là

\begin{verbatim}
>> [T, Y] = ode45(@rats, [0, 365], 2);
\end{verbatim}
%
Giá trị trả lại thứ nhất được gán cho {\tt T}; giá trị thứ hai được gán
cho {\tt Y}.  Mỗi phần tử của {\tt T} là một thời điểm $t$, mà 
tại đó {\tt ode45} ước tính số chuột; mỗi phần tử của {\tt Y} 
là một giá trị ước đoán của $f(t)$.

Nếu bạn gán các giá trị đầu ra cho biến, {\tt ode45} sẽ không 
vẽ hình; phạn phải tự làm điều đó:

\begin{verbatim}
>> plot(T, Y, 'bo-')
\end{verbatim}
%
Nếu vẽ đồ thị các phần tử của {\tt T}, bạn sẽ thấy rằng khoảng cách
giữa các điểm rất không bằng nhau. Ở đầu khoảng thời gian các điểm
sát nhau và về sau này thì tách rời ra.

Để biết được số chuột lúc cuối năm, bạn có thể hiển thị phần tử cuối
của mỗi véc-tơ:

\begin{verbatim}
>> [T(end), Y(end)]
ans = 365.000   76.949
\end{verbatim}
%
{\tt end} là một từ đặc biệt trong Octave; khi xuất hiện ở vị trí
một chỉ số, nó có nghĩa là ``chỉ số của phần tử cuối cùng.''  Bạn
có thể dùng nó trong một biểu thức, vì vậy {\tt Y(end-1)} là 
phần tử áp chót của {\tt Y}.

Số con chuột lúc cuối năm sẽ thay đổi bao nhiêu nếu bạn tăng
gấp đôi số chuột ban đầu? Nó sẽ thay đổi bao nhiêu nếu bạn 
tính đến thời gian sau hai năm? Và nếu bạn tăng $a$ gấp đôi?


\section{Giải tích hay số trị?}

Khi bạn giải PVT theo cách giải tích, kết quả là một hàm, $f$,
cho phép ta tính số cá thể, $f(t)$, với bất kì giá trị nào của
$t$.  Khi bạn giải PVT theo cách số trị, bạn nhận được hai véc-tơ.
Bạn có thể hình dung hai véc-tơ này như xấp xỉ của hàm $f$ 
có tính liên tục: ``rời rạc'' là bởi vì nó chỉ xác định với những
giá trị cụ thể của $t$, và ``xấp xỉ'' là vì mỗi giá trị $F_i$
chỉ là một ước đoán cho giá trị thật $f(t)$.

Trên đây là những hạn chế của nghiệm số trị. Còn ưu điểm chính
là bạn có thể tính nghiệm số trị cho cả những PVT mà không có
nghiệm giải tích, vốn chiếm phần lớn các PVT phi tuyến.

Nếu bạn còn tò mò về cơ chế hoạt động của {\tt ode45},
bạn có thể sửa {\tt rats} để hiển thị các điểm, $(t, y)$, 
tại đó {\tt ode45} được dùng để tính $g$. Sau đây là một
phiên bản đơn giản:

\begin{verbatim}
function res = rats(t, y)
    plot(t, y, 'bo')
    a = 0.01;
    omega = 2 * pi / 365;
    res = a * y * (1 + sin(omega * t));
end
\end{verbatim}
%
Mỗi lần {\tt rats} được gọi, nó chấm một điểm số liệu; để thấy 
được tất cả các điểm, bạn phải dùng {\tt hold on}.

\begin{verbatim}
>> clf; hold on
>> [T, Y] = ode45(@rats, [0, 10], 2);
\end{verbatim}
%
Hình vẽ này cho thấy một phần của kết quả đầu ra, được phóng to
trong khoảng những ngày từ 100 đến 170:

%% \beforefig 
\centerline{\includegraphics[height=2in]{figs/ode45.eps}}

Các vòng tròn cho thấy những điểm tại đó {\tt ode45} gọi đến 
{\tt rats}. Các đường thẳng đi qua vòng tròn cho thấy độ dốc
(tốc độ thay đổi) tính được ở mỗi điểm. Hình chữ nhật cho thấy
các vị trí được ước tính $(T_i, F_i)$.  Lưu ý rằng {\tt ode45}
thường lượng giá $g$ vài lần trong mỗi lần ước tính. Bằng cách
này, không những giá trị ước tính được cải thiện mà còn phát
hiện được những chỗ mà sai số đang tăng, tại đó cần rút ngắn
bước thời gian (hoặc ngược lại).


\section{Điều trục trặc gì có thể xảy ra?}

Đừng quên dấu {\tt @} ở chuôi của hàm. Nếu quên không viết nó,
Octave sẽ coi đối số thứ nhất như một lời gọi hàm, và sẽ gọi
{\tt rats} mà không cấp cho đối số nào.

\begin{verbatim}
>> ode45(rats, [0,365], 2)
error: `y' undefined near line 4 column 12
error: called from:
error:   C:\Users\owner\tencuaban\code\rats.m at line 4, column 6
error: evaluating argument list element number 1
error: evaluating argument list element number 1
\end{verbatim}
%
Một lần nữa, thông báo lỗi có vẻ rắc rối, bởi vì có vẻ như vấn đề
nảy sinh ở {\tt rats}.  Tôi đã bảo bạn cẩn thận rồi nhé!

Mặt khác, cũng cần nhớ rằng hàm bạn viết ra sẽ được gọi bởi
{\tt ode45}, nghĩa là nó phải có dấu của hàm mà {\tt ode45}
trông đợi: cụ thể là nhận vào hai biến, {\tt t} và {\tt y},
theo đúng thứ tự đó, và trả lại một biến đầu ra, {\tt r}.

Nếu bạn làm việc với một hàm tốc độ kiểu như:

\[ g(t, y) = a y \]
%
thì bạn có thể đã muốn viết như sau:

\begin{verbatim}
function res = rate_func(y)        % SAI
    a = 0.1
    res = a * y
end
\end{verbatim}
%
Nhưng cách làm này sai. Tại sao? Vì khi {\tt ode45} gọi đến
\verb#rate_func#, nó cấp cho hai đối số. Nếu bạn chỉ lấy có
một biến đầu vào, bạn sẽ nhận được lỗi. Vì vậy bạn phải viết
một hàm nhận cả {\tt t} làm biến đầu vào, ngay cả khi bạn
không dùng đến nó.

\begin{verbatim}
function res = rate_func(t, y)     % DU'NG
    a = 0.1
    res = a * y
end
\end{verbatim}

Một lỗi thường gặp khác là việc viết một hàm mà không gán
kết quả cho một biến đầu ra. Nếu bạn viết lệnh kiểu như:

\begin{verbatim}
function res = rats(t, y)
    a = 0.01;
    omega = 2 * pi / 365;
    r = a * y * (1 + sin(omega * t))    % SAI
end
\end{verbatim}
%
rồi gọi nó từ {\tt ode45}, bạn sẽ nhận được

\begin{verbatim}
>> ode45(@rats, [0,365], 2)
warning: rats: some elements in list of return values are undefined
error: A(I,J,...) = X: dimensions mismatch
error: called from:
error:   C:\Octave\3.2.4_gcc-4.4.0\share\octave\packages\odepkg-0.8.0\ode45.m at
 line 345, column 17
\end{verbatim}
%
Thông báo này có thể gây lẫn vì nói đến lỗi kích thước ma trận không
khớp, nhưng thực ra vấn nằm ở dòng cảnh báo: một số phần tử trong
danh sách giá trị trả về chưa được định nghĩa. (Thật ra là toàn bộ 
véc-tơ trả về, \texttt{res}, không được định nghĩa!)

Một lỗi khác mà có thể mắc phải khi dùng {\tt ode45} là 
quên mất cặp ngoặc vuông ở đối số thứ hai. Trong trường hợp đó,
Octave sẽ nghĩ rằng có bốn đối số, và bạn nhận được

\begin{verbatim}
>> ode45(@rats, 0, 365, 2)
error: Second input argument must be a valid vector
error: called from:
error:   C:\Octave\3.2.4_gcc-4.4.0\share\octave\packages\odepkg-0.8.0\ode45.m at
 line 66, column 5
\end{verbatim}
%
Một lần nữa, nếu đọc dòng thứ nhất, bạn có thể hình dung ra
được vấn đề: đối số thứ hai (khoảng thời gian thực hiện tính toán)
phải là một véc-tơ.


\section{Độ cứng}

Còn một vấn đề khác mà bạn có thể đối mặt, song bạn có thể thấy
nhẹ nhõm hơn khi biết rằng điều này không phải lỗi của bạn: bài toán bạn
đang giải có thể thuộc loại {\bf cứng}\footnote{Nội dung trình bày
sau đây một phần được dựa trên bài báo đăng bởi Mathworks tại
\url{http://www.mathworks.com/company/newsletters/news_notes/clevescorner/may03_cleve.html}}.
\footnote{Trong mục này có dùng hàm \texttt{ode23s} chỉ có trong
MatLab mà chưa xuất hiện ở Octave. Bạn đọc có thể đọc thêm cách
dùng hàm \texttt{lsode} để thay thế.}

Tôi sẽ không trình bày về khía cạnh kĩ thuật liên quan đến độ cứng 
ở đây, ngoại trừ phải nói rằng với một số bài toán (ở những khoảng
thời gian nào đó và điều kiện ban đầu nào đó) thì bước thời gian cần thiết
để kiểm soát sai số là rất ngắn; điều đó nghĩa là thời gian tính toán
sẽ rất lâu. Sau đây là một ví dụ:

\[ \frac{df}{dt} = f^2 - f^3 \]

Nếu bạn giải PVT với điều kiện ban đầu  $f(0) = \delta$ trên khoảng
từ 0 đến $2/\delta$, với $\delta = \text{0,01}$, bạn sẽ thấy kết quả sau:

%% \beforefig 
\centerline{\includegraphics[height=2in]{figs/stiff.eps}}

Sau bước chuyển dần từ 0 tới 1, bước thời gian trở nên rất ngắn
và việc tính toán rất chậm. Với những giá trị nhỏ hơn của $\delta$, 
tình hình còn tệ hơn.
% phải tìm hiểu thêm xem có thể giải được trong octave ko.
Trong trường hợp này, vấn đề khá dễ khắc phục: thay vì {\tt ode45}
bạn có thể dùng {\tt ode23s}, một hàm giải PVT với xu hướng 
hoạt động tốt với bài toán có tính cứng (stiff) (cũng vì vậy mà có
chữ ``s'' trong tên gọi của hàm).

Nói chung, nếu thấy hàm {\tt ode45} tính rất lâu thì bạn có thể
thử chuyển sang dùng một trong số các hàm giải cho hệ cứng.
Tôi không thường xuyên gặp vấn đề như vậy, nhưng nếu bài toán
có tính cứng thì sự cải thiện về thời gian giải cỏ vẻ là đáng kể.

\begin{ex}
Hãy viết một hàm tốc độ cho PVT này rồi dùng {\tt ode45}
để giải với điều kiện ban đầu và khoảng tính cho trước.
Bắt đầu với $\delta = $ 0,1 và giảm dần nó theo 10 lần. Nếu
quá mệt mỏi chờ đợi phép tính thực hiện chưa xong, bạn có thể
ấn nút Stop ở cửa sổ Figure hoặc ấn Control-C từ dấu nhắc lệnh.

Bây giờ hãy thay thế {\tt ode45} bằng {\tt ode23s} và thử lại!
\end{ex}



\section{Thuật ngữ}

\begin{description}

\item[phương trình vi phân:] Phương trình liên hệ các đạo hàm
của một hàm số chưa biết.

\item[phương trình vi phân thường:] Phương trình vi phân thường mà
tất cả đạo hàm được lấy theo cùng một biến.

\item[phương trình vi phân riêng:] Phương trình vi phân có bao gồm các
đạo hàm lấy theo nhiều biến.

\item[bậc nhất (PVT):] Phương trình vi phân chỉ chứa các đạo hàm bậc nhất.

\item[tuyến tính:] Phương trình vi phân không có chứa tích hoặc lũy thừa
của hàm cùng các đạo hàm của nó.

\item[bước thời gian:] Khoảng thời gian giữa hai lần ước tính kế tiếp trong
lời giải số trị của một phương trình vi phân.

\item[bậc nhất (phương pháp số):] Phương pháp theo đó sai số xấp xỉ
được trông đợi sẽ giảm đi một nửa khi bước tính được rút ngắn còn một nửa.

\item[thích ứng:] Phương thức có thể điều chỉnh được bước thời gian để
kiểm soát sai số.

\item[độ cứng:] Đặc trưng của PVT khiến cho một số hàm giải PVT chạy
rất chậm (hoặc tính ra kết quả không chính xác). Một số hàm giải PVT
như {\tt ode23s}, được thiết kế để giải các bài toán có độ cứng.

\item[tham số:] Giá trị xuất hiện trong mô hình nhằm định lượng một khía
cạnh vật lý nào đó của hệ được mô phỏng.

\end{description}

\section{Bài tập}

\newcommand{\degree}{\ensuremath{^\circ}}

\begin{ex}
Giả sử rằng bạn có tách chứa 8 ounce cà-phê nóng 90 \degree C và
1 ounce kem ở nhiệt độ phòng, 20 \degree C. Bạn biết qua một 
kinh nghiệm cay đắng là chỉ uống được cà-phê nóng nhất ở mức
60 \degree C.

Lưu ý rằng bạn cho kem vào tách cà-phê, và muốn uống càng sớm
càng tốt, thì liệu có nên cho kem vào ngay không, hay đợi một lúc?
Và nếu cần đợi, thì nên đợi bao lâu?

Để trả lời câu hỏi này, bạn phải mô phỏng quá trình nguội lạnh của
nước nóng trong không khí. Cà-phê nóng truyền nhiệt ra ngoài 
môi trường bằng quá trình đối lưu, bức xạ, và bốc hơi. Việc định
lượng từng hiệu ứng nói trên sẽ rất khó và cũng không cần thiết
cho việc giải bài toán này.

Để đơn giản hóa, ta có thể dùng Định luật Newton về làm lạnh
\footnote{\url{http://en.wikipedia.org/wiki/Heat_conduction}}:

\[ \frac{df}{dt} = -r (f - e) \]
%
trong đó $f$ là nhiệt độ cà-phê, được viết theo hàm của thời gian
còn $df/dt$ là đạo hàm theo thời gian của nó; $e$ là nhiệt độ
môi trường, bằng hằng số trong trường hợp này, và $r$ là một
thông số (cũng không đổi) để đặc trưng cho tốc độ truyền nhiệt.

Sẽ dễ ước tính $r$ cho một tách cà phê cụ thể bằng cách đo 
nhiệt độ vài lần theo thời gian. Ta hãy giả sử rằng điều đó đã
được thực hiện và $r$ đã tính được bằng $0.001$ với đơn vị là
nghịch đảo của giây, $1/s$.

\begin{itemize}

\item Hãy dùng kí hiệu toán học để biểu diễn hàm tốc độ, $g$,
dưới dạng hàm của $y$, trong đó $y$ là nhiệt độ của cà-phê
tại thời điểm bất kì.

\item Tạo ra tập tin M có tên {\tt coffee} và viết một hàm có tên
{\tt coffee} nhận vào hai biến và không trả lại giá trị đầu ra.
Hãy đặt lệnh đơn giản như {\tt x=5} vào trong phần thân hàm
rồi gọi  {\tt coffee()} từ dấu nhắc lệnh.

\item Bổ sung một hàm có tên \verb#rate_func# nhận vào 
{\tt t} và {\tt y} rồi tính $g(t,y)$.  Lưu ý rằng trong trường hợp này 
$g$ thực ra không phụ thuộc vào $t$; song dù sao hàm cần viết
vẫn phải nhận vào $t$ làm đối số đầu tiên để có thể dùng được 
{\tt ode45}.

Hãy thử hàm vừa viết được bằng cách thêm một dòng lệnh như 
\verb#rate_func(0,90)# vào trong {\tt coffee}, 
rồi gọi {\tt coffee} từ dấu nhắc lệnh.

\item Một khi \verb#rate_func(0,90)# chạy được, hãy sửa
{\tt coffee} để dùng {\tt ode45} tính nhiệt độ của cà-phê không (chưa tính
đến kem) trong vòng 60 phút. Hãy chắc rằng cà-phê ban đầu
nguội nhanh, rồi chậm dần, cuối cùng thì tiến gần về và đạt (xấp xỉ)
nhiệt độ phòng sau khoảng 1 giờ.

\item Hãy viết một hàm có tên \verb#mix_func# để tính nhiệt độ 
nhiệt độ cuối cùng của hỗn hợp hai chất lỏng. Hàm phải nhận vào
các tham số là thể tích và nhiệt độ của từng loại chất lỏng.

Nói chung nhiệt độ của một hỗn hợp thì phụ thuộc vào nhiệt dung
riêng của hai chất\footnote{\url{http://en.wikipedia.org/wiki/Heat_capacity}}.
Nhưng nếu làm đơn giản bằng cách giả sử rằng cà-phê và kem có
cùng khối lượng riêng và nhiệt dung riêng thì nhiệt độ cuối cùng là
$(v_1 y_1 + v_2 y_2) / (v_1 + v_2)$, trong đó $v_1$ và $v_2$ là
các thể tích của hai loại chất lỏng, và $y_1$ và $y_2$ là nhiệt độ của chúng.

Hãy thêm mã lệnh vào trong {\tt coffee} để thử nghiệm hàm 
\verb#mix_func# vừa viết.

\item Hãy dùng \verb#mix_func# và {\tt ode45} để tính thời điểm
bắt đầu lúc uống được cà-phê, trong trường hợp rót kem vào ngay.

\item Hãy thay đổi {\tt coffee} để nó nhận vào biến $t$ (có vai trò
quyết định sau bao nhiêu giây cà-phê được để nguội trước khi rót kem
vào), và trả lại nhiệt độ của tách cà-phê sau khi trộn.

\item Hãy dùng {\tt fzero} tính thời gian $t$ cần để nhiệt độ của
tách cà-phê sau khi trộn hạ xuống còn 60 \degree C.

\item Những kết quả trên sẽ cho bạn biết gì về đáp số của bài toán
ban đầu? Có phải đó là đáp số như mong muốn không? Những
giả thiết nhằm giản hóa nào đã chi phối lời giải này? Theo bạn thì
giả thiết nào có ảnh hưởng đáng kể nhất? Bạn có nghĩ rằng ảnh
hưởng này đủ mạnh để tác độ đến kết quả không? Xét toàn diện
thì bạn tin tưởng đến mức nào vào việc mô hình này sẽ cho ra 
đáp số cuối cùng? Bạn có thể làm gì để cải thiện mô hình?

\end{itemize}

\end{ex}


% chap09
\chapter{Hệ các PVT}

\section{Ma trận}

Ma trận là dạng hai chiều của một véc-tơ. Cũng như véc-tơ, ma trận
gồm có các phần tử được phân biệt bởi chỉ số. Sự khác biệt với
véc-tơ là ở chỗ các phần tử ma trận được xếp theo hàng và cột, 
vì vậy cần có {\em hai} chỉ số để xác định được một phần tử.

Một trong những cách tạo ra ma trận là dùng hàm {\tt magic},
vốn trả lại một ma trận kì ảo với kích cỡ cho trước:

\begin{verbatim}
>> M = magic(3)

M =  8     1     6
     3     5     7
     4     9     2
\end{verbatim}
%
Nếu không biết kích cỡ của ma trận, bạn có thể dùng {\tt whos} 
để hiển thị nó:

\begin{verbatim}
>> whos
  Attr Name        Size                     Bytes  Class
  ==== ====        ====                     =====  =====
       M           3x3                         72  double
\end{verbatim}
%
Hoặc dùng hàm {\tt size}, lần này sẽ trả về một véc-tơ:

\begin{verbatim}
>> V = size(M)

V = 3     3
\end{verbatim}
%
Phần tử đầu tiên của véc-tơ là số hàng, và phần tử thứ hai là số cột.

Để đọc một phần tử của ma trận, bạn cần chỉ ra số thứ tự hàng và cột:

\begin{verbatim}
>> M(1,2)
ans = 1

>> M(2,1)
ans = 3
\end{verbatim}
%
Khi bắt đầu làm quen với ma trận, bạn cần nhớ được chỉ số nào
đi trước, hàng hay cột. Tôi thì thường nói nhẩm ``hàng, cột'',
như một câu thần chú. Bạn cũng có thể nhớ kiểu 
``xuống dưới, sang ngang,'' hoặc chữ tắt HC.

Một cách khách để tạo ra ma trận là viết các phần tử giữa cặp
ngoặc vuông, cùng dấu chấm phẩy giữa các hàng:

\begin{verbatim}
>> D = [1,2,3 ; 4,5,6]

D =  1     2     3
     4     5     6

>> size(D)

ans = 2     3
\end{verbatim}
%

\section{Véc-tơ hàng và cột}

Mặc dù có thể dễ nhớ hơn theo các loại số vô hướng, véc-tơ và ma trận,
song theo quan điểm của Octave, mọi thứ đều là ma trận. Một số 
vô hướng chính là một ma trận có một hàng và một cột:

\begin{verbatim}
>> x = 5;
>> size(x)

ans = 1     1
\end{verbatim}
%
Và véc-tơ là ma trận có một hàng:

\begin{verbatim}
>> R = 1:5;
>> size(R)

ans = 1     5
\end{verbatim}
%
Thực ra có hai loại véc-tơ. Loại véc-tơ ta đã gặp cho đến giờ là 
{\bf véc-tơ hàng}, vì các phần tử được sắp trên một hàng; còn
loại kia là {\bf véc-tơ cột}, vì các phần tử xếp theo một cột.

Một cách tạo ra véc-tơ cột là lập một ma trận chỉ với một phần tử
trên mỗi hàng:

\begin{verbatim}
>> C = [1;2;3]

C =

     1
     2
     3

>> size(C)

ans = 3     1
\end{verbatim}
%
Sự khác biệt giữa véc-tơ hàng và cột là quan trọng trong môn
đại số tuyến tính, nhưng với đa số các phép tính với véc-tơ thì
điều đó chẳng quan trọng. Khi bạn đánh chỉ số cho véc-tơ, bạn
không cần biết đó là loại véc-tơ gì:

\begin{verbatim}
>> R(2)
ans = 2

>> C(2)
ans = 2
\end{verbatim}



\section{Toán tử chuyển vị}

Toán tử chuyển vị, vốn trông giống như dấu nháy đơn, được dùng để
tính {\bf chuyển vị} của ma trận, vốn là một ma trận mới có tất cả
những phần tử của ma trận ban đầu, nhưng với mỗi hàng được
dựng thành một cột (hoặc bạn có thể nghĩ ngược lại).

Ở ví dụ sau:

\begin{verbatim}
>> D = [1,2,3 ; 4,5,6]

D =  1     2     3
     4     5     6
\end{verbatim}
%
{\tt D} có hai hàng, vì vậy ma trận chuyển vị của nó có
hai cột:

\begin{verbatim}
>> Dt = D'

Dt = 1     4
     2     5
     3     6
\end{verbatim}
%
\begin{ex}
Toán tử chuyển vị có tác động gì đến véc-tơ hàng, véc-tơ cột, và
số vô hướng?
\end{ex}


\section{Lotka-Volterra}
\label{lotka}

Mô hình Lotka-Volterra mô tả sự tương tác giữa hai loài, vật săn và con
mồi, trong cùng một hệ sinh thái. Một ví dụ là hai loài thỏ và cáo.

Mô hình được diễn tả bởi hệ phương trình vi phân sau:

\begin{eqnarray*}
R_t = a R - b R F \\
F_t = e b R F - c F
\end{eqnarray*}
%
trong đó
%
\begin{itemize}
%
\item $R$ là số con thỏ,
\item $F$ là số con cáo,
\item $a$ là tốc độ tăng trưởng của thỏ khi không có loài săn đuổi,
\item $c$ là tốc độ chết của cáo khi không có mồi,
\item $b$ là tốc độ chết của thỏ ứng với mỗi tương tác với cáo,
\item $e$ là hiệu suất biến đổi số thỏ bị ăn thịt thành cáo.
%
\end{itemize}

Thoạt nhìn, bạn có thể nghĩ rằng có thể giải ngay các phương trình
bằng cách gọi {\tt ode45} một lần để giải ra $R$ như một hàm theo
thời gian và một lần khác để giải $F$. Vấn đề là mỗi phương trình
đều chứa đến cả hai biến, cũng vì lý do này mà ta gọi là  
{\bf hệ phương trình} chứ không phải là một loạt các phương trình
riêng lẻ. Để giải một hệ, bạn cần phải giải tất cả phương trình
cùng lúc.

Thật may là {\tt ode45} có thể giải được hệ phương trình. Sự
khác biệt ở đây là điều kiện ban đầu có dạng một véc-tơ chứa
những giá trị ban đầu là $R(0)$ và $F(0)$, và kết quả đầu ra là
ma trận có chứa một cột dành cho $R$ và một cột cho $F$.

Sau đây là các hàm tốc độ được viết với các tham số
$a = 0.1$, $b = 0.01$, $c = 0.1$ and $e = 0.2$:

\begin{verbatim}
function res = lotka(t, V)
    % thao go cac phan tu cua V
    r = V(1);
    f = V(2);

    % dat cac tham so
    a = 0.1;
    b = 0.01;
    c = 0.1;
    e = 0.2;
    
    % tinh cac dao ham
    drdt = a*r - b*r*f;
    dfdt = e*b*r*f - c*f;
    
    % xep cac gia tri dao ham vao vec-to
    res = [drdt; dfdt];
end
\end{verbatim}
%
Như thường lệ, biến đầu vào thứ nhất là thời gian. 
Biến đầu vào thứ hai là một véc-tơ {\tt V} gồm hai phần tử,
$R(t)$ và $F(t)$. Tôi viết nó bằng chữ in để dễ gợi nhớ
rằng đó là véc-tơ. Phần thân hàm gồm bốn {\bf đoạn},
mỗi đoạn đều được chú thích kèm theo.

Đoạn thử nhất nhằm {\bf tháo gỡ} véc-tơ bằng cách sao chép
các phần tử ra các biến vô hướng. Điều này không nhất thiết phải làm,
nhưng việc đặt tên cho từng giá trị giúp tôi nhớ được ý nghĩa của chúng.
Nó cũng giúp ích ở đoạn thứ ba, khi ta tính đạo hàm, thể hiện ở 
cách viết giống như biểu thức toán học ban đầu, góp phần tránh được lỗi.

Đoạn thứ hai đặt các tham số miêu tả các tốc độ sinh sản của
thỏ và cáo, cùng với các đặc trưng tương tác giữa chúng. Nếu ta
đang nghiên cứu một hệ thực sự, thì những giá trị trên sẽ phải 
được rút ra từ quá trình quan sát đời sống của loài vật; nhưng ở
ví dụ này tôi chỉ chọn các giá trị sao cho thu được kết quả thú vị.

Đoạn cuối cùng {\bf gói} các đạo hàm tính được trở lại vào véc-tơ.
Khi {\tt ode45} gọi hàm này, nó cung cấp đầu vào là một véc-tơ
và trông đợi đầu ra cũng là một véc-tơ.

Bạn đọc tinh mắt có thể nhận ra có điểm khác biệt ở dòng:

\begin{verbatim}
    res = [drdt; dfdt];
\end{verbatim}

Dấu chấm phẩy ngăn cách giữa hai phần tử của véc-tơ này không có gì sai.
Nó rất cần trong trường hợp này vì {\tt ode45} yêu cầu kết quả của hàm
này phải là một véc-tơ cột.

Bây giờ ta có thể chạy {\tt ode45} như sau:

\begin{verbatim}
ode45(@lotka, [0, 365], [100, 10])
\end{verbatim}
%
Như thường lệ, thông số thứ nhất là một chuôi hàm, thứ hai là 
khoảng thời gian, và thứ ba là điều kiện ban đầu. Ở đây, điều kiện
ban đầu là một véc-tơ: phần tử thứ nhất là số con thỏ lúc 
$t=0$, phần tử thứ hai là số con cáo.

Thứ tự của hai phần tử này (số thỏ và số cáo) là tùy vào bạn, nhưng
phải thống nhất. Nghĩa là điều kiện ban đầu được cung cấp khi gọi
đến {\tt ode45} phải có cùng thứ tự như trong {\tt lotka}, 
nơi bạn gỡ véc-tơ đầu vào và gói lại véc-tơ đầu ra. 
Octave không hiểu ý nghĩa các giá trị này; tất cả sự theo dõi đều là
trách nhiệm của người lập trình.

Nhưng nếu bạn xếp đúng thứ tự thì kết quả sẽ được như sau:

% % \beforefig 
\centerline{\includegraphics[height=2in]{figs/lotka.eps}}

Trục $x$ là thời gian tính theo ngày; trục $y$ là số cá thể. 
Đường cong phía trên chỉ số thỏ; đường phía dưới chỉ số cáo.
Kết quả này là một trong số những dạng mẫu mà hệ này
có thể rơi vào, tùy theo các điều kiện ban đầu và các tham số.
Bạn hãy tự thử nghiệm với các giá trị khác nhau, như một
bài tập cho riêng mình.


%\section{Điều gì có thể gây trục trặc?} 
%
%Véc-tơ đầu ra của hàm tốc độ phải là một véc-tơ cột; 
%nếu không bạn sẽ nhận được --- Octave ko có lỗi này
%
%\begin{verbatim}
%??? Error using ==> funfun/private/odearguments
%LOTKA must return a column vector.
%
%Error in ==> ode45 at 173
%[neq, tspan, ntspan, next, t0, tfinal, tdir, y0, f0, odeArgs,
%odeFcn, ...
%\end{verbatim}
%%
%vốn là một lời thông báo lỗi khá rõ ràng. Chỉ có điều là {\em tại sao}
%phải cần một véc-tơ cột, song đó không phải là điều mà ta quan tâm.

Bạn phải cẩn thận đảm bảo đúng thứ tự của các phần tử
trong số các điều kiện ban đầu, và các véc-tơ bên trong {\tt lotka}. 
Một lần nữa, Octave không biết rằng các phần tử có ý nghĩa gì, cho
nên nó không thể phát hiện ra lỗi kiểu này, mà chỉ cho kết quả sai.



\section{Ma trận kết quả}

Như ta đã thấy ở trên, nếu bạn gọi {\tt ode45} mà không gán kết quả
vào biến thì nó sẽ vẽ đồ thị kết quả đó. Nếu gán kết quả vào biến
thì việc làm này sẽ ngăn cản việc hiển thị hình vẽ. Câu lệnh cụ thể
như sau:

\begin{verbatim}
>> [T, M] = ode45(@lotka, [0, 365], [100, 10]);
\end{verbatim}
%
Bạn có thể hình dung vế trái của lệnh gán này như một véc-tơ chứa
các biến.

Cũng như trong các ví dụ trước, {\tt T} là véc-tơ chứa các giá trị 
thời điểm mà tại đó {\tt ode45} thực hiện việc ước tính. Nhưng khác
với các ví dụ trước, biến đầu ra thứ hai là một ma trận chứa một cột
cho mỗi biến (trong trường hợp này là $R$ và $F$) và một hàng
cho mỗi giá trị thời gian.

\begin{verbatim}
>> size(M)

ans = 178     2
\end{verbatim}
%
Cấu trúc này---một cột cho mỗi biến---là cách thông thường để
dùng ma trận. {\tt plot} hiểu được cấu trúc này, nên khi bạn viết:

\begin{verbatim}
>> plot(T, M)
\end{verbatim}
%
Octave sẽ hiểu rằng nó cần vẽ đồ thị cho mỗi cột của {\tt M}
theo {\tt T}.

Bạn có thể sao chép các cột của {\tt M} ra các biến khác như sau:

\begin{verbatim}
>> R = M(:, 1);
>> F = M(:, 2);
\end{verbatim}
%
Ở đây, dấu hai chấm biểu thị cho khoảng từ 1 đến {\tt end},
vì vậy {\tt M(:, 1)} nghĩa là ``tất cả các hàng thuộc cột 1'' và
{\tt M(:, 2)} nghĩa là ``tất cả các hàng thuộc cột 2.''

\begin{verbatim}
>> size(R)

ans = 178     1

>> size(F)

ans = 178     1
\end{verbatim}
%
Như vậy {\tt R} và {\tt F} là các véc-tơ cột.

Nếu vẽ đồ thị các véc-tơ này theo nhau, kiểu như:

\begin{verbatim}
>> plot(R, F)
\end{verbatim}
%
thì bạn sẽ thu được một {\bf đồ thị pha} giống hình dưới đây:

% % \beforefig 
\centerline{\includegraphics[height=2in]{figs/phase.eps}}

Mỗi điểm trên đồ thị này biểu diễn một số thỏ nhất định (theo trục $x$)
và một số cáo nhất định (theo trục $y$).

Vì chỉ có hai biến trong hệ này, mỗi điểm trên mặt phẳng biểu thị
cho {\bf trạng thái đầy đủ} của hệ.

Theo thời gian, trạng thái sẽ di chuyển quanh mặt phẳng: hình vẽ
này cho thấy đường đi vạch nên bởi trạng thái trong khoảng thời
gian tính toán. Đường đi này được gọi là {\bf quỹ đạo}.

Vì biểu hiện của hệ thống này có tính chu kì nên quỹ đạo thu được
là một đường cong khép kín.

Nếu có 3 biến trong hệ, ta sẽ cần 3 chiều không gian để biểu thị
trạng thái của hệ, vì vậy quỹ đạo là một đường cong 3 chiều. Bạn
có thể dùng {\tt plot3} để vạch nên đường quỹ đạo trong không gian
3 chiều, nhưng khi có từ 4 biến trở lên thì bạn chẳng còn cách
biểu thị trực quan nào nữa.


\section{Thuật ngữ}

\begin{description}

\item[véc-tơ hàng:] Trong Octave, một ma trận chỉ có một hàng.

\item[véc-tơ cột:] Một ma trận chỉ có một cột. 

\item[chuyển vị:] Phép tính để chuyển các hàng của ma trận thành
cột (hoặc ngược lại).

\item[hệ phương trình:] Tập hợp các phương trình chứa một tập hợp
các biến sao cho các phương trình liên hệ qua lại lẫn nhau.

\item[đoạn:] Một loạt các lệnh liên tiếp hình thành nên một phần của
hàm, thường được kèm theo bởi một lời giải thích rõ ràng.

\item[tháo gỡ:] Sao chép các phần tử trong một véc-tơ vào một 
tập hợp các biến.

\item[đóng gói:] Sao chép các giá trị từ một tập hợp các biến vào
một véc-tơ.

\item[trạng thái:] Nếu một hệ có thể được miêu tả bởi một tập hợp 
các biến thì giá trị của các biến đó được gọi là trạng thái của hệ.

\item[đồ thị pha:] Đồ thị cho thấy trạng thái của hệ như một điểm
trên không gian các trạng thái hiện có.

\item[quỹ đạo:] Đường đi của đồ thị pha cho thấy trạng thái của
một hệ thay đổi như thế nào theo thời gian.


\end{description}

\section{Bài tập}

\begin{ex}

Dựa vào các ví dụ ta đã thấy, bạn có thể nghĩ rằng tất cả PVT
mô tả số cá thể đều có dạng hàm theo thời gian, nhưng thực ra
không phải vậy.

Theo Wikipedia\footnote{\url{http://en.wikipedia.org/wiki/Lorenz_attractor}},
``điểm hấp dẫn Lorenz, được Edward Lorenz đề xuất vào năm 1963, là
một hệ động lực tất định ba chiều phi tuyến được suy từ các phương trình
giản hóa đặc trưng cho các cuộn đối lưu từ phương trình động lực khí quyển.
Với một tập hợp nhất định các tham số, hệ thống sẽ có biểu hiện hỗn loạn
và cho thấy cái mà ngày nay ta gọi là điểm hấp dẫn dị thường...''

Hệ được mô tả bởi hệ phương trình vi phân sau:
%
\begin{eqnarray}
x_t &=& \sigma (y - x)  \\
y_t &=& x (r - z) - y   \\
z_t &=& xy - b z
\end{eqnarray}
%
Các giá trị thông dụng của tham số gồm $\sigma = 10$, $b = 8/3$ và $r=28$.

Hãy dùng {\tt ode45} để ước tính một nghiệm của hệ phương trình này.


\begin{enumerate}

\item Bước đầu tiên là viết một hàm có tên là {\tt lorenz} nhận 
{\tt t} và {\tt V} làm các biến đầu vào, trong đó các thành phần 
của {\tt V} được hiểu là các giá trị hiện thời của {\tt x},
{\tt y} và {\tt z}. Nó cần phải tính được các đạo hàm tương ứng
và trả chúng về dưới dạng một véc-tơ cột.

\item Bước tiếp theo là thử nghiệm hàm của bạn bằng cách gọi nó
từ dòng lệnh với các giá trị như 
$t=0$, $x=1$, $y=2$ và $z=3$. Một khi hàm chạy được, bạn cần
biến nó thành một hàm lặng trước khi gọi {\tt ode45}.

\item Giả định rằng Bước 2 đã xong, bạn có thể dùng {\tt ode45}
để ước tính nghiệm cho khoảng thời gian từ $t_0 = 0$ đến $t_e = 30$
với điều kiện ban đầu $x=1$, $y=2$ và $z=3$.

\item Hãy dùng {\tt plot3} để vẽ đồ thị quỹ đạo theo 
$x$, $y$ và $z$.

\end{enumerate}

\end{ex}


% chap10
\chapter{Các hệ bậc hai}


\section{Hàm lồng ghép}

Trong Mục~\ref{funfiles}, ta đã thấy một ví dụ của tập tin M với
hơn một hàm:

\begin{verbatim}
function res = duck()
    error = error_func(10)
end

function res = error_func(h)
    rho = 0.3;      % density in g / cm^3
    r = 10;         % radius in cm
    res = ...
end
\end{verbatim}
%
Vì hàm thứ nhất kết thúc trước hàm thứ hai, chúng có cùng cấp
thụt đầu dòng. Những hàm như vậy được gọi là 
{\bf song song}, trái với {\bf lồng ghép}. Một hàm lồng ghép
được định nghĩa ở bên trong hàm khác, kiểu như:

\begin{verbatim}
function res = duck()
    error = error_func(10)

    function res = error_func(h)
        rho = 0.3;      % density in g / cm^3
        r = 10;         % radius in cm
        res = ...
    end
end
\end{verbatim}
%
Hàm cấp cao nhất, {\tt duck}, là 
{\bf hàm ngoài} và \verb#error_func# là
{\bf hàm trong}.

Các hàm lồng ghép rất có ích vì các biến của hàm ngoài có thể
truy cập đến từ hàm trong. Điều này không thực hiện được với
các hàm song song.

Ở ví dụ này, việc dùng hàm lồng ghép khiến cho ta có thể chuyển
các tham số {\tt rho} và {\tt r} ra ngoài \verb#error_func#.

\begin{verbatim}
function res = duck(rho)
    r = 10;
    error = error_func(10)

    function res = error_func(h)
        res = ...
    end
end
\end{verbatim}
%
Cả {\tt rho} và {\tt r} đều có thể truy cập đến từ 
\verb#error_func#. Bằng cách biến {\tt rho} trở thành đối số
đầu vào, ta đã khiến việc thử nghiệm {\tt duck} với các giá
trị tham số khác nhau được dễ dàng hơn.



\section{Chuyển động Newton}

Định luật II Newton về chuyển động thường được viết như sau

\[ F = ma \]
%
trong đó $F$ là hợp lực tác dụng lên một vật, $m$ là khối lượng của
vật, còn $a$ là gia tốc mà vật thu được. Chỉ trong trường hợp đơn giản
khi vật chuyển động theo đường thẳng thì cả $F$ và $a$ đều là 
số vô hướng, nhưng nhìn chung chúng là véc-tơ.

Thậm chí khái quát hơn nữa, nếu $F$ và $a$ thay đổi theo thời gian
thì chúng là một hàm và kết quả của việc lượng giá $F(t)$ là một
véc-tơ mô tả hợp lực tại thời điểm $t$. Như vậy một cách viết 
tường minh hơn định luật Newton là

\[ \forall t: \vec{F}(t) = m \vec{a}(t) \]
%
Thứ tự sắp xếp của phương trình này cho thấy nếu ta đã biết $m$ 
và $a$ thì có thể tính được lực. Điều này là đúng, nhưng ở
phần lớn các mô phỏng vật lý thì ngược lại. Dựa trên mô hình 
vật lý, bạn biết $F$ và $m$, rồi đi tính $a$.

Vậy nếu đã biết gia tốc, $a$, dưới dạng hàm theo thời gian, bằng
cách nào có thể tìm được vị trí $p$ của vật? À, ta biết rằng gia tốc
là đạo hàm bậc hai của vị trí, vậy nên ta có thể viết một phương
trình vi phân

\[ p_{tt} = a \]
%
trong đó $a$ và $p$ là các hàm số theo thời gian và trả lại các
véc-tơ, còn $p_{tt}$ là đạo hàm bậc hai theo thời gian của $p$.

Vì phương trình này bao gồm một đạo hàm bậc hai nên nó được gọi là
PVT bậc hai. {\tt ode45} không thể giải phương trình dưới dạng này,
nhưng bằng cách đưa vào một biến mới, $v$, đại diện cho vận tốc
thì ta có thể viết lại nó như một hệ các PVT bậc nhất.

\begin{eqnarray*}
p_t &=& v \\
v_t &=& a
\end{eqnarray*}
%
Phương trình đầu phát biểu rằng đạo hàm bậc nhất của $p$ là $v$; 
phương trình thứ hai cho thấy đạo hàm của $v$ là $a$.


\section{Hiện tượng rơi tự do}
\label{freefall}

Ta hãy bắt đầu bằng một ví dụ đơn giản, một vật rơi tự do trong
chân không (ở đó không có sức cản của không khí). Gần mặt đất,
gia tốc trọng trường là $g = -9.8$ m/s$^2$, trong đó dấu trừ
biểu thị rằng trọng lực hướng xuống dưới.

Nếu vật rơi thẳng xuống (cùng theo hướng trọng lực) thì ta
có thể mô tả vị trí của nó bằng một giá trị vô hướng là độ cao.
Vì vậy, tạm thời bây giờ bài toán là một chiều.

Sau đây là hàm tốc độ mà ta có thể dùng với {\tt ode45} để giải
bài toán này:

\begin{verbatim}
function res = freefall(t, X)
    p = X(1);      % the first element is position
    v = X(2);      % the second element is velocity

    dpdt = v;                          
    dvdt = acceleration(t, p, v);

    res = [dpdt; dvdt];    % pack the results in a column vector
end

function res = acceleration(t, p, v)
    g = -9.8;      % acceleration of gravity in m/s^2
    res = g;
end
\end{verbatim}
%
Hàm thứ nhất là hàm tốc độ. Nó nhận vào các biến {\tt t} và
{\tt X}, trong đó các phần tử của {\tt X} được hiểu là vị trí
và vận tốc. Giá trị trả về từ {\tt freefall} là một véc-tơ (cột)
chứa những đạo hàm của vị trí và vận tốc, tức lần lượt là
vận tốc và gia tốc.

Việc tính $p_t$ thật dễ dàng vì ta đã có vận tốc như một
phần tử của {\tt X}. Thứ duy nhất mà ta cần tính là gia tốc,
và đó là việc mà hàm thứ hai đảm nhiệm.

{\tt acceleration} làm nhiệm vụ tính gia tốc như một hàm của
thời gian, vị trí và vận tốc. Ở ví dụ này, gia tốc tổng hợp là một
hằng số, vì vậy ta không cần phải kể ra tất cả những thông tin
trên, nhưng rồi sắp tới ta sẽ phải nhắc đến.

Sau đây là cách chạy {\tt ode45} với hàm tốc độ này:

\begin{verbatim}
>> ode45(@freefall, [0, 30], [4000, 0])
\end{verbatim}
%
Như mọi khi, đối số thứ nhất là chuôi của hàm, thứ hai là khoảng
thời gian (30 giây) và thứ ba là điều kiện ban đầu: trong trường
hợp này, độ cao ban đầu là 4000 mét và vận tốc ban đầu là 0.
Vì vậy bạn có thể hình dung ``vật'' là một người nhảy dù vừa
rời khỏi máy bay ở độ cao 12000 feet.

Và kết quả sẽ như sau:

% % \beforefig 
\centerline{\includegraphics[height=2in]{figs/freefall.eps}}

Đường bên dưới cho thấy vận tốc bắt đầu tại 0 và hạ xuống
một cách tuyến tính. Đường bên trên cho thấy vị trí bắt đầu
tại 4000 m và hạ xuống theo hàm parabol (nhớ rằng đây là
hàm parabol theo thời gian chứ không phải đường bay hình
parabol).

Lưu ý rằng {\tt ode45} không biết vị trí mặt đất ở đâu, vì vậy
người nhảy dù vẫn hạ độ cao từ không xuống các giá trị độ cao
âm. Ta sẽ giải quyết vấn đề này sau.


\section{Lực cản không khí}

Để giúp cho việc mô phỏng được xác thực hơn, ta có thể thêm vào
lực cản không khí. Với những vật lớn di chuyển nhanh trong không
trung, lực cản không khí tác dụng lên vật sẽ tỷ lệ thuận với $v^2$:

\[ F_{drag} = c v^2 \]
%
Trong đó $c$ là hằng số cản, phụ thuộc vào các yếu tố mật độ 
không khí, diện tích mặt cắt ngang của vật thể và đặc tính bề mặt
của vật thể. Với mục đích minh họa của bài tập này, có thể lấy $c = 0.2$.

Để chuyển đổi từ lực sang gia tốc, ta cần phải biết khối lượng, vì vậy
hãy coi rằng người nhảy dù (cùng với thiết bị đi theo người) nặng 75 kg.

Sau đây là một phiên bản của {\tt acceleration} có tính đến lực cản
không khí (bạn không cần phải thay đổi gì trong {\tt freefall}):

\begin{verbatim}
function res = acceleration(t, p, v)
    a_grav = -9.8;              % acceleration of gravity in m/s^2
    c = 0.2;                    % drag constant
    m = 75;                     % mass in kg
    f_drag = c * v^2;           % drag force in N
    a_drag = f_drag / m;        % drag acceleration in m/s^2
    res = a_grav + a_drag;      % total acceleration
end
\end{verbatim}
%
Dấu của lực cản (và gia tốc) là dương nếu khi vật đang rơi, hướng
của lực cản hướng lên trên. Gia tốc tổng hợp là tổng của gia tốc
trọng lực và gia tốc cản. Hãy cẩn thận khi bạn làm việc với các
lực và gia tốc; hãy chắc rằng bạn chỉ cộng lực với lực và gia tốc
với gia tốc. Trong mã lệnh vừa viết, tôi dùng lời chú thích để tự
nhắc nhở mình rằng các đơn vị ứng với từng giá trị. Điều đó sẽ
giúp tôi tránh khỏi những điều vô nghĩa kiểu như cộng lực và
gia tốc với nhau.

Sau đây là dạng của kết quả khi có lực cản không khí:

% % \beforefig 
\centerline{\includegraphics[height=2in]{figs/freefall2.eps}}

Có sự khác biệt lớn. Với lực cản không khí, vận tốc tăng lên
đến khi gia tốc cản bằng với $g$; sau đó, vận tốc là không đổi,
được biết đến với tên gọi ``vận tốc cuối,'' và vị trí sẽ hạ thấp
tuyến tính theo thời gian (và sẽ chậm hơn nhiều so với trường hợp
rơi trong chân không). Để kiểm tra lại kết quả một cách cẩn thận
hơn, ta có thể gán chúng vào các biến

\begin{verbatim}
>> [T, M] = ode45(@freefall, [0, 30], [4000, 0]);
\end{verbatim}
%
rồi đọc các vị trí và vận tốc cuối:

\begin{verbatim}
>> M(end,1)
ans = 2441.3          % altitude in meters

>> M(end,2)
ans = -60.614            % velocity in m/s
\end{verbatim}
%
\begin{ex}
Hãy tăng khối lượng của người nhảy dù, và kiểm tra lại để chắc
rằng vận tốc cuối tăng lên. Quan hệ này chính là nguồn gốc dẫn đến
cảm nhận trực giác rằng những vật nặng thì rơi nhanh hơn; và
đúng là trong không khí, chúng rơi nhanh hơn thật!
\end{ex}


\section{Nhảy dù!}

Ở mục trước, ta đã thấy rằng vận tốc cuối của một người nhảy dù
nặng 75~kg là khoảng 60~m/s,vốn là khoảng 130 dặm/giờ. Nếu 
quả thật phải tiếp đất với vận tốc như vậy, chắc là bạn sẽ chết. 
Đó là tại sao phải có dù.

\begin{ex}
Hãy sửa lại {\tt acceleration} sao cho sau 30 giây tự do, người nhảy
mở dù, và (gần như) lập tức tăng hằng số cản lên 2,7.

Vận tốc cuối bây giờ bằng bao nhiêu? Bao lâu (sau khi mở dù), người
nhảy sẽ tiếp đất?
\end{ex}


\section{Bài toán hai chiều}
\label{projectile}

Đến đây ta đã dùng {\tt ode45} giải một hệ phương trình bậc nhất
và một phương trình bậc hai. Bước làm hợp lý tiếp theo là một 
hệ phương trình bậc hai, và ví dụ hợp lý tiếp theo là về một đường bay.
``Đường bay'' được vạch ra bởi một vật thể bắn đi trong không khí,
thường là hướng về nhằm phá hủy mục tiêu.

Nếu đường bay nằm trong một mặt phẳng, ta có thể coi hệ là
hai chiều, với $x$ biểu thị khoảng cách theo phương ngang bay được
và $y$ biểu thị độ cao. Như vậy bây giờ thay vì một người nhảy dù,
bạn có thể hình dung về người trong gánh xiếc bị bắn ra từ nòng pháo.

Theo Wikipedia\footnote{\url{http://en.wikipedia.org/wiki/Human_cannonball}},
khoảng cách kỉ lục của người bị bắn từ nòng pháo là xa 56,5 mét.

Sau đây là một khung chương trình có dùng {\tt ode45} để tính đường bay của ``đạn'' trong
không gian hai chiều:

\begin{verbatim}
function res = projectile(t, W)
    P = W(1:2);
    V = W(3:4);

    dPdt = V;                          
    dVdt = acceleration(t, P, V);

    res = [dPdt; dVdt];
end

function res = acceleration(t, P, V)
    g = -9.8;             % acceleration of gravity in m/s^2
    res = [0; g];
end
\end{verbatim}
%
Đối số thứ hai của hàm tốc độ là một véc-tơ, {\tt W}, với
4 phần tử. Hai phần tử đầu được gán cho {\tt P}, để biểu
diễn vị trí; hai phần sau gán cho {\tt V}, để biểu diễn
vận tốc. {\tt P} và {\tt V} là các véc-tơ với các phần tử
là những thành phần theo phương $x$ và $y$.

Kết quả thu được từ {\tt acceleration} cũng là một véc-tơ; 
(tạm thời) bở qua lực cản không khí, gia tốc theo phương
$x$ bằng không, và theo phương $y$ thì bằng $g$. 
Ngoài ra thì mã lệnh giống hệt như ta đã thấy ở
Mục~\ref{freefall}.

Nếu ta phóng người bay từ độ cao ban đầu là 3 mét, với các
vận tốc thành phần là 40 m/s và 30 m/s theo các phương $x$ 
và $y$ thì lời gọi hàm {\tt ode45} sẽ như sau:

\begin{verbatim}
ode45(@projectile, [0,10], [0, 3, 40, 30]);
\end{verbatim}
%
Và kết quả sẽ như sau:

%% \beforefig 
\centerline{\includegraphics[height=2in]{figs/proj1.eps}}

Bạn có thể sẽ phải nghĩ một lát để hình dung ra đường nào
ứng với đại lượng gì. Dường như là thời gian bay vào khoảng
6 giây.

\begin{ex}
Hãy lọc ra các giá trị thành phần theo các phương $x$ và $y$ 
của vị trí, vạch ra đường bay của người, rồi ước tính khoảng
cách bay được.
\end{ex}

\begin{ex}
Hãy thêm sức cản không khí vào bài toán mô phỏng này. Ở
trường hợp người nhảy dù, ta giả sử rằng hằng số cản bằng
0,2; nhưng nó được dựa trên giả thiết là người nhảy rơi
có mặt tiếp xúc phẳng. Nhưng người bị bắn pháo, bay 
hướng đầu về phía trước, có lẽ sẽ ứng với hằng số cản
chừng 0,1. Vận tốc ban đầu cần để đạt được khoảng cách
bay kỷ lục 65,6 sẽ phải bằng bao nhiêu? Gợi ý: góc bắn
tối ưu bằng bao nhiêu?
\end{ex}


\section{Điều gì trục trặc có thể xảy ra?}

%Điều gì trục trặc có thể xảy ra?  À, chẳng hạn như {\tt vertcat}.
%Để giải thích từ này nghĩa là gì, tôi sẽ bắt đầu bằng 
%{\bf phép ghép nối}, phép toán để ghép hai ma trận thành
%một ma trận lớn hơn. ``Vertical catenation'' (ghép theo
%phương thẳng đứng) sẽ ghép hai ma trận bằng cách đặt
%chồng lên nhau (cột nối cột); ``horizontal catenation'' 
%(ghép theo phương ngang) đặt hai ma trận cạnh nhau
%(hàng nối hàng).

Điều gì trục trặc có thể xảy ra? Khi {\bf ghép nối} hai ma trận
thành một ma trận lớn hơn, ta có thể ghép dọc (hai ma trận
được đặt chồng lên nhau, cột nối cột), hoặc ghép ngang (hai
ma trận đặt cạnh nhau, hàng nối hàng). 
Sau đây là một ví dụ ghép ngang với các véc-tơ hàng:

\begin{verbatim}
>> x = 1:3

x = 1     2     3

>> y = 4:5

y = 4     5

>> z = [x, y]

z = 1     2     3     4     5
\end{verbatim}
%
Bên trong cặp ngoặc vuông, dấu phẩy làm nhiệm vụ ghép ngang.
Còn toán tử ghép dọc là dấu chấm phẩy. Sau đây là một ví dụ với
các ma trận:

\begin{verbatim}
>> X = zeros(2,3)

X =  0     0     0
     0     0     0

>> Y = ones(2,3)

Y =  1     1     1
     1     1     1

>> Z = [X; Y]

Z =  0     0     0
     0     0     0
     1     1     1
     1     1     1
\end{verbatim}
%
Các toán tử này chỉ có tác dụng khi các ma trận có cùng kích thước
ở chiều được ghép với nhau. Nếu không, bạn sẽ nhận được:

\begin{verbatim}
>> a = 1:3

a = 1     2     3

>> b = a'

b =  1
     2
     3

>> c = [a, b]
error: number of rows must match (3 != 1) near line 38, column 8

>> c = [a; b]
error: number of columns must match (1 != 3)
\end{verbatim}
%
Ở ví dụ này, {\tt a} là véc-tơ hàng còn {\tt b} là véc-tơ cột,
vì vậy chúng chẳng thể ghép được theo bất cứ chiều nào.

Bằng việc đọc lời thông báo lỗi, bạn có thể đã đoán ra được rằng
lỗi là do các kích thước ma trận không hợp nhau.
%{\tt horzcat} là hàm thực hiện ghép nối theo phương ngang, và
%tương tự với {\tt vertcat} cùng việc ghép nối theo phương dọc.

Các phép toán này có liên quan đến {\tt projectile} vì dòng cuối
cùng, vốn để gói {\tt dPdt} và {\tt dVdt} vào biến đầu ra:

\begin{verbatim}
function res = projectile(t, W)
    P = W(1:2);
    V = W(3:4);

    dPdt = V;                          
    dVdt = acceleration(t, P, V);

    res = [dPdt; dVdt];
end
\end{verbatim}
%
Miễn là cả {\tt dPdt} và {\tt dVdt} đều là véc-tơ cột thì 
dấu chấm phẩy sẽ thực hiện ghép nối theo chiều dọc, và
kết quả là véc-tơ cột có 4 phần tử. Nhưng nếu một trong
hai véc-tơ đó là véc-tơ hàng thì sẽ trục trặc. 

{\tt ode45} trông đợi kết quả của {\tt projectile} như một
véc-tơ cột, vì vậy nếu bạn dùng {\tt ode45}, có thể sẽ tốt hơn
nếu để {\em mọi đại lượng} dưới dạng véc-tơ cột.

Nhìn chung, nếu bạn gặp trục trặc với {\tt horzcat} và 
{\tt vertcat}, hãy dùng {\tt size} để hiển thị kích cỡ của
các toán hạng, và đảm bảo chắc chắn véc-tơ của bạn được
sắp xếp hàng-cột cho đúng.


\section{Thuật ngữ}

\begin{description}

\item[các hàm song song:] Những hàm được định nghĩa cạnh nhau,
và một hàm kết thúc trước khi hàm khác bắt đầu.

\item[hàm lồng ghép:] Hàm được định nghĩa bên trong hàm khác.

\item[hàm ngoài:] Hàm có chứa một định nghĩa hàm khác.

\item[hàm trong:] Hàm được định nghĩa bên trong một lời định nghĩa
hàm khác. Hàm trong có thể truy cập các biến của hàm ngoài.

\item[ghép nối:] Phép toán nối tiếp hai ma trận để tạo nên một
ma trận mới.


\end{description}

\section{Bài tập}

\begin{ex}
\label{baseball}

Đường bay của quả bóng chày bị chi phối bởi ba lực: trọng lực,
lực cản không khí, và lực Magnus do chuyển động quay. Nếu ta
bỏ qua gió và lự cản Magnus thì đường bay của quả bóng chày
luôn nằm trong một mặt phẳng, và ta có thể mô phỏng nó như
vật được bắn đi theo không gian hai chiều.

Một mô hình đơn giản cho lực cản không khí tác dụng lên quả bóng là:
A simple model of the drag of a baseball is:
%
\[ F_d = -\frac{1}{2} ~ \rho ~ v^2 ~ A ~ C_d ~ \hat{V}   \]
%
trong đó $F_d$ là một véc-tơ biểu diễn lực tác dụng lên quả bóng 
chày gây bởi lực cản, $C_d$ là hệ số cả (0,3 là một giá trị phù hợp),
$\rho$ là mật độ không khí (1,3 kg/m$^3$ ở mực nước biển), $A$
là diện tích mặt cắt ngang của quả bóng (0.0042 m$^2$), $v$ là
độ lớn của véc-tơ vận tốc, còn $\hat{V}$ là một véc-tơ đơn vị
theo hướng của véc-tơ vận tốc. Khối lượng của quả bóng là 
0,145~kg.

Bạn có thể đọc thêm về lực cản ở trang 
\url{http://en.wikipedia.org/wiki/Drag_(physics)}.

\begin{itemize}

\item Hãy viết một hàm nhận vào các biến gồm vận tốc ban đầu và góc ném của
quả bóng chày, dùng {\tt ode45} để tính đường bay, và trả lại tầm xa (khoảng
cách phương ngang bay được) là các biến đầu ra.

\item Hãy viết một hàm nhận vào biến vận tốc ban đầu của quả bóng, tính
góc ném sao cho khiến cho tầm xa là lớn nhất, và trả lại góc ném tối ưu nêu
trên cùng với tầm xa như những biến đầu ra. Góc ném tối ưu thay đổi theo
vận tốc ban đầu như thế nào?

\item Khi đội Red Sox đoạt giải World Series năm 2007, họ gặp đội
Colorado Rockies tại sân nhà ở Denver, Colorado.  Hãy ước tính mật độ
không khí ở Mile High City. Nó có ảnh hưởng gì đến sức cản không khí?
Hãy dự đoán về ảnh hưởng của yếu tố này [lực cản] đến góc ném tối ưu,
và dùng mô phỏng của bạn để kiểm tra lại dự đoán đó.

\item Sân Green Monster ở Fenway Park ở độ cao khoảng 12 m và 
chiều dài khoảng 97 m. Vận tốc tối thiểu của quả bóng ngay sau khi
vụt phải bằng bao nhiêu để bay hết chiều dài sân (giả thiết rằng 
bóng bay theo góc tối ưu)? Bạn có nghĩ rằng một người có thể
ném bóng hết chiều dài sân được không?

\item Lực cản của không khí lên quả bóng chày thực tế còn phức tạp
hơn rất nhiều so với tính toán bằng mô hình đơn giản nêu trên. Đặc biệt,
hệ số cản còn thay đổi theo vận tốc. Bạn có thể đọc thêm từ cuốn
{\em The Physics of Baseball}\footnote{Robert K. Adair, Harper Paperbacks, 3rd
Edition, 2002.}; và cũng tìm thông tin trên web. Sau đó, hãy thiết lập
một mô hình thực tế hơn về lực cản và sửa đổi chương trình tính theo
lực cản mới này. Bằng mô hình mới thì tầm xa tính được sẽ thay đổi
bao nhiêu? Góc ném tối ưu sẽ thay đổi bao nhiêu?

\end{itemize}

\end{ex}


% chap11
\chapter{Tối ưu hóa và nội suy}

\section{Các sự kiện dùng trong hàm ODE}
\label{events}

Thường thì khi gọi {\tt ode45}, bạn đều phải chỉ ra các thời điểm bắt đầu
và kết thúc. Nhưng trong nhiều trường hợp, bạn không biết trước
lúc nào việc mô phỏng cần kết thúc. Thật may là Octave cung cấp
một cơ chế xử lý vấn đề này. Điều không hay là cơ chế này hơi lủng củng
một chút. Sau đây là cách hoạt động:

\begin{enumerate}

\item Trước khi gọi {\tt ode45} bạn dùng {\tt odeset} để tạo ra một
đối tượng có tên {\tt options} để chứa các giá trị quy định cách 
hoạt động của {\tt ode45}:

\begin{verbatim}
options = odeset('Events', @events);
\end{verbatim}
%
Trong trường hợp này, tên của tùy chọn (option) là {\tt Events} còn
giá trị là một chuôi hàm. Khi {\tt ode45} hoạt động, nó sẽ gọi
{\tt events} sau mỗi bước thời gian. Bạn có thể gọi hàm này bằng
bất cứ tên gọi nào, nhưng cái tên {\tt events} thường được chọn
theo thông lệ.

\item Hàm mà bạn cung cấp phải nhận vào cùng các biến như 
hàm tốc độ nhận vào. Chẳng hạn, sau đây là một hàm sự kiện 
gắn với hàm {\tt projectile} từ Mục~\ref{projectile}

\begin{verbatim}
function [value,isterminal,direction] = events(t,X)
    value = X(2);        % Extract the current height.
    isterminal = 1;      % Stop the integration if height crosses zero.
    direction = -1;      % But only if the height is decreasing.
end
\end{verbatim}
%
{\tt events} trả lại ba biến đầu ra:

{\tt value} quyết định xem khi nào một sự kiện xảy ra. Trong 
trường hợp này {\tt value} nhận giá trị của phần tử thứ hai thuộc
{\tt X}, vốn được hiểu là chiều cao của vật bay. Một ``sự kiện''
(event) là một thời điểm khi mà giá trị chiều cao nói trên đi qua 0.

{\tt direction} quyết định liệu rằng một sự kiện có xảy ra khi
{\tt value} đang tăng ({\tt direction=1}), giảm 
({\tt direction=-1}, hoặc cả hai {\tt direction=0}.

{\tt isterminal} quyết định xem điều gì cần thực hiện khi sự kiện
xảy ra. Nếu {\tt isterminal=1}, sự kiện là ``terminal'' và quá trình
mô phỏng kết thúc. Nếu {\tt isterminal=0}, quá trình mô phỏng
vẫn tiếp tục, nhưng {\tt ode45} thực hiện thêm một số việc nữa
để đảm bảo rằng nghiệm ở trong vùng lân cận của sự kiện là đúng,
và một trong các giá trị tính được phải rơi đúng vào lúc xảy ra
sự kiện.

\item Khi gọi {\tt ode45}, bạn chuyển {\tt options} làm đối số
thứ tư:

\begin{verbatim}
ode45(@projectile, [0,10], [0, 3, 40, 30], options);
\end{verbatim}
%
\end{enumerate}

\begin{ex}
Phải sửa {\tt events} như thế nào để nó dừng chạy khi chiều cao của
quả bóng rớt xuống thấp hơn 3~m?
\end{ex}


\section{Tối ưu hóa}

Trong Bài tập~\ref{baseball}, bạn được yêu cầu tính góc ban đầu
tối ưu sau khi bóng bị vụt. ``Tối ưu'' là cách nói hoa mỹ cho
``tốt nhất;'' nghĩa của nó lại tùy thuộc vào bài toán cụ thể.
Với bài toán Green Monster---tìm ra góc đánh tối ưu cho một
cú hết sân thì nghĩa của ``tối ưu'' không phải là hiển nhiên.

Rất dễ nghĩ rằng chọn góc mà cho tầm xa là lớn nhất (khoảng cách
từ chỗ vụt đến chỗ chạm đất). Nhưng ở đây ta cần cố vượt qua một
tường chắn cao 12~m, vì vậy có lẽ ta sẽ cần góc vụt sao cho 
tầm xa là lớn nhất khi quả bóng bay qua ngưỡng 12~m.

Mặc dù định nghĩa nào trong số trên cũng dùng được cho những
mục đích nhất định, nhưng không có định nghĩa nào hoàn toàn
đúng. Ở trường hợp này góc ``tối ưu'' là góc mà cho chiều cao
lớn nhất tại điểm mà quả bóng chạm tường, vốn cách chỗ vụt 
97~m.

Vì vậy bước đầu tiên của mọi bài toán tối ưu là định nghĩa
xem ``tối ưu'' là gì. Bước thứ hai là định nghĩa khoảng giá trị
mà bạn muốn dò tìm. Trong trường hợp này, khoảng giá trị cho
phép là giữa 0 độ (song song với mặt đất) đến 90 độ (thẳng
lên trời). Ta trông đợi góc tối ưu gần với 45 độ, nhưng không
chắc rằng nó chệch với 45 độ là bao nhiêu. Để an toàn, ta có
thể bắt đầu tìm trong khoảng rộng nhất có thể.

Cách đơn giản nhất để tìm giá trị tối ưu là chạy chương trình
mô phỏng với một khoảng rộng các giá trị rồi lựa ra giá trị
cho kết quả tốt nhất. Cách này không hiệu quả lắm, đặc biệt
trong bài này khi mà việc tính tầm bay là rất tốn công.

Một thuật toán khá hơn là cách Tìm kiếm theo lát cắt vàng.

\section{Tìm kiếm theo lát cắt vàng}

Để trình bày cách tìm kiếm theo lát cắt vàng, tôi sẽ bắt đầu với một
dạng đơn giản hơn mà tôi đặt tên là tìm kiếm theo lát cắt bạc. Ý tưởng
cơ bản cũng giống như các phương pháp tìm nghiệm mà ta đã thấy ở
Mục~\ref{zero}.  Trong bài toán tìm nghiệm, ta có một bức tranh
như sau:

% % \beforefig 
\centerline{\includegraphics[height=1.5in]{figs/secant.eps}}

Cho trước một hàm $f$ có thể lượng giá được, và ta cần tìm một
nghiệm của $f$; nghĩa là một giá trị của $x$ sao cho $f(x)=0$.  
Nếu ta có thể tìm được một giá trị, $x_1$, sao cho $f(x_1)$ 
dương và một giá trị khác, $x_2$, sao cho $f(x_2)$ âm, thì
phải có một nghiệm trong khoảng giữa chúng (miễn là $f$ liên tục).
Lúc này ta nói $x_1$ và $x_2$ bao lấy nghiệm.

Thuật toán tiếp diễn với việc chọn một giá trị thứ ba, $x_3$, 
ở giữa $x_1$ và $x_2$ rồi tính $y = f(x_3)$.  Nếu $y$ dương thì ta
có thể lập ra một cặp mới, $(x_3, x_2)$, bao lấy nghiệm. Nếu 
$y$ âm thì cặp $(x_1, x_3)$ bao lấy nghiệm. Bằng cách nào đi nữa
thì khoảng bao cũng hẹp lại và ước đoán của ta về vị trí nghiệm
trở nên chính xác hơn.

Đó là việc tìm nghiệm. Còn cách Tìm kiếm theo lát cắt vàng cũng
tương tự, nhưng ta phải khởi đầu với ba giá trị, và bức tranh
sẽ có dạng sau:

% % \beforefig 
\centerline{\includegraphics[height=1.5in]{figs/golden1.eps}}

Biểu đồ này cho thấy rằng ta đã tính $f$ tại ba vị trí,
$x_1$, $x_2$ và $x_3$, rồi biết được $x_2$ cho giá trị lớn nhất.
Nếu $f$ liên tục, thì có ít nhất là một cực trị địa phương ở
giữa $x_1$ và $x_3$, vì vậy ta sẽ nói rằng bộ ba $(x_1, x_2, x_3)$
bao lấy một cực đại.

Bước tiếp theo là chọn điểm thứ tư, $x_4$, rồi tính $f(x_4)$. 
Có hai kết quả có thể xảy ra, tùy theo là $f(x_4)$ có lớn hơn $f(x_2)$'
hay không:

% % \beforefig 
\centerline{\includegraphics[height=1.5in]{figs/golden2.eps}}

Nếu $f(x_4)$ nhỏ hơn  $f(x_2)$ (hình bên trái), thì bộ ba mới
$(x_1, x_2, x_4)$ bao lấy cực đại. Nếu $f(x_4)$ lớn hơn
$f(x_2)$ (hình bên phải), thì $(x_2, x_4, x_3)$ bao lấy cực đại.
Dù với cách nào đi nữa thì khoảng bao cũng thu hẹp lại và 
ước tính giá trị cực đại của $x$ càng tốt hơn.

Phương pháp này áp dụng được ch ohầu hết các giá trị của $x_4$,
nhưng có cách chọn nhất định sẽ có hiệu quả hơn. Ở đây, tôi chọn 
cách chia đôi khoảng lớn hơn trong số hai khoảng $(x_1, x_2)$ và 
$(x_2, x_3)$.

Sau đây là đoạn chương trình trong Octave:

\begin{verbatim}
function res = optimize(V)
    x1 = V(1);
    x2 = V(2);
    x3 = V(3);
    
    fx1 = height_func(x1);
    fx2 = height_func(x2);
    fx3 = height_func(x3);
   
    for i=1:50
        if x3-x2 > x2-x1
            x4 = (x2+x3) / 2;
            fx4 = height_func(x4);
            if fx4 > fx2
                x1 = x2;  fx1 = fx2;
                x2 = x4;  fx2 = fx4;
            else
                x3 = x4;  fx3 = fx4;
            end
        else
            x4 = (x1+x2) / 2;
            fx4 = height_func(x4);
            if fx4 > fx2
                x3 = x2;  fx3 = fx2;
                x2 = x4;  fx2 = fx4;
            else
                x1 = x4;  fx1 = fx4;
            end
        end

        if abs(x3-x1) < 1e-2
            break
        end
    end
    res = [x1 x2 x3];
end
\end{verbatim}
%
Biến đầu vào là một véc-tơ có chứa ba giá trị và bao lấy một cực đại;
trong trường hợp này là các góc tính theo độ. {\tt optimize} bắt đầu 
bằng việc ước lượng \verb#height_func# cho ba giá trị này.
Ta giả sử rằng \verb#height_func# trả lại kết quả mà ta cần 
tối ưu hóa; trong bài toán Green Monster đó chính là chiều cao của 
quả bóng khi chạm tường.

Mỗi lượt lặp qua vòng {\tt for} hàm sẽ chọn một giá trị của {\tt x4}, 
tính  \verb#height_func#, rồi cập nhật bộ ba {\tt x1}, {\tt x2} và 
{\tt x3} tùy theo kết quả thu được.

Sau khi cập nhật, nó tính độ dài khoảng bao nghiệm, {\tt x3-x1},
rồi kiểm tra xem nó đã đủ ngắn chưa. Nếu được rồi, nó sẽ thoát khỏi 
vòng lặp và trả lại kết quả là bộ ba hiện thời. Trong trường hợp dở nhất, 
vòng lặp sẽ được thực hiện 50 lần.

\begin{ex}
Tôi gọi thuật toán này là Tìm kiếm theo lát cắt bạc vì nó tốt gần bằng 
cách Tìm kiếm theo lát cắt vàng. Hãy đọc Wikipedia về cách Tìm 
kiếm theo lát cắt vàng 
(\url{http://en.wikipedia.org/wiki/Golden_section_search}) rồi sửa lại 
mã lệnh trên để tính theo cách mới này.
\end{ex}

\begin{ex}
Bạn có thể viết các hàm nhận vào chuôi của hàm khác, như ta đã thấy  
ở {\tt fzero} và {\tt ode45}. Chẳng hạn, \verb#handle_func# nhận vào 
một chuôi hàm tên là {\tt func} rồi gọi nó, truyền vào đối số là  {\tt pi}.

\begin{verbatim}
function res = handle_func(func)
    func(pi)
end
\end{verbatim}
%
Bạn có thể gọi \verb#handle_func# từ dấu nhắc lệnh và truyền
vào các chuôi hàm khác nhau làm đối số:

\begin{verbatim}
>> handle_func(@sin)
ans = 0

>> handle_func(@cos)
ans = -1
\end{verbatim}
%
Hãy sửa lại {\tt optimize} để cho nó nhận vào một chuôi hàm rồi 
lấy hàm này làm mục tiêu để tối ưu hóa.
\end{ex}

\begin{ex}
Hàm {\tt fminsearch} của Octave nhận vào một chuôi hàm và tìm 
cực tiểu địa phương của hàm này. Hãy đọc lời hướng dẫn cách dùng  
{\tt fminsearch} rồi dùng nó để tìm góc đánh tối ưu của quả bóng 
chày ứng với một  vận tốc cho trước. 
\end{ex}


\section{Ánh xạ rời rạc và liên tục }

Khi bạn giải PVT theo cách giải tích, kết qủa thu được là một hàm, 
và bạn có thể coi rằng đó là một phép ánh xạ liên tục. Khi bạn 
dùng một hàm giải PVT, bạn thu được hai véc-tơ (hoặc một véc-tơ 
và một ma trận), mà bạn có thể coi là một phép ánh xạ rời rạc.

Chẳng hạn, ở Mục~\ref{ode45}, ta đã dùng hàm tốc độ sau để 
ước tính số con chuột như một hàm theo thời gian: 

\begin{verbatim}
function res = rats(t, y)
    a = 0.01;
    omega = 2 * pi / 365;
    res = a * y * (1 + sin(omega * t));
end
\end{verbatim}
%
Kết quả thu được từ  {\tt ode45} là hai véc-tơ:

\begin{verbatim}
>> [T, Y] = ode45(@rats, [0, 365], 2);
\end{verbatim}
%
{\tt T} chứa các giá trị thời gian tại đó cần ước tính số chuột bằng {\tt ode45}; 
{\tt Y} chứa các giá trị ước tính.

Bây giờ ta hình dung như cần biết số chuột vào ngày thứ 180 của năm. Ta có thể 
tìm giá trị 180 trong  {\tt T}:

\begin{verbatim}
>> find(T==180)
ans = [](0x1)
\end{verbatim}
%
Nhưng không có bảo đảm gì rằng sẽ tồn tại một giá trị như vậy trong {\tt T}.  
Ta có thể tìm ra chỉ số mà tại đó giá trị của {\tt T} cắt qua 180:

\begin{verbatim}
>> I = find(T>180); I(1)
ans = 17
\end{verbatim}
%
{\tt I} sẽ nhận được tất cả những  chỉ số ứng với các phần tử của  {\tt T} mà lớn 
hơn  180, vì vậy  {\tt I(1)} chính là chỉ số  {\em đầu tiên}.

Sau đó ta tìm giá trị tương ứng của  {\tt Y}:

\begin{verbatim}
>> [T(17), Y(17)]
ans = 194.878    44.284
\end{verbatim}
%   
Cách này cho ta một ước tính thô sơ về số chuột vào ngày 180. Nếu cần 
tính kĩ hơn, ta có thể tìm thêm giá trị ngay trước ngày 180:

\begin{verbatim}
>> [T(16), Y(16)]
ans = 177.843   37.771
\end{verbatim}
%   
Như vậy số chuột vào ngày 180 sẽ nằm giữa  37,771 và  44,284.

Nhưng cụ thể con số nào trong khoảng này sẽ là ước lượng chính xác nhất?
Một cách làm đơn giản là chọn ngay giá trị nào tương ứng thời gian gần với 
180 hơn. Trong bài này, dù rằng giá trị 117,843 đã khá gần với ngày 180 
nhưng ta vẫn muốn chính xác hơn.


\section{Nội suy}

Một cách làm hợp lý là vạch một đường thẳng nối hai điểm bao ngày 180
và dùng đường thẳng đó để ước tính giá trị giữa chúng. Quá trình này được 
gọi là {\bf nội suy tuyến tính}, và Octave cung cấp một hàm có tên 
{\tt interp1} để đảm nhiệm việc này:

\begin{verbatim}
>> pop = interp1(T, Y, 180)
pop = 38.596
\end{verbatim}
%
Hai đối số đầu dùng để chỉ một phép ánh xạ rởi rạc từ các giá trị có 
trong {\tt T} đến các giá trị trong  {\tt Y}.  Đối số thứ ba là giá trị thời gian 
mà ta cần nội suy. Kết quả thu được giống như ta trông đợi, chừng ở chính  giữa 
hai giá trị đầu khoảng bao. 

{\tt interp1} cũng có thể nhận một đối số thứ tư để chỉ dạng nội suy mà bạn muốn.
Mặc định là {\tt 'linear'}, vốn thực hiện nội suy tuyến tính. Các lựa chọn khác bao 
gồm {\tt 'spline'} vốn dùng một đường cong spline để lượn qua bốn điểm, với hai 
điểm mỗi phía, và {\tt 'cubic'}, vốn dùng phép nội suy Hermit bậc ba cho 
từng đoạn.

\begin{verbatim}
>> pop = interp1(T, Y, 180, 'spline')
pop = 38.646

>> pop = interp1(T, Y, 180, 'cubic')
pop = 38.694
\end{verbatim}
%
Ở trường hợp này ta trông đợi các kết quả thu được từ nội suy spline 
và bậc ba tốt hơn so với tuyến tính, vì chúng dùng nhiều điểm số liệu hơn, 
và ta biết rằng hàm không phải tuyến tính. Nhưng chẳng có lý do gì để ta 
có thể trông đợi rằng hàm spline cho kết quả tốt hơn hàm bậc ba, hoặc 
ngược lại. Thật may là, các kết quả không quá khác biệt. 

Ta cũng có thể dùng  {\tt interp1} để kéo dài đồ thị của số chuột ra 
ngoài khoảng các giá trị có trong {\tt T}:

\begin{verbatim}
>> [T(end), Y(end)]
ans = 365.0000   76.949

>> pop = interp1(T, Y, 370, 'spline', 'extrap')
pop = 81.037
\end{verbatim}
%
Quá trình này được gọi là  {\bf ngoại suy} (chú ý là ta phải chỉ định 
thêm chuỗi \texttt{'extrap'}).  Với những giá trị thời gian 
còn gần 365, ngoại suy vẫn có vẻ hợp lý, nhưng khi càng xa về phía 
``tương lai,'' ta càng trông đợi ở đó sự kém chính xác. Chẳng hạn, 
sau đây là con số ước tính được khi ngoại suy cả một năm:

\begin{verbatim}
>> pop = interp1(T, Y, 365*2, 'cubic', 'extrap')
pop = -3518.6
\end{verbatim}
%
Kết quả là hoàn toàn sai.


\section{Nội suy hàm ngược}

Ta đã dùng {\tt interp1} để tìm số chuột như một hàm của thời gian;
và bằng cách đảo ngược vai trò của {\tt T} và {\tt Y}, ta cũng có thể 
nội suy thời gian như một hàm của số chuột. Chẳng hạn, ta cần biết 
sau bao lâu thì số chuột sẽ đạt đến 20.

\begin{verbatim}
>> interp1(Y, T, 20)
ans = 133.4128
\end{verbatim}
%
Cách dùng {\tt interp1} thế này có thể dễ nhầm lẫn nếu bạn nghĩ rằng 
các đối số như là $x$ và $y$. Có thể hay hơn là bạn hình dung chúng 
như tập nguồn và tập đích trong một phép ánh xạ (còn đối số thứ ba 
là phần tử trong tập nguồn).

Hình vẽ dưới đây cho thấy $f$ ({\tt Y} vẽ theo  {\tt T}) và nghịch đảo 
của  $f$ ({\tt T} vẽ theo {\tt Y}).

% % \beforefig
%\centerline{\includegraphics[height=2in,width=4in]{figs/ratplot.eps}}
\centerline{\includegraphics[height=2.5in]{figs/ratplot.eps}}

Ở trường hợp này ta có thể dùng  {\tt interp1} theo cách nào cũng được 
vì  $f$ có  {\bf ánh xạ đơn trị}, tức là mỗi giá trị của tập đích chỉ có một 
giá trị từ tập nguồn có ánh xạ đến nó.

Nếu ta giảm lượng cung cấp thức ăn sao cho số chuột giảm trong thời kì 
mùa đông thì có thể sẽ thấy kết quả sau:

% % \beforefig 
\centerline{\includegraphics[height=2.5in]{figs/ratplot2.eps}}

Ta vẫn dùng được  {\tt interp1} để ánh xạ từ {\tt T} đến  {\tt Y}:

\begin{verbatim}
>> interp1(T, Y, 260)
ans = 15.0309
\end{verbatim}
%
Như vậy là vào ngày 260, số chuột có khoảng 15 con, nhưng nếu ta cần biết 
vào ngày nào số chuột có 15 con thì sẽ tồn tại hai câu trả lời: 172,44 và 
260,44.  Nếu thử dùng  {\tt interp1}, ta sẽ nhận được kết quả sai:

\begin{verbatim}
>> interp1(Y, T, 15)         
ans = 196.3833                % SAI 
\end{verbatim}
%
Vào ngày 196, số chuột thực tế là 16,8; vì vậy  {\tt interp1} còn không đạt 
gần con số đó! Vấn đề là ở chỗ {\tt T} với vai trò hàm số của {\tt Y} là một 
{\bf ánh xạ đa trị}; với một giá trị nào đó ở tập nguồn, có hơn một giá trị ở 
tập đích. Điều này làm cho {\tt interp1} không tính đúng. Tôi không thể tìm thấy 
tài liệu nào viết về sự hạn chế nói trên, thật hơi tệ.


\section{Chuột đồng}

Như ta đã thấy, một công dụng của nội suy là để diễn giải kết quả của một 
bài toán số trị; song còn một công dụng khác là để lấp đầy những khoảng 
trống giữa các số liệu đo rời rạc.

Chẳng hạn\footnote{Ví dụ này được trích có sửa đổi từ Gerald \& Wheatley,
{\em Applied Numerical Analysis}, Fourth Edition, Addison-Wesley,
1989.}, giả sử rằng số chuột đồng bị chi phối bởi phương trình tốc độ:

\[ g(t, y) = ay - b(t) y^{1.7} \]
%
trong đó  $t$ là thời gian tính theo tháng, $y$ là số chuột, $a$ là một tham số 
đặc trưng cho tốc độ tăng số chuột trong trường hợp không hạn chế, còn 
$b$ là hàm số theo thời gian, đặc trưng cho ảnh hưởng của lương thực 
được cấp đến tốc độ chết.

Mặc dù $b$ xuất hiện trong phương trình như một hàm liên tục, ta có thể sẽ 
không biết được $b(t)$ với mọi $t$.  Thay vào đó, ta có thể chỉ có các số liệu đo 
rời rạc sau đây:

\begin{verbatim}
t          b(t)
-          ----
0          0.0070
1          0.0036             
2          0.0011
3          0.0001
4          0.0004
5          0.0013
6          0.0028
7          0.0043
8          0.0056
\end{verbatim}
%
Nếu dùng {\tt ode45} để giải phương trình vi phân, thì ta sẽ không thể 
tiến gần đến những giá trị của $t$ khi hàm tốc độ (và do đó cả $b$) 
được lượng giá. Ta cần cung cấp một hàm cho phép xác định $b$ bất kì lúc nào:

\begin{verbatim}
function res = interpolate_b(t)
    T = 0:8;
    B = [70 36 11 1 4 13 28 43 56] * 1e-4;
    res = interp1(T, B, t);
end
\end{verbatim}
%
Nhìn bao quát, hàm này dùng một phép ánh xạ rời rạc để lập ra một 
ánh xạ liên tục.

\begin{ex}
Hãy viết một hàm tốc độ trong đó dùng \verb#interpolate_b# để 
lượng giá  $g$ rồi dùng {\tt ode45} để tính số chuột đồng từ 
$t=0$ đến $t=8$ với số chuột ban đầu bằng 100 và $a=0.9$.

Sau đó sửa lại   \verb#interpolate_b# để dùng nội suy spline và 
chạy lại  {\tt ode45} để xem phép nội suy ảnh hưởng nhiều đến các kết 
quả hay không.
\end{ex}

\section{Thuật ngữ}

\begin{description}

\item[nội suy:] Ước tính giá trị của một hàm dựa vào các giá trị đã biết 
ở hai phía.

\item[ngoại suy:] Ước tính giá trị của một hàm dựa vào các giá trị đã biết 
nhưng không bao lấy giá trì cần tìm.

\item[ánh xạ đơn trị:] Ánh xạ trong đó mỗi giá trị của tập nguồn chiếu 
đến một giá trị ở tập đích.

\item[ánh xạ đa trị:] Ánh xạ trong đó có ít nhất một giá trị ở tập nguồn chiếu 
đến nhiều giá trị ở tập đích.

\end{description}


\section{Bài tập}

\begin{ex}
\label{golf}

Một quả bóng golf\footnote{Xem
\url{http://en.wikipedia.org/wiki/Golf_ball}.} được đánh theo cú xoáy ngược 
sẽ phát sinh lực nâng, vốn có thể làm tăng tầm xa, nhưng năng lượng để 
tạo ra độ xoáy có thể sẽ làm giảm vận tốc ban đầu. Hãy viết một chương trình 
mô phỏng đường bay của một quả bóng golf rồi dùng nó để tính góc đánh 
và sự phân chia năng lượng để tạo độ xoáy và vận tốc ban đầu (từ một 
nguồn năng lượng nhất định) sao cho tầm xa theo phương ngang của quả 
bóng đạt cực đại.

Hiện tượng quả bóng xoáy bị nâng lên là do lực Magnus\footnote{Xem 
\url{http://en.wikipedia.org/wiki/Magnus_effect}.}; lực này vuông góc với 
trục quay và đường bay. Hệ số nâng tỉ lệ với tốc độ quay, và bằng khoảng 
0,1 đối với quả bóng quay được 3000 vòng/phút. Hệ số cản của quả bóng 
vào khoảng 0,2 khi quả bóng bay nhanh hơn 20 m/s.
\end{ex}



%chap12
\chapter{Bây giờ véc-tơ mới thật là véc-tơ}

\section{Véc-tơ là gì?}

Từ ``véc-tơ'' có thể mang những nghĩa khác nhau đối với từng người. Trong 
Octave, véc-tơ là một ma trận chỉ có một hàng, hoặc một cột. Cho đến giờ,
ta đã dùng các véc-tơ của Octave để biểu diễn:

\begin{description}

\item[dãy:] Dãy là một tập hợp các giá trị được nhận diện bởi các chỉ số 
nguyên; theo cách làm tự nhiên ta có thể lưu các phần tử của dãy như những 
phần tử của một véc-tơ trong Octave.

\item[véc-tơ trạng thái:] Véc-tơ trạng thái là một tập hợp các giá trị để mô tả 
trạng thái của một hệ vật lý. Khi gọi {\tt ode45}, bạn cho nó các điều kiện 
ban đầu dưới dạng một véc-tơ trạng thái. Sau đó, khi {\tt ode45} gọi hàm 
tốc độ mà bạn lập nên, nó sẽ trả kết quả là một véc-tơ trạng thái khác.

\item[ánh xạ rời rạc:] Nếu có trong tay hai véc-tơ cùng độ dài, bạn có thể hình 
dung chúng như một phép ánh xạ từ những phần tử của một véc-tơ này sang 
các phần tử thuộc véc-tơ kia. Chẳng hạn, ở Mục~\ref{rats}, kết quả thu được 
từ  {\tt ode45} là các véc-tơ, {\tt T} và {\tt Y}; chúng biểu diễn một phép 
ánh xạ từ các giá trị thời gian của {\tt T} sang các giá trị số lượng chuột có 
trong {\tt Y}.

\end{description}

Trong chương này ta sẽ xét đến một công dụng khác của véc-tơ trong Octave:
để biểu diễn các véc-tơ không gian. Một véc-tơ không gian là một giá trị nhằm 
biểu diễn một đại lượng vật lý nhiều chiều, như vị trí, vận tốc, gia tốc, hoặc 
lực\footnote{Xem
\url{http://en.wikipedia.org/wiki/Vector_(spatial)}.}.

Các đại lượng nói trên không thể diễn tả bởi một con số vì chúng có chứa 
nhiều thành phần. Chẳng hạn, trong không gian tọa độ Đề-các 3 chiều, ta cần 
phải có 3 con số mới xác định được một vị trí trong không gian, mà thường 
gọi là các tọa độ $x$, $y$ và $z$.  Một ví dụ khác, trong không gian tọa độ 
cực 2 chiều, bạn có thể xác định một vận tốc bằng hai con số, một là độ lớn 
và thứ hai là góc, thường được gọi là $r$ và $\theta$.

Biểu diễn các véc-tơ không gian bằng véc-tơ trong Octave rất tiện vì 
Octave biết cách thực hiện hầu hết các phép tính với véc-tơ phục vụ 
cho việc mô phỏng vật lý. Chẳng hạn, giả sử bạn có vận tốc của quả 
bóng chày theo dạng véc-tơ Octave với hai phần tử, $v_x$ và $v_y$,
chính là hai thành phần của vận tốc theo các phương $x$ và  $y$.

\begin{verbatim}
>> V = [30, 40];        % velocity in m/s
\end{verbatim}
%
Và giả sử rằng bạn cần phải tính gia tốc tổng hợp của quả bóng dưới tác 
dụng của lực cản không khí và trọng lực. Theo ký hiệu toán học, lực cản 
được tính bởi 

\[ F_d = -\frac{1}{2} ~ \rho ~ v^2 ~ A ~ C_d ~ \hat{V}   \]
%
trong đó  $V$ là véc-tơ không gian biểu diễn vận tốc, $v$ là độ lớn của 
vận tốc (còn được gọi là  ``tốc độ''), và $\hat{V}$ là một véc-tơ đơn vị 
theo hướng của véc-tơ vận tốc. Các đại lượng khác, $\rho$, $A$ và  $C_d$
đều là số vô hướng.

Độ lớn của véc-tơ thì bằng căn bậc hai của tổng các bình phương 
của từng phần tử. Bạn có thể tính với {\tt hypotenuse} ở Mục~\ref{hypotenuse}, 
hoặc dùng hàm Octave có tên {\tt norm} ({\bf norm}, hay chuẩn, là 
tên gọi khác \footnote{Độ lớn đôi khi cũng được gọi là độ dài 
(``length'') nhưng tôi tránh dùng từ này vì sẽ lẫn với hàm 
{\tt length} để trả lại số phần tử có trong một véc-tơ của Octave.}  
cho độ lớn của véc-tơ):

\begin{verbatim}
>> v = norm(V)
v = 50
\end{verbatim}
%
$\hat{V}$ là một {\bf véc-tơ đơn vị}, nghĩa là nó phải có chuẩn bằng 1,
và  chỉ theo cùng hướng với $V$.  Cách dễ nhất để tính véc-tơ đơn vị này là chia 
$V$ cho chuẩn của chính nó.

\begin{verbatim}
>> Vhat = V / v

Vhat =  0.60000  0.80000
\end{verbatim}
%
Bây giờ ta có thể đảm bảo rằng chuẩn của $\hat{V}$ bằng 1:

\begin{verbatim}
>> norm(Vhat)
ans = 1
\end{verbatim}
%
Để tính $F_d$ ta chỉ cần nhân các đại lượng vô hướng với $\hat{V}$.

\begin{verbatim}
Fd = - 1/2 * C * rho * A * v^2 * Vhat
\end{verbatim}
%
Tương tự như vậy, ta có thể tính gia tốc bằng cách chia véc-tơ 
$F_d$ cho số vô hướng $m$.

\begin{verbatim}
Ad = Fd / m
\end{verbatim}
%
Để biểu diễn gia tốc trọng trường, ta tạo nên một véc-tơ gồm hai 
phần tử:

\begin{verbatim}
Ag = [0; -9.8]
\end{verbatim}
%
Phần tử  $x$ của gia tốc trọng trường bằng 0; phần tử $y$ bằng 
$-$9,8 m/s${}^2$.

Cuối cùng ta tính gia tốc tổng cộng bằng cách cộng véc-tơ lại:

\begin{verbatim}
A = Ag + Ad;
\end{verbatim}
%
Một điều hay trong cách tính này là ta không cần phải nghĩ nhều về từng 
thành phần của véc-tơ. Bằng cách coi véc-tơ không gian như những đại lượng 
cơ bản, ta có thể diễn tả các phép tính phức tạp một cách ngắn gọn.


\section{Tích vô hướng và tích hữu hướng}

Việc nhân một véc-tơ với số vô hướng là quá rõ ràng; cộng hai véc-tơ cũng vậy. 
Nhưng nhân hai véc-tơ thì tinh vi hơn. Hóa ra rằng có hai phép toán véc-tơ 
trông tựa như phép nhân, đó là {\bf tích vô hướng} và {\bf tích hữu hướng}.

Tích vô hướng của hai véc-tơ $A$ và $B$ cho kết quả là số vô hướng:

\[ d = a b \cos \theta \]
%
trong đó $a$ là độ lớn của $A$, $b$ là độ lớn của $B$, còn 
$\theta$ là góc giữa hai véc-tơ. Ta đã biết cách tính các độ lớn, và có thể 
hình dung ra cách tính $\theta$, nhưng không cần thiết phải làm việc đó.  
Octave có một hàm, {\tt dot}, để tính tích vô hướng.

\begin{verbatim}
d = dot(A, B)
\end{verbatim}
%
{\tt dot} tính được với số chiều bất kì, miễn là {\tt A} và {\tt B} có cùng 
số phần tử.

Nếu một trong hai toán hạng là véc-tơ đơn vị thì bạn có thể dùng tích 
vô hướng để tính ra thành phần của véc-tơ $A$ theo hướng véc-tơ đơn vị 
$\hat{i}$ đó:

\begin{verbatim}
s = dot(A, ihat)
\end{verbatim}
%
Ở ví dụ này, $s$ là {\bf hình chiếu vô hướng} của $A$
lên phương $\hat{i}$. Còn {\bf hình chiếu véc-tơ} là một véc-tơ 
có độ lớn $s$ theo phương $\hat{i}$:

\begin{verbatim}
V = dot(A, ihat) * ihat
\end{verbatim}
%
Tích hữu hướng của hai véc-tơ $A$ và $B$ là một véc-tơ hướng 
vuông góc với $A$ và $B$ và có độ lớn:

\[ c = a b \sin \theta \]
%
trong đó (một lần nữa) $a$ là độ lớn của $A$, $b$ là độ lớn của 
$B$, còn $\theta$ là góc giữa hai véc-tơ.  Octave có một hàm, 
{\tt cross}, để tính tích hữu hướng.

\begin{verbatim}
C = cross(A, B)
\end{verbatim}
%
{\tt cross} chỉ tính được với véc-tơ 3 chiều; và kết quả cũng là một 
véc-tơ 3 chiều khác.

Một cách hay dùng của {\tt cross} là để tính các mô-men lực. Nếu bạn 
biểu diễn tay đòn mô-men $R$ và lực $F$ dưới dạng các véc-tơ 3
chiều, thì mô-men lực sẽ được tính một cách đơn giản:

\begin{verbatim}
Tau = cross(R, F)
\end{verbatim}

Nếu các thành phần của {\tt R} được tính bằng mét và các thành 
phần của {\tt F} tính bằng newton, thì các thành phần trong mô-men lực 
{\tt Tau} được tính bằng newton-mét.



\section{Cơ học thiên thể}

Việc mô hình hóa cơ học thiên thể là một dịp tốt để ta thực hiện tính 
toán với véc-tơ không gian. Hãy tưởng tượng một ngôi sao với 
khối lượng $m_1$ tại một điểm trong không gian được mô tả bởi 
véc-tơ $P_1$, và một hành tinh khối lượng $m_2$ tại điểm $P_2$.  
Độ lớn của lực hấp dẫn\footnote{See
\url{http://en.wikipedia.org/wiki/Gravity}} giữa chúng là 

\[ f_g = G \frac{m_1 m_2}{r^2}  \]
%
trong đó $r$ là khoảng cách giữa chúng, còn $G$ là hằng số hấp dẫn,
bằng khoảng $\mbox{6,67} \times 10^{-11}$ N m${}^2$ /
kg${}^2$.  Nhớ rằng đây là giá trị của $G$ chỉ trong trường hợp ta tính 
khối lượng theo ki-lô-gam, khoảng cách theo mét, và lực theo newton.

Hướng của lực lên ngôi sao tại $P_1$ là chỉ về phía $P_2$. Ta có thể 
tính hướng tương đối giữa chúng bằng cách trừ véc-tơ; nếu ta tính 
{\tt R = P2 - P1}, thì hướng của {\tt R} bây giờ sẽ chỉ từ {\tt P1} 
đến {\tt P2}.

Khoảng cách giữa hành tinh và ngôi sao là chiều dài của $R$:

\begin{verbatim}
r = norm(R)
\end{verbatim}
%
Hướng của lực tác dụng lên ngôi sao là $\hat{R}$:

\begin{verbatim}
rhat = R / r
\end{verbatim}

\begin{ex}
Hãy viết một dãy lệnh Octave để tính {\tt F12} là véc-tơ biểu diễn 
lực mà hành tinh tác dụng lên ngôi sao, và {\tt F21}, là lực do 
ngôi sao tác dụng lên hành tinh.
\end{ex}

\begin{ex}
Hãy gói các câu lệnh sau vào một hàm có tên \verb#gravity_force_func#
nhận vào các biến {\tt P1}, {\tt m1}, {\tt P2}, và {\tt m2} rồi trả lại {\tt F12}.
\end{ex}

\begin{ex}
\label{jupiter}
Hãy viết một chương trình  mô phỏng quỹ đạo của Sao Mộc quanh
Mặt Trời. Khối lượng của Mặt Trời vào khoảng $\mbox{2,0} \times 10^{30}$ kg. 
Bạn có thể lấy số liệu khối lượng của Sao Mộc cũng như khoảng cách
đến Mặt Trời và vận tốc của Sao Mộc trên quỹ đạo từ trang 
\url{http://en.wikipedia.org/wiki/Jupiter}. Chạy chương trình để
đảm bảo rằng Sao Mộc quay trọn 1 vòng quỹ đạo quanh Mặt Trời
hết khoảng 4332 ngày.
\end{ex}


\section{Tạo hình chuyển động}

Hình động là một công cụ hữu ích để kiểm tra kết quả tính toán từ
một mô hình vật lý. Nếu có gì trục trặc xảy ra, mọi sự sẽ rõ ràng
trên hình động. Có hai cách làm hình động trong Octave. Một cách
là dùng {\tt getframe} để chụp một loạt các ảnh và {\tt movie} để
phát lại chúng. Một cách làm khác, không chính thức, là vẽ một loạt
các hình đồ thị. Sau đây là một ví dụ tôi viết cho Bài tập~\ref{jupiter}:

\begin{verbatim}
function animate_func(T,M)
    % animate the positions of the planets, assuming that the
    % columns of M are x1, y1, x2, y2.
    X1 = M(:,1);
    Y1 = M(:,2);
    X2 = M(:,3);
    Y2 = M(:,4);

    minmax = [min([X1;X2]), max([X1;X2]), min([Y1;Y2]), max([Y1;Y2])];

    for i=1:length(T)
        clf;
        axis(minmax);
        hold on;
        draw_func(X1(i), Y1(i), X2(i), Y2(i));
        drawnow;
    end
end
\end{verbatim}
%
Các biến đầu vào là kết quả đầu ra từ {\tt ode45}, một véc-tơ
{\tt T} và một ma trận {\tt M}. Các cột của {\tt M} chứa các
vị trí và vận tốc của Mặt Trời và Sao Mộc, vì vậy
{\tt X1} và {\tt Y1} nhận các tọa độ của Mặt Trời; còn
{\tt X2} và {\tt Y2} nhận các tọa độ của Sao Mộc.

{\tt minmax}  là một véc-tơ gồm 4 phần tử được dùng bên trong 
vòng lặp để thiết lập các trục trên biểu đồ. Thông tin này cần thiết
bởi vì nếu không, Octave sẽ tự co dãn hình mỗi lần qua một
lượt lặp, và các trục sẽ luôn thay đổi, dẫn đến khó theo dõi
hình động.

Qua mỗi lượt lặp, \verb#animate_func# dùng {\tt clf}
để xóa hình và {\tt axis} để đặt lại các trục.  {\tt hold on} 
giúp ta có thể vẽ được nhiều đường đồ thị lên cùng một 
hệ trúc (nếu không Octave sẽ tự xóa hình mỗi lần
bạn gọi câu lệnh {\tt plot} mới).

Cũng qua mỗi lượt lặp, ta phải gọi {\tt drawnow} để
Octave thực sự hiển thị từng hình vẽ. Còn nếu không, nó sẽ
đợi đến tận khi bạn vẽ xong hết các hình {\em rồi mới} 
cập nhật quá trình hiển thị.

\verb#draw_func# là hàm số đảm nhiệm việc vẽ đồ thị:

\begin{verbatim}
function draw_func(x1, y1, x2, y2)
    plot(x1, y1, 'r.', 'MarkerSize', 50);
    plot(x2, y2, 'b.', 'MarkerSize', 20);
end
\end{verbatim}
%
Các biến đầu vào là vị trí của Mặt Trời và Sao Mộc. \verb#draw_func#
dùng {\tt plot} để vẽ Mặt Trời như một dấu đỏ lớn và Sao Mộc như
một dấu xanh lam nhỏ hơn.

\begin{ex}
Để chắc rằng bạn hiểu được cách hoạt động của \verb#animate_func#,
hãy thử chú thích để loại ra một số dòng lệnh xem điều gì xảy ra.
\end{ex}

Một hạn chế của kiểu hình động này là tốc độ của hình động phụ thuộc
vào máy của bạn thực hiện việc vẽ hình lúc nào. Vì kết quả từ
{\tt ode45} thường không xuất ra đều theo thời gian nên hình động
có thể sẽ chậm lại khi {\tt ode45} nhận bước thời gian ngắn và
nhanh lên khi bước thời gian dài hơn.

Có hai cách sửa vấn đề này:

\begin{enumerate}

\item Khi gọi {\tt ode45} bạn có thể chỉ định một véc-tơ chứa các thời điểm
cần phải tính kết quả. Sau đây là một ví dụ:

\begin{verbatim}
end_time = 1000;
step = end_time/200;
[T, M] = ode45(@rate_func, [0:step:end_time], W);
\end{verbatim}
%
Đối số thứ hai là một véc-tơ khoảng số chạy từ 0 đến 1000 với bước chạy
quy định bởi {\tt step}.  Vì {\tt step} bằng \verb#end_time/200#, nên
sẽ có khoảng 200 hàng trong {\tt T} và {\tt M} (chính xác là 201).

Tùy chọn này sẽ không ảnh hưởng đến độ chính xác của kết quả; 
{\tt ode45} vẫn dùng biến thời gian để thực hiện ước tính, nhưng rồi
nó sẽ nội suy các giá trị trước khi trả lại kết quả.

\item Bạn có thể dùng {\tt pause} để chạy hình động theo đúng thời
gian thật. Sau khi vẽ từng hình và gọi nó {\tt drawnow}, bạn có thể
tính thời gian từ đó đến hình kế tiếp và dùng {\tt pause} để đợi:

\begin{verbatim}
dt = T(i+1) - T(i);
pause(dt);
\end{verbatim}
%
Một hạn chế của phương pháp này là nó bỏ qua thời gian cần để
vẽ hình, vì vậy nó có xu hướng chạy chậm, đặc biệt nếu hình vẽ 
phức tạp hoặc bước thời gian quá ngắn.

\end{enumerate}

\begin{ex}
Hãy dùng \verb#animate_func# và \verb#draw_func# để hiển thị
kết quả mô phỏng Sao Mộc. Sửa các hàm này để sao cho thời gian
một ngày mô phỏng tương đương với 0,001 giây đồng hồ---mỗi
vòng quay sẽ mất khoảng 4,3 giây.
\end{ex}


\section{Bảo toàn năng lượng}

Một cách làm tiện dụng để kiểm tra độ chính xác của một chương trình
giải PVT là xem nó có bảo toàn được năng lượng của hệ hay không.
Với chuyển động của hành tinh, hóa ra là {\tt ode45} không thể
bảo toàn được.

Động năng của một vật chuyển động bằng $m v^2 / 2$; động năng
của hệ Mặt Trời thì bằng tổng các động năng của từng hành tinh và của 
Mặt Trời. Thế năng của Mặt Trời với khối lượng $m_1$ và một hành tinh
có khối lượng $m_2$ cách nhau một khoảng $r$ thì bằng:

\[ U = -G \frac{m_1 m_2}{r}  \]
%

\begin{ex}
Hãy viết một hàm có tên \verb#energy_func# để nhận vào các kết quả 
{\tt T} và {\tt M} từ chương trình mô phỏng Sao Mộc, rồi tính tổng
năng lượng (động năng và thế năng) của hệ với mỗi vị trí và vận tốc
ước tính được. Vẽ đồ thị của kết quả này như một hàm theo thời gian
và đảm bảo rằng nó giảm dần trong quá trình mô phỏng. Hàm cần viết
phải tính được sự thay đổi tương đối về năng lượng, độ chênh lệch giữa
năng lượng ban đầu và lúc kết thúc, và biểu thị độ chênh này theo phần
trăm so với năng lượng ban đầu.
\end{ex}

Bạn có thể giảm tốc độ thất thoát năng lượng bằng cách giảm tùy chọn
dung sai của {\tt ode45} qua việc dùng {\tt odeset} (xem Mục~\ref{events}):

\begin{verbatim}
options = odeset('RelTol', 1e-5);
[T, M] = ode45(@rate_func, [0:step:end_time], W, options);
\end{verbatim}
%
Tên của tùy chọn cần chỉnh là {\tt RelTol}, viết tắt của ``relative tolerance''
(dung sai tương đối). Giá trị mặc định là {\tt 1e-3} hay 0,001.  Các giá trị
nhỏ hơn sẽ khiến cho {\tt ode45} thêm ``khắt khe'', vì vậy cần hàm sẽ
cần tính nhiều hơn để giảm nhỏ sai số.

\begin{ex}
Hãy chạy {\tt ode45} với một loạt các giá trị của {\tt RelTol} và đảm bảo rằng
khi dung sai càng nhỏ thì tốc độ thất thoát năng lượng cũng chậm lại.
\end{ex}

\begin{ex}
Hãy chạy chương trình mô phỏng bạn viết với một trong các hàm giải ODE
khác có trong Octave và xem chúng có bảo toàn năng lượng không.
\end{ex}

% \section{Scaling}

% \section{Polar coordinates}

\section{Mô hình dùng để làm gì?}

Trong mục~\ref{modeling}, tôi đã định nghĩa một ``mô hình'' như một
sự mô tả được giản hóa về một hệ vật lý, và đề cập rằng một mô hình
tốt rất thích hợp cho việc phân tích và mô phỏng, và khiến cho các 
ước tính đủ độ tin cậy để dùng cho mục đích định trước.

Từ đó, ta đã thấy một số ví dụ; bây giờ ta có thể nói thêm những công
dụng của mô hình. Các mục đích mà mô hình cần đạt đến thường có
xu hướng rơi vào ba dạng sau.
 
\begin{description}

\item[dự đoán:] Một số mô hình có thể dự đoán về các hệ vật lý. Lấy
một ví dụ đơn giản, mô hình con vịt ở Bài tập~\ref{duck} dự đoán về
độ cao mà con vịt sẽ nổi. Ở phía đầu kia xét về độ phức tạp, mô hình
khí tượng toàn cầu dự đoán tình hình thời tiết hàng mười năm hoặc
trăm năm trong tương lai.

\item[thiết kế:] Mô hình rất có ích trong thiết kế kĩ thuật, đặc biệt
là để kiểm tra tính khả thi của một phương án thiết kế, và để 
tối ưu hóa. Chẳng hạn, trong Bài tập~\ref{golf} bạn được yêu cầu
phải thiết kế cú đánh golf với sự kết hợp hoàn hảo giữa góc vụt,
vận tốc và độ xoáy.

\item[giải thích:] Mô hình có thể giải thích các câu hỏi khoa học.
Chẳng hạn, mô hình Lotka-Volterra trong Mục~\ref{lotka} đề xuất
một lời giải thích cho cơ chế biến động của hệ quần thể động vật
dưới hình thức các mối tương tác giữa loài ăn thịt và vật mồi.

\end{description}

Các ví dụ ở cuối chương này sẽ gồm mỗi mô hình theo từng loại
kể trên.


\section{Thuật ngữ}

\begin{description}

\item[véc-tơ không gian:] Một giá trị dùng để biểu thị một đại lượng
vật lý gồm nhiều chiều; chẳng hạn vị trí, vận tốc, gia tốc, và lực.

\item[chuẩn:] Độ lớn của một véc-tơ. Đôi khi còn được gọi là ``độ dài,''
nhưng không được nhầm với số phần tử thuộc một véc-tơ trong Octave.

\item[véc-tơ đơn vị:] Véc-tơ có chuẩn bằng 1, dùng để biểu thị hướng.

\item[tích vô hướng:] Số vô hướng, là kết quả phép nhân hai véc-tơ, nó tỉ lệ với
độ lớn của từng véc-tơ và cô-sin của góc giữa chúng.

\item[tích hữu hướng:] Véc-tơ là kết quả phép nhân hai véc-tơ khác, với
chuẩn tỉ lệ với chuẩn của từng véc-tơ và với sin của góc giữa chúng,
và có hướng vuông góc với cả hai véc-tơ.

\item[hình chiếu:] Thành phần của một véc-tơ xét theo hướng của véc-tơ
kia (có thể được dùng với nghĩa ``hình chiếu vô hướng'' hay
``hình chiếu véc-tơ'').

\end{description}


\section{Bài tập}

\begin{ex}
Nếu bạn đặt hai bát nước giống hệt nhau vào ngăn đá tủ lạnh, nước ở
trong một bát thì ở nhiệt độ bình thường còn ở bát kia thì đang sôi, liệu
bát nước nào sẽ đông đá trước?

Gợi ý: bạn có thể sẽ cần tìm hiểu thêm về hiệu ứng Mpemba.

% You might have to do some research on thermal expansion\footnote{See
% \url{http://en.wikipedia.org/wiki/Thermal_expansion}.},
% cooling\footnote{See
% \url{http://en.wikipedia.org/wiki/Heat_conduction}.},
% evaporation\footnote{See
% \url{http://en.wikipedia.org/wiki/Evaporation}.} and
% freezing\footnote{See \url{http://en.wikipedia.org/wiki/Freezing}.},
% and think about which factors you have to include in the model and
% which you can ignore.
\end{ex}

\begin{ex}
Bạn được yêu cầu phải thiết kế một dường dốc để trượt ván; khác với
những dốc trượt thông thường, cái này có thể xoay (kiểu bập bênh) quanh
một chốt cố định. Người trượt ván tiến đến đường dốc, trước đó còn đi
trên đất bằng, rồi lập tức leo dốc; họ không được phép đặt chân xuống.
Nếu họ trượt đủ nhanh thì đường dốc sẽ xoay và họ sẽ chuyển tư thế
thành trượt xuống một cách nhẹ nhàng. Sẽ có ban giám khảo chấm điểm
kĩ thuật và nghệ thuật cho động tác trượt.

Việc của bạn là thiết kế một dốc trượt để cho phép người trượt hoàn thành
bài biểu diễn này, và tạo ra một mô hình vật lý của hệ, một chương trình
mô phỏng để tính ra chuyển động của người trượt trên dốc, và hình động
biểu diễn kết quả tính được.
\end{ex}

\begin{ex}
\label{binary}

Một hệ hai sao bao gồm hai ngôi sao quay xung quanh lẫn nhau và
đôi khi có cả những hành tinh quay quanh từng ngôi sao
\footnote{Xem \url{http://en.wikipedia.org/wiki/Binary_star}.}. Trong
hệ hai sao, một số quỹ đạo là ``bền vững'' theo nghĩa một hành tinh
có thể bay trong quỹ đạo đó mà không bị đâm vào một trong hai sao,
và không bị bay tuốt vào không trung.

Mô phỏng là công cụ có ích phục vụ cho việc nghiên cứu bản chất
của các quỹ đạo này, như đề cập đến trong Holman, M.J. and P.A. 
Wiegert, 1999, ``Long-Term Stability
of Planets in Binary Systems,''  {\em Astronomical Journal} 117, 
có thể tải về từ \url{http://citeseer.ist.psu.edu/358720.html}.

Hãy đọc bài báo này rồi sửa lại chương trình mô phỏng hành tinh
đã viết để lặp lại hoặc mở rộng kết quả.
\end{ex}

\newpage

%\blankpage
%\blankpage
%\blankpage

\end{document}



